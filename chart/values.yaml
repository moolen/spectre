nameOverride: ""
fullnameOverride: ""
namespace: monitoring

image:
  repository: ghcr.io/moolen/spectre
  tag: latest
  pullPolicy: IfNotPresent
  pullSecrets: []

replicaCount: 1

updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 1

minReadySeconds: 0

revisionHistoryLimit: 5

resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# Service configuration
# Port allocation:
#   - 8080: HTTP REST API with gRPC-Web support (main service)
#   - 8082: MCP HTTP server (sidecar)
#   - 9999: pprof profiling endpoint
service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}
  labels: {}
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  externalTrafficPolicy: ""
  sessionAffinity: None
  sessionAffinityConfig: {}

# Pprof profiling configuration
pprof:
  enabled: false
  port: 9999

# OpenTelemetry tracing configuration
tracing:
  enabled: false
  endpoint: ""  # OTLP gRPC endpoint (e.g., "victorialogs:4317")

# MCP (Model Context Protocol) sidecar configuration
mcp:
  enabled: true
  spectreURL: "http://localhost:8080"  # Connect to main container via localhost (REST API)
  httpAddr: ":8082"
  port: 8082
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "256Mi"
      cpu: "200m"
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1000
  livenessProbe:
    enabled: true
    httpGet:
      path: /health
      port: mcp
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    enabled: true
    httpGet:
      path: /health
      port: mcp
    initialDelaySeconds: 3
    periodSeconds: 5
    timeoutSeconds: 2
    failureThreshold: 3
    successThreshold: 1

# Graph reasoning layer configuration
graph:
  # Enable graph-based reasoning features
  enabled: true


  # FalkorDB configuration (graph database)
  falkordb:
    # Deploy FalkorDB as a sidecar container
    sidecar: true

    # FalkorDB image
    image:
      repository: falkordb/falkordb
      tag: "v4.14.10-alpine"
      pullPolicy: IfNotPresent

    # Graph database name
    graphName: "spectre"

    # Redis port (FalkorDB uses Redis protocol)
    port: 6379

    # Resources for FalkorDB container
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "1Gi"
        cpu: "500m"

    # Security context
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      readOnlyRootFilesystem: false
      runAsNonRoot: true
      runAsUser: 999  # FalkorDB user

    # Persistence for graph data
    persistence:
      enabled: true
      size: 5Gi
      mountPath: /var/lib/falkordb/data
      # storageClassName: ""  # Use default storage class
      accessModes:
        - ReadWriteOnce

    # Health check configuration
    livenessProbe:
      enabled: true
      exec:
        command:
          - redis-cli
          - ping
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3
      successThreshold: 1

    readinessProbe:
      enabled: true
      exec:
        command:
          - redis-cli
          - ping
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3
      successThreshold: 1

  # Graph sync pipeline configuration
  sync:
    # Retention window for graph data (in hours)
    retentionHours: 24

    # Rebuild graph on startup
    rebuildOnStart: true

    # Only rebuild if graph is empty
    rebuildIfEmptyOnly: true

    # Time window for rebuild (in hours)
    rebuildWindowHours: 24

    # Batch size for event processing
    batchSize: 100

    # Batch timeout (in seconds)
    batchTimeoutSeconds: 5

# Persistent storage configuration (deprecated - storage package removed)
persistence:
  enabled: false
  size: 10Gi
  mountPath: /data
  # storageClassName: "" # Use default storage class if not specified
  accessModes:
    - ReadWriteOnce
  annotations: {}
  selector: {}
  existingClaim: ""

config:
  logLevel: "info"
  # Per-package log level overrides
  # Supports exact package names and wildcard patterns (*.suffix)
  # Examples:
  #   graph.sync: "debug"      # Exact match for graph.sync package
  #   graph.*: "debug"         # Wildcard pattern for all graph.* packages
  #   controller: "warn"       # Only warn and above for controller
  # If a package matches multiple patterns, the most specific pattern wins
  # Packages not listed use the default logLevel above
  logLevels: {}
    # graph.sync: "debug"
    # graph.*: "debug"
    # controller: "warn"
  maxConcurrentRequests: 100
  # Watcher configuration - resources to watch
  # Each resource specifies Group/Version/Kind and optional namespace
  watcher:
    resources:
      - group: ""
        version: "v1"
        kind: "Pod"
      - group: "apps"
        version: "v1"
        kind: "ReplicaSet"
      - group: "apps"
        version: "v1"
        kind: "Deployment"
      - group: ""
        version: "v1"
        kind: "Service"
      - group: ""
        version: "v1"
        kind: "Node"
      - group: "apps"
        version: "v1"
        kind: "StatefulSet"
      - group: "apps"
        version: "v1"
        kind: "DaemonSet"
      - group: ""
        version: "v1"
        kind: "ConfigMap"
      - group: "networking.k8s.io"
        version: "v1"
        kind: "NetworkPolicy"
      - group: "networking.k8s.io"
        version: "v1"
        kind: "Ingress"
      - group: "helm.toolkit.fluxcd.io"
        version: "v2"
        kind: "HelmRelease"
      - group: "kustomize.toolkit.fluxcd.io"
        version: "v1"
        kind: "Kustomization"
      - group: "source.toolkit.fluxcd.io"
        version: "v1"
        kind: "HelmRepository"
      - group: "source.toolkit.fluxcd.io"
        version: "v1"
        kind: "GitRepository"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000

livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  enabled: true
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  enabled: false
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 30
  successThreshold: 1

podAnnotations: {}
podLabels: {}
priorityClassName: ""
terminationGracePeriodSeconds: 15
dnsPolicy: ClusterFirst
dnsConfig: {}
hostAliases: []
hostNetwork: false
hostPID: false
hostIPC: false
nodeSelector: {}
tolerations: []
affinity: {}
topologySpreadConstraints: []

serviceAccount:
  create: true
  name: ""  # Will use "spectre" if not specified
  annotations: {}
  automountServiceAccountToken: true

extraArgs: []

extraVolumes: []
extraVolumeMounts: []

env: []
envFrom: []
lifecycle: {}
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: spectre.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
  mcp:
    enabled: false
    host: mcp.spectre.example.com
    paths:
      - path: /
        pathType: Prefix
    tls: []

serviceMonitor:
  enabled: false
  namespace: ""
  labels: {}
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  relabelings: []
  metricRelabelings: []

podDisruptionBudget:
  enabled: false
  minAvailable: 1
