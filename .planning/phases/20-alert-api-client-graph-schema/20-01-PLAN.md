---
phase: 20-alert-api-client-graph-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/graph/models.go
  - internal/integration/grafana/client.go
autonomous: true

must_haves:
  truths:
    - "Alert nodes exist in FalkorDB graph with metadata (name, severity, labels)"
    - "GrafanaClient can fetch alert rules from Grafana Alerting API"
    - "Alert rules include PromQL expressions that can be parsed for metric extraction"
  artifacts:
    - path: "internal/graph/models.go"
      provides: "Alert node types and MONITORS edge type"
      contains: "NodeTypeAlert"
      exports: ["NodeTypeAlert", "EdgeTypeMonitors", "AlertNode"]
    - path: "internal/integration/grafana/client.go"
      provides: "Alert rule API methods"
      exports: ["ListAlertRules", "GetAlertRule", "AlertRuleMeta", "AlertRule"]
  key_links:
    - from: "internal/integration/grafana/client.go"
      to: "Grafana Alerting API"
      via: "/api/v1/provisioning/alert-rules HTTP endpoint"
      pattern: "api/v1/provisioning/alert-rules"
    - from: "internal/graph/models.go"
      to: "internal/integration/grafana/alert_syncer.go"
      via: "AlertNode type usage"
      pattern: "graph\\.AlertNode"
---

<objective>
Add Alert node schema to FalkorDB graph and extend GrafanaClient with alert rules API methods.

Purpose: Establish the foundation for alert rule synchronization by defining the graph schema for Alert nodes and providing HTTP client methods to fetch alert rules from Grafana Alerting API. This follows the established dashboard sync pattern.

Output: Alert node types in graph schema, HTTP client methods for listing and fetching alert rules, ready for AlertSyncer implementation in Plan 20-02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-alert-api-client-graph-schema/20-RESEARCH.md
@internal/graph/models.go
@internal/integration/grafana/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Alert node type and MONITORS edge to graph schema</name>
  <files>internal/graph/models.go</files>
  <action>
Add Alert node type to graph schema following the established Dashboard/Panel/Query/Metric pattern.

**Add to NodeType constants (around line 20):**
```go
NodeTypeAlert    NodeType = "Alert"
```

**Add to EdgeType constants (around line 50):**
```go
EdgeTypeMonitors EdgeType = "MONITORS" // Alert -> Metric
```

**Add AlertNode struct after VariableNode (around line 151):**
```go
// AlertNode represents a Grafana Alert Rule node in the graph
type AlertNode struct {
    UID          string            `json:"uid"`          // Alert rule UID (primary key)
    Title        string            `json:"title"`        // Alert rule title
    RuleGroup    string            `json:"ruleGroup"`    // Rule group name
    FolderUID    string            `json:"folderUID"`    // Folder UID
    Labels       map[string]string `json:"labels"`       // Alert labels (includes severity)
    Annotations  map[string]string `json:"annotations"`  // Alert annotations
    Condition    string            `json:"condition"`    // Condition expression RefID
    NoDataState  string            `json:"noDataState"`  // "OK", "NoData", "Alerting"
    ExecErrState string            `json:"execErrState"` // "OK", "Alerting"
    ForDuration  string            `json:"forDuration"`  // Duration string (e.g., "5m")
    Updated      int64             `json:"updated"`      // Unix nano timestamp (for incremental sync)
    FirstSeen    int64             `json:"firstSeen"`    // Unix nano timestamp
    LastSeen     int64             `json:"lastSeen"`     // Unix nano timestamp
}
```

**Why this structure:**
- UID as primary key (same pattern as Dashboard)
- Updated timestamp for incremental sync (same pattern as Dashboard.version)
- Labels/Annotations as maps (stored as JSON strings in graph)
- NoDataState and ExecErrState for alert configuration metadata
- FirstSeen/LastSeen for temporal tracking (consistent with other nodes)

**Do NOT:**
- Add alert state fields (firing/pending/normal) - deferred to Phase 21
- Add direct Alertâ†’Service edges - use transitive queries through Metric nodes
- Store PromQL expressions in Alert node - stored in graph Data array structure
  </action>
  <verify>
```bash
grep -n "NodeTypeAlert" internal/graph/models.go
grep -n "EdgeTypeMonitors" internal/graph/models.go
grep -n "type AlertNode struct" internal/graph/models.go
```

All three patterns should be found. AlertNode should have 14 fields (UID through LastSeen).
  </verify>
  <done>
Alert node types added to graph schema with NodeTypeAlert constant, EdgeTypeMonitors constant, and AlertNode struct with 14 fields matching Grafana Alerting API structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Grafana Alerting API client methods (ListAlertRules, GetAlertRule)</name>
  <files>internal/integration/grafana/client.go</files>
  <action>
Add HTTP client methods for Grafana Alerting Provisioning API following the established ListDashboards/GetDashboard pattern.

**Add types after QueryResponse (around line 231):**
```go
// AlertRuleMeta represents an alert rule in the list response
type AlertRuleMeta struct {
    UID       string            `json:"uid"`
    Title     string            `json:"title"`
    RuleGroup string            `json:"ruleGroup"`
    FolderUID string            `json:"folderUID"`
    Updated   time.Time         `json:"updated"`
    Labels    map[string]string `json:"labels"`
}

// AlertRule represents a full alert rule from the Grafana Alerting API
type AlertRule struct {
    UID          string                 `json:"uid"`
    Title        string                 `json:"title"`
    RuleGroup    string                 `json:"ruleGroup"`
    FolderUID    string                 `json:"folderUID"`
    NoDataState  string                 `json:"noDataState"`  // "OK", "NoData", "Alerting"
    ExecErrState string                 `json:"execErrState"` // "OK", "Alerting"
    For          string                 `json:"for"`          // Duration string: "5m", "1h"
    Condition    string                 `json:"condition"`    // RefId of condition expression
    Labels       map[string]string      `json:"labels"`
    Annotations  map[string]string      `json:"annotations"`
    Updated      time.Time              `json:"updated"`
    Data         []AlertQueryOrExpr     `json:"data"` // Query/expression array
}

// AlertQueryOrExpr represents a query or expression in an alert rule
type AlertQueryOrExpr struct {
    RefID         string                 `json:"refId"`
    QueryType     string                 `json:"queryType,omitempty"` // "" for Prometheus, "expression" for reducers
    DatasourceUID string                 `json:"datasourceUid"`
    Model         map[string]interface{} `json:"model"` // Contains "expr" for PromQL queries
}
```

**Add ListAlertRules method after ListDatasources (around line 355):**
```go
// ListAlertRules retrieves all alert rules from Grafana.
// Uses /api/v1/provisioning/alert-rules endpoint (Grafana Unified Alerting).
func (c *GrafanaClient) ListAlertRules(ctx context.Context) ([]AlertRuleMeta, error) {
    // Build request URL
    reqURL := fmt.Sprintf("%s/api/v1/provisioning/alert-rules", c.config.URL)
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
    if err != nil {
        return nil, fmt.Errorf("create list alert rules request: %w", err)
    }

    // Add Bearer token authentication if using secret watcher
    if c.secretWatcher != nil {
        token, err := c.secretWatcher.GetToken()
        if err != nil {
            return nil, fmt.Errorf("failed to get API token: %w", err)
        }
        req.Header.Set("Authorization", "Bearer "+token)
    }

    // Execute request
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("execute list alert rules request: %w", err)
    }
    defer resp.Body.Close()

    // CRITICAL: Always read response body to completion for connection reuse
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("read response body: %w", err)
    }

    // Check HTTP status code
    if resp.StatusCode != http.StatusOK {
        c.logger.Error("Grafana list alert rules failed: status=%d body=%s", resp.StatusCode, string(body))
        return nil, fmt.Errorf("list alert rules failed (status %d): %s", resp.StatusCode, string(body))
    }

    // Parse JSON response
    var alertRules []AlertRuleMeta
    if err := json.Unmarshal(body, &alertRules); err != nil {
        return nil, fmt.Errorf("parse alert rules response: %w", err)
    }

    c.logger.Debug("Listed %d alert rules from Grafana", len(alertRules))
    return alertRules, nil
}

// GetAlertRule retrieves a full alert rule by UID.
// Uses /api/v1/provisioning/alert-rules/{uid} endpoint.
func (c *GrafanaClient) GetAlertRule(ctx context.Context, uid string) (*AlertRule, error) {
    // Build request URL
    reqURL := fmt.Sprintf("%s/api/v1/provisioning/alert-rules/%s", c.config.URL, uid)
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
    if err != nil {
        return nil, fmt.Errorf("create get alert rule request: %w", err)
    }

    // Add Bearer token authentication if using secret watcher
    if c.secretWatcher != nil {
        token, err := c.secretWatcher.GetToken()
        if err != nil {
            return nil, fmt.Errorf("failed to get API token: %w", err)
        }
        req.Header.Set("Authorization", "Bearer "+token)
    }

    // Execute request
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("execute get alert rule request: %w", err)
    }
    defer resp.Body.Close()

    // CRITICAL: Always read response body to completion for connection reuse
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("read response body: %w", err)
    }

    // Check HTTP status code
    if resp.StatusCode != http.StatusOK {
        c.logger.Error("Grafana get alert rule failed: status=%d body=%s", resp.StatusCode, string(body))
        return nil, fmt.Errorf("get alert rule failed (status %d): %s", resp.StatusCode, string(body))
    }

    // Parse JSON response
    var alertRule AlertRule
    if err := json.Unmarshal(body, &alertRule); err != nil {
        return nil, fmt.Errorf("parse alert rule response: %w", err)
    }

    c.logger.Debug("Retrieved alert rule %s from Grafana", uid)
    return &alertRule, nil
}
```

**Why this implementation:**
- Follows exact pattern from ListDashboards/GetDashboard (connection pooling, Bearer auth, error handling)
- Uses Unified Alerting Provisioning API (/api/v1/provisioning/alert-rules) not legacy API
- Updated field is time.Time for comparison (converted to UnixNano for graph storage)
- AlertQueryOrExpr.Model is map[string]interface{} for flexible PromQL extraction
- CRITICAL comment on ReadAll for connection reuse (existing pattern from research)

**Do NOT:**
- Use legacy alert API (/api/alerts) - deprecated in Grafana 9+
- Parse PromQL in client methods - deferred to AlertSyncer/GraphBuilder
- Fetch alert state here - alert state is Phase 21, this is rule definitions only
  </action>
  <verify>
```bash
# Verify types added
grep -n "type AlertRuleMeta struct" internal/integration/grafana/client.go
grep -n "type AlertRule struct" internal/integration/grafana/client.go
grep -n "type AlertQueryOrExpr struct" internal/integration/grafana/client.go

# Verify methods added
grep -n "func (c \*GrafanaClient) ListAlertRules" internal/integration/grafana/client.go
grep -n "func (c \*GrafanaClient) GetAlertRule" internal/integration/grafana/client.go

# Verify endpoint correctness
grep "api/v1/provisioning/alert-rules" internal/integration/grafana/client.go
```

All types and methods should be found. Endpoint should use v1 provisioning API (not legacy /api/alerts).
  </verify>
  <done>
GrafanaClient extended with ListAlertRules and GetAlertRule methods using Grafana Unified Alerting Provisioning API. Types added: AlertRuleMeta, AlertRule, AlertQueryOrExpr. Methods follow established HTTP client pattern with Bearer auth and connection reuse.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compile check:**
```bash
cd /home/moritz/dev/spectre-via-ssh
go build ./internal/graph
go build ./internal/integration/grafana
```
Both should compile without errors.

2. **Schema verification:**
```bash
grep -A 15 "type AlertNode struct" internal/graph/models.go
```
Should show AlertNode with 14 fields: UID, Title, RuleGroup, FolderUID, Labels, Annotations, Condition, NoDataState, ExecErrState, ForDuration, Updated, FirstSeen, LastSeen.

3. **API client verification:**
```bash
grep -A 5 "type AlertRule struct" internal/integration/grafana/client.go
grep "api/v1/provisioning/alert-rules" internal/integration/grafana/client.go | wc -l
```
Should show AlertRule struct and at least 2 occurrences of provisioning API endpoint (ListAlertRules and GetAlertRule).

4. **Edge type verification:**
```bash
grep "EdgeTypeMonitors" internal/graph/models.go
```
Should show EdgeTypeMonitors constant and comment indicating Alert -> Metric relationship.
</verification>

<success_criteria>
- [ ] NodeTypeAlert, EdgeTypeMonitors constants added to graph/models.go
- [ ] AlertNode struct added with 14 fields matching Grafana Alerting API structure
- [ ] AlertRuleMeta, AlertRule, AlertQueryOrExpr types added to client.go
- [ ] ListAlertRules method added to GrafanaClient (returns []AlertRuleMeta)
- [ ] GetAlertRule method added to GrafanaClient (returns *AlertRule)
- [ ] Both methods use /api/v1/provisioning/alert-rules endpoint (Unified Alerting API)
- [ ] Both methods follow established HTTP client pattern (Bearer auth, connection reuse, error handling)
- [ ] Code compiles without errors (go build ./internal/graph ./internal/integration/grafana)
</success_criteria>

<output>
After completion, create `.planning/phases/20-alert-api-client-graph-schema/20-01-SUMMARY.md` documenting:
- Graph schema extensions (NodeTypeAlert, EdgeTypeMonitors, AlertNode struct)
- GrafanaClient API methods (ListAlertRules, GetAlertRule)
- Type definitions (AlertRuleMeta, AlertRule, AlertQueryOrExpr)
- Alignment with research recommendations (Unified Alerting API, updated timestamp pattern)
- Integration points for Plan 20-02 (AlertSyncer will use these types and methods)
</output>
