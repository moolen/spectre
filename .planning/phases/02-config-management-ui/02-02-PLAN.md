---
phase: 02-config-management-ui
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/src/pages/IntegrationsPage.tsx
  - ui/src/components/IntegrationModal.tsx
  - ui/src/components/IntegrationTable.tsx
  - ui/src/components/IntegrationConfigForm.tsx
autonomous: true

must_haves:
  truths:
    - "User sees '+ Add Integration' button on IntegrationsPage"
    - "Clicking button opens modal with integration type selection"
    - "User can fill config form (name, type, URL) and save"
    - "Saved integrations appear in table (not tiles)"
    - "Table shows Name, Type, URL, Date Added, Status columns"
    - "Clicking table row opens edit modal"
    - "Test Connection button validates config before save"
    - "User can delete integration via Delete button in modal"
  artifacts:
    - path: "ui/src/components/IntegrationModal.tsx"
      provides: "Modal for add/edit integration with portal rendering"
      min_lines: 150
      exports: ["IntegrationModal"]
    - path: "ui/src/components/IntegrationTable.tsx"
      provides: "Table view with health status indicators"
      min_lines: 100
      exports: ["IntegrationTable"]
    - path: "ui/src/components/IntegrationConfigForm.tsx"
      provides: "Type-specific config forms (VictoriaLogs, etc)"
      min_lines: 80
      exports: ["IntegrationConfigForm"]
    - path: "ui/src/pages/IntegrationsPage.tsx"
      provides: "Updated page with modal state management and API integration"
      contains: "useState.*isModalOpen"
  key_links:
    - from: "ui/src/pages/IntegrationsPage.tsx"
      to: "/api/config/integrations"
      via: "fetch calls in useEffect and handleSave"
      pattern: "fetch.*api/config/integrations"
    - from: "ui/src/components/IntegrationModal.tsx"
      to: "/api/config/integrations/{name}/test"
      via: "Test Connection button handler"
      pattern: "fetch.*test"
    - from: "ui/src/components/IntegrationModal.tsx"
      to: "/api/config/integrations/{name}"
      via: "Delete button handler with DELETE method"
      pattern: "fetch.*DELETE|method.*DELETE"
    - from: "ui/src/components/IntegrationTable.tsx"
      to: "IntegrationModal"
      via: "onEdit callback from row click"
      pattern: "onClick.*onEdit"
---

<objective>
Build React UI for integration management with modal-based add/edit flow and table view.

Purpose: User-facing interface for managing integrations. Replaces mock tiles with functional CRUD UI backed by REST API. Modal provides guided flow with connection testing. Table shows runtime status.

Output: Working UI where users can add/edit/delete integrations, test connections, and see health status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-config-management-ui/02-CONTEXT.md
@.planning/phases/02-config-management-ui/02-RESEARCH.md

# Existing UI patterns
@ui/src/pages/IntegrationsPage.tsx
@ui/src/components/Sidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IntegrationModal component with portal rendering</name>
  <files>
    ui/src/components/IntegrationModal.tsx
  </files>
  <action>
Create modal component in ui/src/components/IntegrationModal.tsx:

1. Interface definitions:
   ```tsx
   interface IntegrationConfig {
     name: string;
     type: string;
     enabled: boolean;
     config: Record<string, any>;
   }

   interface IntegrationModalProps {
     isOpen: boolean;
     onClose: () => void;
     onSave: (config: IntegrationConfig) => Promise<void>;
     onDelete?: (name: string) => Promise<void>;
     initialConfig?: IntegrationConfig;
   }
   ```

2. Modal implementation using React portal:
   - Use createPortal from 'react-dom' to render modal at document.body
   - State: config (IntegrationConfig), isTesting (boolean), testResult ({success, message} | null)
   - Focus management: useEffect to trap focus and handle Escape key
   - Backdrop click closes modal (stopPropagation on modal content)

3. Modal structure:
   - Header: "Add Integration" or "Edit Integration" + close button (Ã—)
   - Body: IntegrationConfigForm component (pass config and onChange callback)
   - Test result display: Success/error badge with message (conditional render)
   - Footer: "Test Connection", "Save", "Cancel" buttons
   - Footer (edit mode only): "Delete" button (left-aligned, destructive styling)

4. Test Connection handler:
   ```tsx
   const handleTest = async () => {
     setIsTesting(true);
     try {
       const response = await fetch(`/api/config/integrations/${config.name}/test`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(config),
       });
       const result = await response.json();
       setTestResult({
         success: response.ok,
         message: result.message || (response.ok ? 'Connection successful' : 'Connection failed')
       });
     } catch (err) {
       setTestResult({ success: false, message: err.message });
     } finally {
       setIsTesting(false);
     }
   };
   ```

5. Save handler:
   - Call onSave prop with current config
   - Close modal after save completes
   - No need to check testResult - user can save even if test fails (per 02-CONTEXT.md)

6. Delete handler (only show button if initialConfig exists):
   ```tsx
   const handleDelete = async () => {
     if (!initialConfig || !onDelete) return;

     if (!confirm(`Delete integration "${initialConfig.name}"? This action cannot be undone.`)) {
       return;
     }

     try {
       await onDelete(initialConfig.name);
       onClose();
     } catch (err) {
       alert(`Failed to delete: ${err.message}`);
     }
   };
   ```

7. Inline CSS following existing patterns:
   - Modal overlay: fixed, full viewport, rgba(0,0,0,0.7) backdrop, z-index 1000
   - Modal content: centered, max-width 600px, border-radius 12px, var(--color-surface-elevated)
   - Buttons: Blue primary for Save, gray secondary for Cancel/Close, red destructive for Delete
   - Test result: Green background for success, red for error
   - Delete button: Left-aligned in footer, red text, separated from Save/Cancel

8. Accessibility:
   - role="dialog" and aria-modal="true" on modal content
   - Focus first input on open
   - Escape key closes modal
   - Focus trap (Tab cycles within modal)

Return null if !isOpen (conditional render).

Follow existing component patterns from Sidebar.tsx (inline CSS-in-JS, var() for colors).
  </action>
  <verify>
npm run build
Build succeeds with no errors in IntegrationModal.tsx
  </verify>
  <done>
IntegrationModal component created with portal rendering, focus management, Test Connection functionality, Delete button with confirmation dialog, inline CSS, accessibility attributes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IntegrationTable and IntegrationConfigForm components</name>
  <files>
    ui/src/components/IntegrationTable.tsx
    ui/src/components/IntegrationConfigForm.tsx
  </files>
  <action>
Create table component in ui/src/components/IntegrationTable.tsx:

1. Interface:
   ```tsx
   interface Integration {
     name: string;
     type: string;
     config: { url?: string; [key: string]: any };
     enabled: boolean;
     health?: 'healthy' | 'degraded' | 'stopped';
     dateAdded?: string;
   }

   interface IntegrationTableProps {
     integrations: Integration[];
     onEdit: (integration: Integration) => void;
   }
   ```

2. Table structure:
   - Columns: Name, Type, URL/Endpoint, Date Added, Status
   - Extract URL from config.url (fallback to "N/A")
   - Date Added: Use new Date().toLocaleDateString() or actual timestamp if API provides
   - Status: Color dot + text ("Healthy", "Degraded", "Stopped")

3. Status indicator:
   ```tsx
   const getStatusColor = (health: string) => {
     switch (health) {
       case 'healthy': return '#10b981'; // green
       case 'degraded': return '#f59e0b'; // amber
       case 'stopped': return '#ef4444'; // red
       default: return '#6b7280'; // gray
     }
   };
   ```

4. Row click handler:
   - onClick calls onEdit(integration)
   - Cursor pointer on hover
   - Hover effect: background color change

5. Inline CSS:
   - Table: full width, border-radius 12px, var(--color-surface-elevated)
   - Headers: uppercase, 12px font, var(--color-text-muted), var(--color-surface-muted) background
   - Rows: 16px padding, border-bottom, hover effect
   - Status dot: 8px circle inline with text

Create form component in ui/src/components/IntegrationConfigForm.tsx:

1. Interface:
   ```tsx
   interface IntegrationConfigFormProps {
     config: IntegrationConfig;
     onChange: (config: IntegrationConfig) => void;
   }
   ```

2. Form fields (common to all types):
   - Name: Text input (disabled if editing existing)
   - Type: Dropdown (VictoriaLogs for now, extensible for future integrations)
   - Enabled: Checkbox (default true)

3. Type-specific config (VictoriaLogs):
   - URL: Text input for config.url (e.g., "http://victorialogs:9428")
   - Placeholder: "http://victorialogs:9428"
   - Validation: Required, must start with http:// or https://

4. Field change handlers:
   - Update config object immutably
   - Call onChange with new config
   - Example:
     ```tsx
     const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       onChange({
         ...config,
         config: { ...config.config, url: e.target.value }
       });
     };
     ```

5. Form styling:
   - Labels: 14px, var(--color-text-primary), margin-bottom 8px
   - Inputs: 100% width, padding 12px, border-radius 8px, var(--color-border-soft) border
   - Focus: Blue border (var(--color-accent) or #3b82f6)
   - Spacing: 20px between fields

Follow existing form patterns from Spectre UI (if any exist, otherwise use standard React form patterns).
  </action>
  <verify>
npm run build
Build succeeds with no errors in IntegrationTable.tsx and IntegrationConfigForm.tsx
  </verify>
  <done>
IntegrationTable component renders table with 5 columns and status indicators. IntegrationConfigForm renders type-specific fields for VictoriaLogs integration. Both components exported and importable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update IntegrationsPage with modal state and API integration</name>
  <files>
    ui/src/pages/IntegrationsPage.tsx
  </files>
  <action>
Update IntegrationsPage.tsx to use new components:

1. Add imports:
   ```tsx
   import { useState, useEffect } from 'react';
   import IntegrationModal from '../components/IntegrationModal';
   import IntegrationTable from '../components/IntegrationTable';
   ```

2. Add state:
   ```tsx
   const [integrations, setIntegrations] = useState<IntegrationConfig[]>([]);
   const [isModalOpen, setIsModalOpen] = useState(false);
   const [selectedIntegration, setSelectedIntegration] = useState<IntegrationConfig | undefined>();
   const [loading, setLoading] = useState(true);
   const [error, setError] = useState<string | null>(null);
   ```

3. Fetch integrations on mount:
   ```tsx
   useEffect(() => {
     loadIntegrations();
   }, []);

   const loadIntegrations = async () => {
     try {
       setLoading(true);
       const response = await fetch('/api/config/integrations');
       if (!response.ok) throw new Error('Failed to load integrations');
       const data = await response.json();
       setIntegrations(data || []);
       setError(null);
     } catch (err) {
       setError(err.message);
       console.error('Failed to load integrations:', err);
     } finally {
       setLoading(false);
     }
   };
   ```

4. Save handler (create or update):
   ```tsx
   const handleSave = async (config: IntegrationConfig) => {
     try {
       const method = selectedIntegration ? 'PUT' : 'POST';
       const url = selectedIntegration
         ? `/api/config/integrations/${config.name}`
         : '/api/config/integrations';

       const response = await fetch(url, {
         method,
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(config),
       });

       if (!response.ok) {
         const error = await response.json();
         throw new Error(error.message || 'Failed to save integration');
       }

       // Reload integrations list
       await loadIntegrations();
       setIsModalOpen(false);
       setSelectedIntegration(undefined);
     } catch (err) {
       console.error('Failed to save:', err);
       alert(`Failed to save: ${err.message}`); // Simple error handling for MVP
     }
   };
   ```

5. Delete handler:
   ```tsx
   const handleDelete = async (name: string) => {
     try {
       const response = await fetch(`/api/config/integrations/${name}`, {
         method: 'DELETE',
       });

       if (!response.ok) {
         const error = await response.json();
         throw new Error(error.message || 'Failed to delete integration');
       }

       // Reload integrations list
       await loadIntegrations();
     } catch (err) {
       console.error('Failed to delete:', err);
       throw err; // Re-throw so modal can show error
     }
   };
   ```

6. Add Integration button handler:
   ```tsx
   const handleAddIntegration = () => {
     setSelectedIntegration(undefined);
     setIsModalOpen(true);
   };
   ```

7. Edit handler (from table row click):
   ```tsx
   const handleEdit = (integration: IntegrationConfig) => {
     setSelectedIntegration(integration);
     setIsModalOpen(true);
   };
   ```

8. Update JSX:
   - Keep existing header with title and description
   - Replace "+ Add Integration" button (was disabled) with working button calling handleAddIntegration
   - Conditional render:
     - If loading: Show loading spinner or skeleton
     - If error: Show error message with retry button
     - If integrations.length === 0: Show existing INTEGRATIONS tiles (empty state)
     - If integrations.length > 0: Show IntegrationTable component
   - Render IntegrationModal at bottom (pass isOpen, onClose, onSave, onDelete, initialConfig props)

9. Remove "Request Integration" section at bottom (no longer needed).

Follow existing page layout patterns (max-w-6xl, p-8, etc).
  </action>
  <verify>
npm run build
Build succeeds with no TypeScript errors
npm run dev
Dev server starts without errors
  </verify>
  <done>
IntegrationsPage updated with API integration, modal state management, delete handler wired to DELETE endpoint, conditional rendering (tiles for empty state, table for integrations), working Add/Edit/Delete/Save flow.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Delete button in IntegrationModal with confirmation dialog</name>
  <files>
    ui/src/components/IntegrationModal.tsx
  </files>
  <action>
Add Delete button functionality to IntegrationModal (implemented as part of Task 1):

1. Delete button placement:
   - Only show in edit mode (when initialConfig prop exists)
   - Left-aligned in footer (opposite side from Save/Cancel)
   - Red/destructive styling to indicate danger action

2. Delete handler with confirmation:
   ```tsx
   const handleDelete = async () => {
     if (!initialConfig || !onDelete) return;

     // Browser-native confirmation dialog
     const confirmed = window.confirm(
       `Delete integration "${initialConfig.name}"?\n\nThis action cannot be undone.`
     );

     if (!confirmed) return;

     try {
       await onDelete(initialConfig.name);
       onClose(); // Close modal on success
     } catch (err) {
       // Error display - simple alert for MVP
       alert(`Failed to delete: ${err.message}`);
       // Modal stays open so user can retry or cancel
     }
   };
   ```

3. Button styling:
   - Color: #ef4444 (red) for text and border
   - Background: transparent (outlined button)
   - Hover: Red background with white text
   - Separated from primary actions with margin-right: auto or justify-content: space-between

4. Wire to IntegrationsPage:
   - IntegrationsPage passes handleDelete as onDelete prop
   - handleDelete calls DELETE /api/config/integrations/{name} endpoint
   - After successful delete, reloads integration list
   - If delete fails, throws error back to modal for display

Why confirmation dialog: Prevents accidental deletions of production integrations. Browser-native confirm() provides adequate UX for MVP (can upgrade to custom modal later if needed).

Why left-align: Separates destructive action from primary actions, following common UI patterns (GitHub, Linear, etc).
  </action>
  <verify>
npm run build
Build succeeds with no errors
grep -n "handleDelete\|onDelete" ui/src/components/IntegrationModal.tsx
Shows delete handler and button implementation
  </verify>
  <done>
Delete button exists in IntegrationModal (edit mode only), shows confirmation dialog, calls onDelete prop, wired to DELETE endpoint via IntegrationsPage.handleDelete.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Components build successfully:**
   ```bash
   npm run build
   ```
   No TypeScript errors in new components

2. **Components importable:**
   ```bash
   grep -n "IntegrationModal\|IntegrationTable\|IntegrationConfigForm" ui/src/pages/IntegrationsPage.tsx
   ```
   Shows import statements

3. **API integration present:**
   ```bash
   grep -n "fetch.*api/config/integrations" ui/src/pages/IntegrationsPage.tsx
   ```
   Shows fetch calls to REST API including DELETE method

4. **Modal state managed:**
   ```bash
   grep -n "useState.*isModalOpen\|useState.*selectedIntegration" ui/src/pages/IntegrationsPage.tsx
   ```
   Shows state hooks for modal

5. **Delete functionality wired:**
   ```bash
   grep -n "handleDelete\|method.*DELETE" ui/src/pages/IntegrationsPage.tsx
   ```
   Shows delete handler calling DELETE endpoint
</verification>

<success_criteria>
- [ ] IntegrationModal uses createPortal for rendering at document.body
- [ ] Modal has focus trap and Escape key handling
- [ ] Test Connection button calls /test endpoint with 5s timeout
- [ ] Delete button exists in edit mode with confirmation dialog
- [ ] Delete button calls onDelete prop which invokes DELETE endpoint
- [ ] IntegrationTable shows 5 columns with status indicators
- [ ] Status dots use color coding (green=healthy, amber=degraded, red=stopped)
- [ ] IntegrationConfigForm renders VictoriaLogs fields (name, type, URL)
- [ ] IntegrationsPage fetches integrations on mount via useEffect
- [ ] Save handler uses POST for create, PUT for update
- [ ] Delete handler uses DELETE method and reloads list on success
- [ ] Empty state shows original tiles, populated state shows table
- [ ] Modal opens on Add button click and table row click
</success_criteria>

<output>
After completion, create `.planning/phases/02-config-management-ui/02-02-SUMMARY.md` following the summary template.
</output>
