---
phase: 02-config-management-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/api/handlers/integration_config_handler.go
  - internal/api/handlers/register.go
  - internal/config/integration_writer.go
  - internal/config/integration_writer_test.go
autonomous: true

must_haves:
  truths:
    - "GET /api/config/integrations returns list of configured integrations"
    - "POST /api/config/integrations creates new integration instance"
    - "PUT /api/config/integrations/{name} updates existing integration"
    - "DELETE /api/config/integrations/{name} removes integration"
    - "Config changes persist to disk and survive server restart"
    - "File writes are atomic (no corruption on crash)"
  artifacts:
    - path: "internal/api/handlers/integration_config_handler.go"
      provides: "REST API handlers for integration CRUD"
      min_lines: 200
      exports: ["IntegrationConfigHandler", "NewIntegrationConfigHandler"]
    - path: "internal/config/integration_writer.go"
      provides: "Atomic YAML writer with temp-file-then-rename pattern"
      min_lines: 50
      exports: ["WriteIntegrationsFile"]
    - path: "internal/api/handlers/register.go"
      provides: "Route registration for /api/config/integrations"
      contains: "/api/config/integrations"
  key_links:
    - from: "internal/api/handlers/integration_config_handler.go"
      to: "internal/config/integration_writer.go"
      via: "WriteIntegrationsFile call"
      pattern: "WriteIntegrationsFile\\("
    - from: "internal/api/handlers/register.go"
      to: "integration_config_handler.go"
      via: "NewIntegrationConfigHandler + HandleFunc"
      pattern: "NewIntegrationConfigHandler|HandleFunc.*integrations"
    - from: "integration_config_handler.go"
      to: "internal/integration/manager.go"
      via: "Health status from manager registry"
      pattern: "registry\\.Get|Health\\("
---

<objective>
Create REST API for integration config CRUD operations with atomic file persistence.

Purpose: Enable programmatic management of integration configurations with safe disk writes. API layer sits between UI and config file, providing validation, atomic writes, and triggering hot-reload.

Output: Working REST endpoints that read/write integrations.yaml atomically, preserving data integrity on crashes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-config-management-ui/02-CONTEXT.md
@.planning/phases/02-config-management-ui/02-RESEARCH.md

# Phase 1 infrastructure
@.planning/phases/01-plugin-infrastructure-foundation/01-04-SUMMARY.md

# Existing code patterns
@internal/api/handlers/register.go
@internal/api/response.go
@internal/config/integration_config.go
@internal/integration/types.go
@internal/integration/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement atomic YAML writer with temp-file-then-rename pattern</name>
  <files>
    internal/config/integration_writer.go
    internal/config/integration_writer_test.go
  </files>
  <action>
Create atomic YAML writer in internal/config/integration_writer.go:

1. Implement WriteIntegrationsFile function:
   - Marshal IntegrationsFile to YAML using gopkg.in/yaml.v3
   - Create temp file in same directory as target (os.CreateTemp with pattern ".integrations.*.yaml.tmp")
   - Write marshaled YAML to temp file
   - Close temp file to flush to disk
   - Atomic rename from temp to target path (os.Rename - POSIX guarantees atomicity)
   - Cleanup temp file if any step fails

2. Error handling:
   - Return descriptive errors at each step (marshal, create temp, write, close, rename)
   - Use defer os.Remove(tmpPath) to ensure cleanup even on error

3. Test coverage in integration_writer_test.go:
   - TestWriteIntegrationsFile_Success: Write valid config, verify file contents match
   - TestWriteIntegrationsFile_InvalidData: Pass non-serializable data, expect error
   - TestWriteIntegrationsFile_ReadBack: Write config, load with Koanf, verify round-trip

Why atomic writes: Direct os.WriteFile can corrupt config on crashes. Temp-file-then-rename ensures readers never see partial writes.

Follow existing config package patterns (see integration_config.go for struct definitions).
  </action>
  <verify>
go test ./internal/config -v -run TestWrite
All 3 tests pass
  </verify>
  <done>
WriteIntegrationsFile function exists, handles errors correctly, passes round-trip test with Koanf loader from Phase 1.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement REST API handlers for integration config CRUD</name>
  <files>
    internal/api/handlers/integration_config_handler.go
  </files>
  <action>
Create REST handler in internal/api/handlers/integration_config_handler.go:

1. Define IntegrationConfigHandler struct:
   - configPath string (path to integrations.yaml)
   - manager *integration.Manager (for health status queries)
   - logger *logging.Logger

2. Implement CRUD handlers:

   **HandleList (GET /api/config/integrations):**
   - Load IntegrationsFile using config.LoadIntegrationsFile (from Phase 1)
   - For each instance, query manager.GetInstance(name).Health() to get runtime status
   - Return JSON array with instances + health status enrichment
   - Use api.WriteJSON for success, api.WriteError for failures

   **HandleCreate (POST /api/config/integrations):**
   - Parse IntegrationConfig from request body
   - Validate using IntegrationsFile.Validate() (checks name, type, uniqueness)
   - Load current config file
   - Append new instance to Instances array
   - Write atomically using WriteIntegrationsFile
   - Return 201 Created with new instance JSON
   - Hot-reload happens automatically via IntegrationWatcher (Phase 1)

   **HandleGet (GET /api/config/integrations/{name}):**
   - Extract name from URL path (strings.TrimPrefix on r.URL.Path)
   - Load config, find instance by name
   - Enrich with health status from manager
   - Return 404 if not found

   **HandleUpdate (PUT /api/config/integrations/{name}):**
   - Extract name from URL path
   - Parse updated IntegrationConfig from body
   - Validate config
   - Load current config, find and replace instance
   - Write atomically
   - Return 200 with updated instance

   **HandleDelete (DELETE /api/config/integrations/{name}):**
   - Extract name from URL path
   - Load config, filter out instance by name
   - Write atomically
   - Return 204 No Content

   **HandleTest (POST /api/config/integrations/{name}/test):**
   - Parse IntegrationConfig from body
   - Validate using IntegrationsFile.Validate()
   - Look up factory via GetFactory(config.Type)
   - Create integration instance via factory.Create(config)
   - Call integration.Start(ctx) with 5-second timeout
   - Call integration.Health(ctx) to check status
   - Call integration.Stop(ctx) for cleanup
   - Return {"success": true/false, "message": "..."}
   - Use recover() to catch panics from malformed configs

3. Error responses:
   - Use api.WriteError with codes: INVALID_JSON, INVALID_CONFIG, NOT_FOUND, LOAD_ERROR, WRITE_ERROR, TEST_FAILED
   - Return all validation errors at once (not fail-fast) for better UX

Constructor: NewIntegrationConfigHandler(configPath string, manager *integration.Manager, logger *logging.Logger)

Follow existing handler patterns (see search_handler.go, metadata_handler.go).
  </action>
  <verify>
go build ./internal/api/handlers
Build succeeds with no errors
  </verify>
  <done>
IntegrationConfigHandler struct exists with 6 handler methods (List, Create, Get, Update, Delete, Test), uses atomic writer, enriches responses with health status, validates configs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register integration config routes in API server</name>
  <files>
    internal/api/handlers/register.go
  </files>
  <action>
Update RegisterHandlers function in internal/api/handlers/register.go:

1. Add parameters to RegisterHandlers signature:
   - configPath string
   - integrationManager *integration.Manager

2. Create and register handler (add after existing registrations):
   ```go
   // Integration config management
   configHandler := NewIntegrationConfigHandler(configPath, integrationManager, logger)
   router.HandleFunc("/api/config/integrations",
       withMethod(http.MethodGet, configHandler.HandleList))
   router.HandleFunc("/api/config/integrations",
       withMethod(http.MethodPost, configHandler.HandleCreate))

   // Wildcard route for path parameters (name)
   router.HandleFunc("/api/config/integrations/", func(w http.ResponseWriter, r *http.Request) {
       name := strings.TrimPrefix(r.URL.Path, "/api/config/integrations/")
       if name == "" {
           api.WriteError(w, http.StatusNotFound, "NOT_FOUND", "Integration name required")
           return
       }

       // Check for /test suffix
       if strings.HasSuffix(name, "/test") {
           name = strings.TrimSuffix(name, "/test")
           if r.Method != http.MethodPost {
               api.WriteError(w, http.StatusMethodNotAllowed, "METHOD_NOT_ALLOWED", "POST required")
               return
           }
           configHandler.HandleTest(w, r) // Pass name via context or re-parse
           return
       }

       // Route by method for /{name} operations
       switch r.Method {
       case http.MethodGet:
           configHandler.HandleGet(w, r)
       case http.MethodPut:
           configHandler.HandleUpdate(w, r)
       case http.MethodDelete:
           configHandler.HandleDelete(w, r)
       default:
           api.WriteError(w, http.StatusMethodNotAllowed, "METHOD_NOT_ALLOWED",
               "Allowed: GET, PUT, DELETE")
       }
   })

   logger.Info("Registered /api/config/integrations endpoints")
   ```

3. Update call sites:
   - cmd/spectre/commands/server.go will need to pass configPath and manager to RegisterHandlers
   - This change will cause compilation errors until server.go is updated (acceptable - will be fixed when server integrates this handler)

Note: Path parameter extraction uses strings.TrimPrefix instead of gorilla/mux, following existing codebase patterns (stdlib http.ServeMux).
  </action>
  <verify>
go build ./internal/api/handlers
Build succeeds (server.go will have errors until it passes new params - expected)
grep -n "config/integrations" internal/api/handlers/register.go
Output shows new route registrations
  </verify>
  <done>
RegisterHandlers function updated with configPath and integrationManager parameters, routes registered for /api/config/integrations with all HTTP methods, logged confirmation message.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Atomic writer verified:**
   ```bash
   go test ./internal/config -v -run TestWrite
   ```
   All writer tests pass

2. **Handler compiles:**
   ```bash
   go build ./internal/api/handlers
   ```
   No compilation errors in handlers package

3. **Routes registered:**
   ```bash
   grep -A5 "config/integrations" internal/api/handlers/register.go
   ```
   Shows route registration code

4. **Integration point identified:**
   ```bash
   grep -n "RegisterHandlers" cmd/spectre/commands/server.go
   ```
   Shows where server.go needs updates (will compile fail until server integrates - expected)
</verification>

<success_criteria>
- [ ] WriteIntegrationsFile function uses temp-file-then-rename for atomicity
- [ ] Round-trip test passes (write YAML, load with Koanf, verify match)
- [ ] IntegrationConfigHandler implements 6 HTTP methods
- [ ] Handlers use api.WriteJSON/WriteError for consistent responses
- [ ] Test endpoint validates config and uses 5-second timeout
- [ ] Health status enrichment queries manager.GetInstance().Health()
- [ ] Routes registered in register.go with appropriate HTTP methods
- [ ] All validation errors returned at once (not fail-fast)
- [ ] Handler panics caught by recover() in test endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/02-config-management-ui/02-01-SUMMARY.md` following the summary template.
</output>
