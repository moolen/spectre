---
phase: 01-plugin-infrastructure-foundation
plan: 04
type: execute
wave: 3
depends_on: [01-02]
files_modified:
  - internal/integration/manager.go
  - internal/integration/manager_test.go
  - cmd/spectre/commands/server.go
autonomous: true

must_haves:
  truths:
    - Manager starts enabled integration instances from config
    - Failed instance marked as degraded, not crash server
    - Health checks auto-recover degraded instances
    - Full restart on config change (all instances stop/start)
    - MCP server continues serving with degraded instances
  artifacts:
    - path: internal/integration/manager.go
      provides: Integration lifecycle manager
      min_lines: 180
      exports: [Manager, ManagerConfig, NewManager]
    - path: internal/integration/manager_test.go
      provides: Manager unit tests
      min_lines: 100
  key_links:
    - from: internal/integration/manager.go
      to: internal/integration/registry.go
      via: uses Registry to store instances
      pattern: Registry
    - from: internal/integration/manager.go
      to: internal/config/integration_watcher.go
      via: registers as reload callback
      pattern: ReloadCallback
    - from: cmd/spectre/commands/server.go
      to: internal/integration/manager.go
      via: creates and starts Manager
      pattern: integration\\.NewManager
---

<objective>
Implement integration lifecycle manager with health monitoring, auto-recovery, and hot-reload integration.

Purpose: Orchestrate integration instances - start enabled instances, monitor health, handle degraded state, restart all instances on config change. Integrates watcher (Plan 03) and registry (Plan 02) into cohesive system.

Output: Manager with Start/Stop lifecycle, health monitoring, and MCP server integration point.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/01-plugin-infrastructure-foundation/01-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/research/SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/cmd/spectre/commands/server.go
@/home/moritz/dev/spectre-via-ssh/internal/lifecycle/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement integration lifecycle manager</name>
  <files>internal/integration/manager.go</files>
  <action>
Create `internal/integration/manager.go` implementing lifecycle management for integration instances.

**Types:**
```go
type ManagerConfig struct {
  ConfigPath         string
  HealthCheckInterval time.Duration  // default: 30s
  ShutdownTimeout     time.Duration  // default: 10s
}

type Manager struct {
  config    ManagerConfig
  registry  *Registry
  watcher   *IntegrationWatcher
  factories map[string]IntegrationFactory  // type -> factory function
  cancel    context.CancelFunc
  stopped   chan struct{}
}

type IntegrationFactory func(name string, config map[string]interface{}) (Integration, error)
```

**Constructor:**
```go
func NewManager(config ManagerConfig) (*Manager, error)
```
- Validate ConfigPath not empty
- Set HealthCheckInterval default to 30s if zero
- Set ShutdownTimeout default to 10s if zero
- Create Registry
- Initialize factories map (empty for now - Phase 2-3 will register VictoriaLogs)

**RegisterFactory method:**
```go
func (m *Manager) RegisterFactory(integrationType string, factory IntegrationFactory) error
```
- Stores factory for creating instances of given type
- Returns error if type already registered

**Start method:**
```go
func (m *Manager) Start(ctx context.Context) error
```
1. Load initial config using `LoadIntegrationsFile(m.config.ConfigPath)`
2. Start instances from config: for each enabled instance, call factory and store in registry
3. If instance.Start() fails, mark as degraded (set health status), continue with other instances
4. Create IntegrationWatcher with reload callback
5. Start watcher (calls our reload callback on changes)
6. Start health check loop (goroutine checking all instances every HealthCheckInterval)
7. Store context cancel function for shutdown

**Reload callback (private method):**
```go
func (m *Manager) handleConfigReload(newConfig *IntegrationsFile) error
```
1. Stop all existing instances gracefully (call Stop with timeout)
2. Clear registry
3. Start instances from new config (same logic as Start)
4. Log which instances started/failed
5. Return nil (errors logged but don't prevent reload)

**Health check loop (private method):**
```go
func (m *Manager) runHealthChecks(ctx context.Context)
```
1. Ticker fires every HealthCheckInterval
2. For each instance in registry:
   - Call instance.Health()
   - If Degraded and backend responds: call instance.Start() for auto-recovery
   - If Healthy but backend fails: mark as Degraded
3. Log health status changes
4. Respect context cancellation

**Stop method:**
```go
func (m *Manager) Stop() error
```
1. Cancel context to stop health checks and watcher
2. Stop watcher (calls watcher.Stop())
3. Stop all instances with ShutdownTimeout
4. Wait on stopped channel with timeout
5. Return error if any instance fails to stop gracefully

**GetRegistry method:**
```go
func (m *Manager) GetRegistry() *Registry
```
- Returns registry for MCP server to query instances

**Error handling:**
- Instance start failure: Log error, mark degraded, continue with others
- Reload failure: Log error, keep running with previous instances
- Health check failure: Mark degraded, attempt auto-recovery on next cycle
- Graceful shutdown timeout: Log warning, force stop

Use structured logging. Follow lifecycle patterns from `internal/lifecycle/manager.go`.
  </action>
  <verify>
Manual integration test:
1. Create test YAML with two instances (one valid, one with bad config to trigger degraded)
2. Create mock Integration that tracks Start/Stop/Health calls
3. Create Manager, register mock factory
4. Call Start - verify both instances created, failed one marked degraded
5. Modify config to disable one instance - verify full restart
6. Call Stop - verify all instances stopped gracefully

Check: `go build ./internal/integration` succeeds.
  </verify>
  <done>
Manager starts instances from config. Failed instances marked degraded without crashing. Health checks auto-recover. Config reload triggers full restart. Stop shuts down gracefully with timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write manager unit tests and integrate with server command</name>
  <files>internal/integration/manager_test.go, cmd/spectre/commands/server.go</files>
  <action>
**Part A: Write manager tests in `internal/integration/manager_test.go`**

Test cases:
1. **TestManagerStartLoadsInstances** - Config with 2 enabled instances, verify both started and in registry
2. **TestManagerFailedInstanceDegraded** - Instance.Start() returns error, verify marked degraded, server continues
3. **TestManagerConfigReload** - Modify config, verify all instances restarted
4. **TestManagerHealthCheckRecovery** - Instance degraded, health check succeeds, verify Start called again
5. **TestManagerGracefulShutdown** - Start manager, call Stop, verify all instances stopped within timeout

Mock Integration implementation for tests:
```go
type mockIntegration struct {
  name      string
  startErr  error
  stopErr   error
  health    HealthStatus
  startCalls int
  stopCalls  int
}
```

**Part B: Integrate Manager into server command**

Update `cmd/spectre/commands/server.go`:
1. Add flag for integrations config path (e.g., `--integrations-config`)
2. After lifecycle.Manager creation, create integration.Manager:
   ```go
   integrationMgr, err := integration.NewManager(integration.ManagerConfig{
     ConfigPath: integrationsConfigPath,
   })
   if err != nil {
     return err
   }
   ```
3. Register integrationMgr with lifecycle.Manager as a component
4. Integration manager will start/stop with server lifecycle

**Do NOT register any factories yet** - VictoriaLogs factory comes in Phase 2-3. This wiring just prepares the infrastructure.

Follow existing patterns from `cmd/spectre/commands/server.go` for lifecycle component registration.
  </action>
  <verify>
Run `go test ./internal/integration -v -run TestManager` and confirm all tests pass.

Build server command: `go build ./cmd/spectre` succeeds.

Manual test: Run `spectre server --integrations-config /tmp/empty.yaml` with empty file, verify server starts without errors.
  </verify>
  <done>
Manager unit tests pass covering: instance startup, degraded handling, config reload, health recovery, shutdown. Server command integrated with integration manager. Server starts with empty integrations config.
  </done>
</task>

</tasks>

<verification>
**Lifecycle verification:**
- Start manager with valid config, verify instances started
- Stop manager, verify all instances stopped within timeout
- Health check detects degraded instance, auto-recovery works

**Reload verification:**
- Modify config while running
- Verify all instances restarted (old stopped, new started)
- Confirm MCP tools still accessible during reload

**Degraded state verification:**
- Instance fails to start, verify marked degraded
- MCP tools query shows degraded status
- Server continues serving other instances

**Integration verification:**
- Manager uses Registry from Plan 02
- Manager uses IntegrationWatcher from Plan 03
- Server command wires manager into lifecycle
</verification>

<success_criteria>
- [ ] Manager starts enabled instances from config
- [ ] Failed instances marked degraded, server continues
- [ ] Health checks run every 30s, auto-recover degraded instances
- [ ] Config reload triggers full instance restart
- [ ] Graceful shutdown stops all instances within timeout
- [ ] GetRegistry provides access for MCP server
- [ ] Unit tests pass for all scenarios
- [ ] Server command integrated with integration manager
- [ ] Server starts with empty integrations config
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-infrastructure-foundation/01-04-SUMMARY.md`
</output>
