---
phase: 01-plugin-infrastructure-foundation
plan: 04
type: execute
wave: 4
depends_on: [01-02, 01-03]
files_modified:
  - internal/integration/manager.go
  - internal/integration/manager_test.go
  - cmd/spectre/commands/server.go
autonomous: true

must_haves:
  truths:
    - Manager validates integration versions on startup (PLUG-06)
    - Manager starts enabled integration instances from config
    - Failed instance marked as degraded, not crash server
    - Health checks auto-recover degraded instances
    - Full restart on config change (all instances stop/start)
    - MCP server continues serving with degraded instances
  artifacts:
    - path: internal/integration/manager.go
      provides: Integration lifecycle manager with version validation
      min_lines: 200
      exports: [Manager, ManagerConfig, NewManager]
    - path: internal/integration/manager_test.go
      provides: Manager unit tests
      min_lines: 100
  key_links:
    - from: internal/integration/manager.go
      to: internal/integration/registry.go
      via: uses Registry to store instances
      pattern: Registry
    - from: internal/integration/manager.go
      to: internal/integration/factory.go
      via: uses factory registry to create instances
      pattern: GetFactory
    - from: internal/integration/manager.go
      to: internal/config/integration_watcher.go
      via: registers as reload callback
      pattern: ReloadCallback
    - from: cmd/spectre/commands/server.go
      to: internal/integration/manager.go
      via: creates and starts Manager
      pattern: integration\\.NewManager
---

<objective>
Implement integration lifecycle manager with version validation, health monitoring, auto-recovery, and hot-reload integration.

Purpose: Orchestrate integration instances - validate versions (PLUG-06), start enabled instances, monitor health, handle degraded state, restart all instances on config change. Integrates watcher (Plan 03), factory registry, and instance registry (Plan 02) into cohesive system.

Output: Manager with Start/Stop lifecycle, version validation, health monitoring, and MCP server integration point.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/01-plugin-infrastructure-foundation/01-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/research/SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/cmd/spectre/commands/server.go
@/home/moritz/dev/spectre-via-ssh/internal/lifecycle/manager.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement integration lifecycle manager with version validation</name>
  <files>internal/integration/manager.go</files>
  <action>
Create `internal/integration/manager.go` implementing lifecycle management for integration instances with version validation.

**Types:**
```go
type ManagerConfig struct {
  ConfigPath         string
  HealthCheckInterval time.Duration  // default: 30s
  ShutdownTimeout     time.Duration  // default: 10s
  MinIntegrationVersion string        // e.g., "1.0.0" (PLUG-06)
}

type Manager struct {
  config    ManagerConfig
  registry  *Registry
  watcher   *IntegrationWatcher
  cancel    context.CancelFunc
  stopped   chan struct{}
}
```

**Constructor:**
```go
func NewManager(config ManagerConfig) (*Manager, error)
```
- Validate ConfigPath not empty
- Set HealthCheckInterval default to 30s if zero
- Set ShutdownTimeout default to 10s if zero
- Create Registry
- Parse MinIntegrationVersion if provided (use semver comparison)

**Start method:**
```go
func (m *Manager) Start(ctx context.Context) error
```
1. Load initial config using `LoadIntegrationsFile(m.config.ConfigPath)`
2. **Version validation (PLUG-06):** For each instance config, lookup factory via `GetFactory(instance.Type)`. Create instance with factory. Call `instance.Metadata()` and validate version against MinIntegrationVersion using semantic version comparison. If version too old, return error before starting anything. Log which instances passed validation.
3. Start instances from config: for each enabled instance that passed validation, call instance.Start()
4. If instance.Start() fails, mark as degraded (set health status), continue with other instances
5. Create IntegrationWatcher with reload callback
6. Start watcher (calls our reload callback on changes)
7. Start health check loop (goroutine checking all instances every HealthCheckInterval)
8. Store context cancel function for shutdown

**Version validation implementation:**
- Use `github.com/hashicorp/go-version` for semantic version comparison (add to go.mod if needed)
- Compare instance.Metadata().Version >= MinIntegrationVersion
- If MinIntegrationVersion is empty, skip validation
- Log validation results: "Integration {name} version {version} validated" or "Integration {name} version {version} below minimum {min}"

**Reload callback (private method):**
```go
func (m *Manager) handleConfigReload(newConfig *IntegrationsFile) error
```
1. Stop all existing instances gracefully (call Stop with timeout)
2. Clear registry
3. Re-run version validation on new instances
4. Start instances from new config (same logic as Start)
5. Log which instances started/failed
6. Return nil (errors logged but don't prevent reload)

**Health check loop (private method):**
```go
func (m *Manager) runHealthChecks(ctx context.Context)
```
1. Ticker fires every HealthCheckInterval
2. For each instance in registry:
   - Call instance.Health()
   - If Degraded and backend responds: call instance.Start() for auto-recovery
   - If Healthy but backend fails: mark as Degraded
3. Log health status changes
4. Respect context cancellation

**Stop method:**
```go
func (m *Manager) Stop() error
```
1. Cancel context to stop health checks and watcher
2. Stop watcher (calls watcher.Stop())
3. Stop all instances with ShutdownTimeout
4. Wait on stopped channel with timeout
5. Return error if any instance fails to stop gracefully

**GetRegistry method:**
```go
func (m *Manager) GetRegistry() *Registry
```
- Returns registry for MCP server to query instances

**Error handling:**
- Instance version too old: Return error during Start (fail fast)
- Instance start failure: Log error, mark degraded, continue with others
- Reload failure: Log error, keep running with previous instances
- Health check failure: Mark degraded, attempt auto-recovery on next cycle
- Graceful shutdown timeout: Log warning, force stop

Use structured logging. Follow lifecycle patterns from `internal/lifecycle/manager.go`. Add go-version dependency if not already present.
  </action>
  <verify>
Manual integration test:
1. Create test YAML with two instances (one valid, one with bad config to trigger degraded)
2. Create mock Integration that tracks Start/Stop/Health calls and returns metadata with version
3. Create Manager with MinIntegrationVersion set
4. Call Start - verify version validation runs, both instances created, failed one marked degraded
5. Modify config to disable one instance - verify full restart
6. Call Stop - verify all instances stopped gracefully

Check: `go build ./internal/integration` succeeds.
  </verify>
  <done>
Manager validates integration versions on startup (PLUG-06). Starts instances from config. Failed instances marked degraded without crashing. Health checks auto-recover. Config reload triggers full restart with re-validation. Stop shuts down gracefully with timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write manager unit tests and integrate with server command</name>
  <files>internal/integration/manager_test.go, cmd/spectre/commands/server.go</files>
  <action>
**Part A: Write manager tests in `internal/integration/manager_test.go`**

Test cases:
1. **TestManagerVersionValidation** - Set MinIntegrationVersion, register factory returning old version, verify Start returns error (PLUG-06)
2. **TestManagerStartLoadsInstances** - Config with 2 enabled instances, verify both started and in registry
3. **TestManagerFailedInstanceDegraded** - Instance.Start() returns error, verify marked degraded, server continues
4. **TestManagerConfigReload** - Modify config, verify all instances restarted with re-validation
5. **TestManagerHealthCheckRecovery** - Instance degraded, health check succeeds, verify Start called again
6. **TestManagerGracefulShutdown** - Start manager, call Stop, verify all instances stopped within timeout

Mock Integration implementation for tests:
```go
type mockIntegration struct {
  name      string
  version   string  // for Metadata()
  startErr  error
  stopErr   error
  health    HealthStatus
  startCalls int
  stopCalls  int
}

func (m *mockIntegration) Metadata() IntegrationMetadata {
  return IntegrationMetadata{Name: m.name, Version: m.version, Type: "mock"}
}
```

**Part B: Integrate Manager into server command**

Update `cmd/spectre/commands/server.go`:
1. Add flag for integrations config path (e.g., `--integrations-config`)
2. Add flag for minimum integration version (e.g., `--min-integration-version`)
3. After lifecycle.Manager creation, create integration.Manager:
   ```go
   integrationMgr, err := integration.NewManager(integration.ManagerConfig{
     ConfigPath: integrationsConfigPath,
     MinIntegrationVersion: minIntegrationVersion,
   })
   if err != nil {
     return err
   }
   ```
4. Register integrationMgr with lifecycle.Manager as a component
5. Integration manager will start/stop with server lifecycle

**Do NOT register any factories yet** - VictoriaLogs factory comes in Phase 2-3. This wiring just prepares the infrastructure.

Follow existing patterns from `cmd/spectre/commands/server.go` for lifecycle component registration.
  </action>
  <verify>
Run `go test ./internal/integration -v -run TestManager` and confirm all tests pass.

Build server command: `go build ./cmd/spectre` succeeds.

Manual test: Run `spectre server --integrations-config /tmp/empty.yaml --min-integration-version 1.0.0` with empty file, verify server starts without errors.
  </verify>
  <done>
Manager unit tests pass covering: version validation (PLUG-06), instance startup, degraded handling, config reload with re-validation, health recovery, shutdown. Server command integrated with integration manager and version flag. Server starts with empty integrations config.
  </done>
</task>

</tasks>

<verification>
**Version validation verification (PLUG-06):**
- Start manager with MinIntegrationVersion="2.0.0"
- Register mock returning version "1.0.0"
- Verify Start returns error with clear version mismatch message

**Lifecycle verification:**
- Start manager with valid config, verify instances started
- Stop manager, verify all instances stopped within timeout
- Health check detects degraded instance, auto-recovery works

**Reload verification:**
- Modify config while running
- Verify all instances restarted with version re-validation
- Confirm MCP tools still accessible during reload

**Degraded state verification:**
- Instance fails to start, verify marked degraded
- MCP tools query shows degraded status
- Server continues serving other instances

**Integration verification:**
- Manager uses Registry from Plan 02
- Manager uses FactoryRegistry from Plan 02
- Manager uses IntegrationWatcher from Plan 03
- Server command wires manager into lifecycle
</verification>

<success_criteria>
- [ ] Manager validates integration versions on startup (PLUG-06)
- [ ] Version validation uses semantic version comparison
- [ ] Old versions rejected with clear error message
- [ ] Manager starts enabled instances from config
- [ ] Failed instances marked degraded, server continues
- [ ] Health checks run every 30s, auto-recover degraded instances
- [ ] Config reload triggers full instance restart with re-validation
- [ ] Graceful shutdown stops all instances within timeout
- [ ] GetRegistry provides access for MCP server
- [ ] Unit tests pass for all scenarios including version validation
- [ ] Server command integrated with integration manager
- [ ] Server starts with empty integrations config
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-infrastructure-foundation/01-04-SUMMARY.md`
</output>
