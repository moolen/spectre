---
phase: 01-plugin-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/types.go
  - internal/config/integration_config.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - Integration config can be unmarshaled from YAML with schema version
    - Integration interface defines lifecycle contract (Start/Stop/Health)
    - Config validation rejects invalid schema versions
  artifacts:
    - path: internal/integration/types.go
      provides: Integration interface and types
      min_lines: 50
      exports: [Integration, IntegrationMetadata, HealthStatus]
    - path: internal/config/integration_config.go
      provides: Integration config schema
      min_lines: 60
      exports: [IntegrationConfig, IntegrationsFile]
  key_links:
    - from: internal/config/integration_config.go
      to: internal/integration/types.go
      via: type references
      pattern: integration\\.IntegrationMetadata
---

<objective>
Define integration configuration schema and interface contract for in-tree integration management.

Purpose: Establish foundation for plugin system - config schema with versioning and integration lifecycle interface. These contracts must be stable from day 1 as they define how all future integrations will be structured.

Output: Type definitions for integration config (YAML schema) and integration interface (lifecycle contract).
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/01-plugin-infrastructure-foundation/01-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/research/SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/internal/mcp/server.go
@/home/moritz/dev/spectre-via-ssh/internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define integration interface and metadata types</name>
  <files>internal/integration/types.go</files>
  <action>
Create `internal/integration/types.go` defining the integration lifecycle interface and supporting types.

**Integration interface must include:**
- `Metadata() IntegrationMetadata` - returns name, version, description
- `Start(ctx context.Context) error` - initializes integration instance
- `Stop(ctx context.Context) error` - graceful shutdown with timeout
- `Health(ctx context.Context) HealthStatus` - returns current health state

**HealthStatus enum:**
- `Healthy` - integration functioning normally
- `Degraded` - connection failed but instance still registered
- `Stopped` - integration explicitly stopped

**IntegrationMetadata struct:**
- `Name string` - unique integration name (e.g., "victorialogs")
- `Version string` - semantic version (e.g., "1.0.0")
- `Description string` - human-readable description
- `Type string` - integration type for multiple instances (e.g., "victorialogs")

**Additional types:**
- `InstanceConfig interface{}` - placeholder for instance-specific config (each integration type provides concrete implementation)

Use idiomatic Go patterns: context for cancellation, errors for failures, interfaces for extensibility.
  </action>
  <verify>
Run `go build ./internal/integration` to confirm types compile.

Check exports: `go doc internal/integration` should show Integration interface, IntegrationMetadata, HealthStatus.
  </verify>
  <done>
Integration interface exists with Metadata/Start/Stop/Health methods. HealthStatus enum has Healthy/Degraded/Stopped states. IntegrationMetadata has Name/Version/Description/Type fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define integration config schema with versioning</name>
  <files>internal/config/integration_config.go</files>
  <action>
Create `internal/config/integration_config.go` defining the YAML config schema for integrations file.

**IntegrationsFile struct (top-level):**
- `SchemaVersion string` - explicit schema version (e.g., "v1")
- `Instances []IntegrationConfig` - list of integration instances

**IntegrationConfig struct (per instance):**
- `Name string` - unique instance name (e.g., "victorialogs-prod")
- `Type string` - integration type (e.g., "victorialogs")
- `Enabled bool` - whether instance should be started
- `Config map[string]interface{}` - instance-specific configuration (type-specific)

**Validation function:**
- `func (f *IntegrationsFile) Validate() error` - validates schema version (must be "v1"), unique instance names, non-empty type, valid enabled boolean
- Return descriptive errors for violations

**Example YAML structure (in comment):**
```yaml
schema_version: v1
instances:
  - name: victorialogs-prod
    type: victorialogs
    enabled: true
    config:
      url: "http://victorialogs:9428"
```

Use `gopkg.in/yaml.v3` for YAML tags (already in go.mod). Follow existing config patterns from `internal/config/config.go`.
  </action>
  <verify>
Run `go build ./internal/config` to confirm schema compiles.

Create test file to unmarshal sample YAML and call Validate() - confirm it accepts valid config and rejects invalid schema versions.
  </verify>
  <done>
IntegrationsFile schema exists with SchemaVersion and Instances fields. IntegrationConfig has Name/Type/Enabled/Config fields. Validate() rejects invalid schema versions and duplicate instance names.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Koanf dependency for config hot-reload</name>
  <files>go.mod, go.sum</files>
  <action>
Add Koanf v2 to project dependencies for configuration hot-reload with fsnotify support.

Run:
```bash
cd /home/moritz/dev/spectre-via-ssh
go get github.com/knadh/koanf/v2@v2.3.0
go get github.com/knadh/koanf/providers/file@latest
go get github.com/knadh/koanf/parsers/yaml@latest
go mod tidy
```

**Why Koanf:**
- Research identified it as superior to Viper (modular, fixes case-sensitivity bugs, built-in file watching)
- Transitive dependency on fsnotify for file watching
- Clean provider/parser architecture

Verify installation by checking `go.mod` contains:
- `github.com/knadh/koanf/v2 v2.3.0` (or later)
- Related providers and parsers

Do NOT implement any config loading logic yet - just add dependency. Config loader implementation comes in Plan 02.
  </action>
  <verify>
Run `go mod tidy && go build ./...` to confirm dependency resolves and project still builds.

Check: `grep koanf go.mod` shows koanf/v2 and provider packages.
  </verify>
  <done>
Koanf v2.3.0+ added to go.mod. Project builds successfully with new dependency. File and YAML providers available for use in next plan.
  </done>
</task>

</tasks>

<verification>
**Schema validation:**
- Create test YAML file with valid and invalid schema versions
- Unmarshal into IntegrationsFile and call Validate()
- Confirm valid configs pass, invalid schema versions rejected

**Interface contract:**
- Verify Integration interface exports all required methods
- Confirm HealthStatus enum has all three states
- Check IntegrationMetadata has required fields

**Build verification:**
- `go build ./internal/integration` succeeds
- `go build ./internal/config` succeeds
- No import cycles introduced
</verification>

<success_criteria>
- [ ] Integration interface defined with Metadata/Start/Stop/Health methods
- [ ] HealthStatus enum with Healthy/Degraded/Stopped states
- [ ] IntegrationsFile schema with SchemaVersion and Instances
- [ ] IntegrationConfig schema with Name/Type/Enabled/Config fields
- [ ] Validate() function rejects unsupported schema versions
- [ ] Koanf v2.3.0+ in go.mod with file and YAML providers
- [ ] All new code builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-infrastructure-foundation/01-01-SUMMARY.md`
</output>
