---
phase: 01-plugin-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - internal/integration/registry.go
  - internal/integration/factory.go
  - internal/config/integration_loader.go
  - internal/integration/registry_test.go
autonomous: true

must_haves:
  truths:
    - Registry stores multiple integration instances by name
    - Factory registry enables in-tree integration discovery (PLUG-01)
    - Config loader reads YAML file and returns IntegrationsFile
    - Registry prevents duplicate instance names
    - Instances can be retrieved by name
  artifacts:
    - path: internal/integration/registry.go
      provides: Integration registry with instance management
      min_lines: 80
      exports: [Registry, NewRegistry]
    - path: internal/integration/factory.go
      provides: Factory registry for in-tree discovery
      min_lines: 60
      exports: [FactoryRegistry, RegisterFactory]
    - path: internal/config/integration_loader.go
      provides: Config loader using Koanf
      min_lines: 60
      exports: [LoadIntegrationsFile]
    - path: internal/integration/registry_test.go
      provides: Registry unit tests
      min_lines: 50
  key_links:
    - from: internal/integration/registry.go
      to: internal/integration/types.go
      via: stores Integration instances
      pattern: Integration
    - from: internal/integration/factory.go
      to: internal/integration/types.go
      via: factory function signature
      pattern: IntegrationFactory
    - from: internal/config/integration_loader.go
      to: internal/config/integration_config.go
      via: returns IntegrationsFile
      pattern: IntegrationsFile
---

<objective>
Implement integration registry for instance management, factory registry for in-tree discovery, and config loader using Koanf.

Purpose: Create in-memory registry to hold integration instances, factory registry for compile-time integration discovery (PLUG-01), and config loader to read integrations YAML file. Registry provides foundation for lifecycle management (Start/Stop) and lookup by name.

Output: Registry with add/get/list operations, factory registry for type-to-constructor mapping, and Koanf-based config loader.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/01-plugin-infrastructure-foundation/01-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/research/SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create factory registry for in-tree integration discovery</name>
  <files>internal/integration/factory.go</files>
  <action>
Create `internal/integration/factory.go` implementing factory registry for compile-time integration discovery (PLUG-01).

**Key clarification:** In-tree integrations use compile-time registration, not filesystem scanning. Config file references integration TYPES that are pre-registered in the factory registry.

**Types:**
```go
type IntegrationFactory func(name string, config map[string]interface{}) (Integration, error)

type FactoryRegistry struct {
  factories map[string]IntegrationFactory
  mu        sync.RWMutex
}
```

**Global registry:**
```go
var defaultRegistry = NewFactoryRegistry()

func RegisterFactory(integrationType string, factory IntegrationFactory) error {
  return defaultRegistry.Register(integrationType, factory)
}

func GetFactory(integrationType string) (IntegrationFactory, bool) {
  return defaultRegistry.Get(integrationType)
}
```

**Methods:**
- `NewFactoryRegistry() *FactoryRegistry` - constructor
- `Register(integrationType string, factory IntegrationFactory) error` - registers factory for given type
- `Get(integrationType string) (IntegrationFactory, bool)` - retrieves factory by type
- `List() []string` - returns sorted list of registered types

**Usage pattern (document in comment):**
```go
// In integration package (e.g., internal/integration/victorialogs/victorialogs.go):
func init() {
  integration.RegisterFactory("victorialogs", NewVictoriaLogsIntegration)
}

// Or explicit registration in main():
func main() {
  integration.RegisterFactory("victorialogs", victorialogs.NewVictoriaLogsIntegration)
}
```

**Error handling:** Register returns error if type already registered or if type is empty string.

**Thread safety:** Use RWMutex for concurrent reads (Get/List) and exclusive writes (Register).

This implements PLUG-01 (convention-based discovery) via Go's compile-time registration, not runtime filesystem scanning.
  </action>
  <verify>
Run `go build ./internal/integration` to confirm factory registry compiles.

Check exports: `go doc internal/integration` should show RegisterFactory and GetFactory functions.
  </verify>
  <done>
Factory registry exists with Register/Get/List operations. Global defaultRegistry with convenience functions. Thread-safe concurrent access. Documentation explains in-tree registration pattern (Go init or explicit main registration).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration registry with instance management</name>
  <files>internal/integration/registry.go, internal/integration/registry_test.go</files>
  <action>
Create `internal/integration/registry.go` implementing in-memory registry for integration instances.

**Registry struct:**
- `instances map[string]Integration` - stores instances by name
- `mu sync.RWMutex` - protects concurrent access

**Methods:**
- `NewRegistry() *Registry` - constructor, initializes empty map
- `Register(name string, integration Integration) error` - adds instance, returns error if name already exists
- `Get(name string) (Integration, bool)` - retrieves instance by name, returns bool for existence check
- `List() []string` - returns sorted list of instance names
- `Remove(name string) bool` - removes instance, returns true if existed

**Thread safety:** Use RWMutex for concurrent reads (List/Get) and exclusive writes (Register/Remove).

**Error handling:** Register returns error if name already exists or if name is empty string.

**Testing in `internal/integration/registry_test.go`:**
- Test Register with duplicate names (expect error)
- Test Get for existing and non-existing instances
- Test List returns sorted names
- Test Remove returns correct bool
- Test concurrent access (spawn goroutines doing Register/Get/List)

Use `github.com/stretchr/testify/assert` for assertions (already in go.mod).
  </action>
  <verify>
Run `go test ./internal/integration -v` and confirm all registry tests pass.

Check: `go build ./internal/integration` succeeds with no errors.
  </verify>
  <done>
Registry stores instances by name with thread-safe operations. Register prevents duplicate names. Get/List/Remove work correctly. Unit tests pass with concurrent access verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement config loader using Koanf</name>
  <files>internal/config/integration_loader.go</files>
  <action>
Create `internal/config/integration_loader.go` implementing config file loading with Koanf.

**Function signature:**
```go
func LoadIntegrationsFile(filepath string) (*IntegrationsFile, error)
```

**Implementation:**
1. Create new Koanf instance: `k := koanf.New(".")`
2. Load file using file provider with YAML parser:
   ```go
   import (
     "github.com/knadh/koanf/v2"
     "github.com/knadh/koanf/providers/file"
     "github.com/knadh/koanf/parsers/yaml"
   )

   if err := k.Load(file.Provider(filepath), yaml.Parser()); err != nil {
     return nil, fmt.Errorf("failed to load config: %w", err)
   }
   ```
3. Unmarshal into IntegrationsFile:
   ```go
   var config IntegrationsFile
   if err := k.Unmarshal("", &config); err != nil {
     return nil, fmt.Errorf("failed to parse config: %w", err)
   }
   ```
4. Call `config.Validate()` to ensure schema version and structure are valid
5. Return validated config

**Error handling:** Return wrapped errors with context. File not found should return clear error message.

**Why NOT use file watching yet:** File watching comes in Plan 03 with hot-reload implementation. This loader is synchronous - load once, return config.

Follow existing error wrapping patterns from `internal/config/config.go`.
  </action>
  <verify>
Create test YAML file in `/tmp/test-integrations.yaml` with valid schema:
```yaml
schema_version: v1
instances:
  - name: test-instance
    type: test
    enabled: true
    config:
      url: "http://localhost:9428"
```

Run Go code to call `LoadIntegrationsFile("/tmp/test-integrations.yaml")` and verify:
- Returns no error
- IntegrationsFile has schema_version="v1"
- Has one instance with name="test-instance"

Test with invalid schema version and confirm Validate() error returned.
  </verify>
  <done>
LoadIntegrationsFile reads YAML using Koanf, unmarshals into IntegrationsFile, validates schema version. Returns clear errors for file not found or invalid schema.
  </done>
</task>

</tasks>

<verification>
**Factory registry verification:**
- Register factory for type "test", retrieve it, verify function pointer matches
- Register duplicate type, verify error returned
- List() returns all registered types in sorted order

**Instance registry verification:**
- Unit tests pass for Register/Get/List/Remove
- Concurrent access test passes (no data races)
- Duplicate name registration returns error

**Config loader verification:**
- Valid YAML file loads successfully
- Invalid schema version rejected by Validate()
- File not found returns clear error
- Unmarshaling preserves all fields (name, type, enabled, config map)

**Integration:**
- Config loader can be called standalone
- Registry can store instances from any source
- Factory registry provides type-to-constructor mapping
- No circular dependencies between packages
</verification>

<success_criteria>
- [ ] Factory registry implements Register/Get/List with thread safety (PLUG-01)
- [ ] Global RegisterFactory/GetFactory convenience functions exist
- [ ] In-tree registration pattern documented (init or main)
- [ ] Registry implements Register/Get/List/Remove with thread safety
- [ ] Registry prevents duplicate instance names
- [ ] Registry unit tests pass including concurrent access
- [ ] LoadIntegrationsFile uses Koanf to read YAML
- [ ] Config loader calls Validate() on loaded config
- [ ] Invalid schema versions rejected with clear error
- [ ] All tests pass: `go test ./internal/integration ./internal/config`
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-infrastructure-foundation/01-02-SUMMARY.md`
</output>
