---
phase: 01-plugin-infrastructure-foundation
plan: 03
type: execute
wave: 3
depends_on: [01-02]
files_modified:
  - internal/config/integration_watcher.go
  - internal/config/integration_watcher_test.go
autonomous: true

must_haves:
  truths:
    - File watcher detects config file changes on disk
    - Debouncing prevents reload storms from editor save sequences
    - Invalid config rejected without crashing watcher
    - Watcher notifies callback on successful reload
  artifacts:
    - path: internal/config/integration_watcher.go
      provides: File watcher with debouncing and validation
      min_lines: 120
      exports: [IntegrationWatcher, WatcherConfig, ReloadCallback]
    - path: internal/config/integration_watcher_test.go
      provides: Watcher unit tests
      min_lines: 80
  key_links:
    - from: internal/config/integration_watcher.go
      to: internal/config/integration_loader.go
      via: calls LoadIntegrationsFile on change
      pattern: LoadIntegrationsFile
    - from: internal/config/integration_watcher.go
      to: github.com/knadh/koanf/providers/file
      via: uses file provider for watching
      pattern: file\\.Provider
---

<objective>
Implement config file watcher with debouncing and validation for hot-reload support.

Purpose: Detect changes to integrations YAML file and trigger reload callback. Debouncing prevents editor save storms. Validation prevents invalid configs from reaching registry. Foundation for full hot-reload in Plan 04.

Output: IntegrationWatcher with Start/Stop lifecycle and callback notification.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/01-plugin-infrastructure-foundation/01-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/research/SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration file watcher with debouncing</name>
  <files>internal/config/integration_watcher.go</files>
  <action>
Create `internal/config/integration_watcher.go` implementing file watching with Koanf and fsnotify.

**Types:**
```go
type ReloadCallback func(config *IntegrationsFile) error

type WatcherConfig struct {
  FilePath       string
  DebounceMillis int  // default: 500ms
}

type IntegrationWatcher struct {
  config   WatcherConfig
  callback ReloadCallback
  koanf    *koanf.Koanf
  cancel   context.CancelFunc
  stopped  chan struct{}
}
```

**Constructor:**
```go
func NewIntegrationWatcher(config WatcherConfig, callback ReloadCallback) (*IntegrationWatcher, error)
```
- Validate FilePath is not empty
- Set DebounceMillis default to 500 if zero
- Do NOT start watching yet (Start method does that)

**Start method:**
```go
func (w *IntegrationWatcher) Start(ctx context.Context) error
```
1. Load initial config using `LoadIntegrationsFile(w.config.FilePath)`
2. Call callback with initial config (fail fast if callback errors)
3. Create Koanf instance with file provider
4. Use `file.Provider(filepath).Watch(callback)` for fsnotify integration
5. Implement debouncing: Use timer that resets on each file event, fires callback after debounce period
6. On file change:
   - Reload config using `LoadIntegrationsFile`
   - If reload fails (invalid YAML or validation error), log error but keep watching with previous valid config
   - If reload succeeds, call callback
   - If callback returns error, log error but keep watching
7. Respect context cancellation for graceful shutdown

**Stop method:**
```go
func (w *IntegrationWatcher) Stop() error
```
- Cancel context to stop file watcher
- Wait on `stopped` channel with timeout (e.g., 5 seconds)
- Return error if timeout exceeded

**Debouncing implementation:**
- Use `time.Timer` that resets on each fsnotify event
- Only trigger reload after timer fires (no new events for debounce period)
- Prevents reload storm when editor saves multiple times rapidly

**Error handling:**
- Invalid config during reload: Log error, continue with previous valid config
- Callback error: Log error, continue watching (don't crash watcher)
- File deleted: Log warning, continue watching (waits for file to reappear)

Use structured logging compatible with existing patterns (can use standard log package or slog).
  </action>
  <verify>
Manual testing:
1. Create test YAML at `/tmp/test-watch.yaml` with valid config
2. Start watcher with callback that prints config
3. Modify file and save - confirm callback fires after debounce period
4. Save multiple times rapidly - confirm only one callback fires
5. Write invalid YAML - confirm error logged, watcher continues
6. Restore valid YAML - confirm callback fires again
7. Call Stop() - confirm watcher exits cleanly

Check: `go build ./internal/config` succeeds.
  </verify>
  <done>
IntegrationWatcher detects file changes with debouncing. Invalid configs logged but don't crash watcher. Callback fires with valid config. Start/Stop lifecycle works cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write watcher unit tests</name>
  <files>internal/config/integration_watcher_test.go</files>
  <action>
Create `internal/config/integration_watcher_test.go` with comprehensive tests for file watching behavior.

**Test cases:**

1. **TestWatcherStartLoadsInitialConfig** - Verify Start() loads config and calls callback immediately
2. **TestWatcherDetectsFileChange** - Write temp file, start watcher, modify file, verify callback fires
3. **TestWatcherDebouncing** - Modify file 5 times within 200ms, verify callback fires only once after debounce
4. **TestWatcherInvalidConfigRejected** - Modify file with invalid schema version, verify callback NOT called, watcher continues
5. **TestWatcherCallbackError** - Callback returns error, verify watcher logs but continues
6. **TestWatcherStopGraceful** - Start watcher, call Stop(), verify exits within timeout

**Test helpers:**
- `createTempConfigFile(t *testing.T, content string) string` - creates temp file with YAML content
- `waitForCallback(t *testing.T, called *bool, timeout time.Duration)` - waits for callback flag with timeout

**Testing approach:**
- Use `t.TempDir()` for isolated test files
- Use channels or atomic bools to track callback invocations
- Use short timeouts for fast tests (debounce: 100ms, wait: 500ms max)
- Use `time.Sleep` sparingly, prefer channels for synchronization

**Filesystem timing:**
- fsnotify events may be delayed on some platforms
- Use generous timeouts in tests (2x expected debounce time)
- Mark flaky tests with `t.Skip()` if filesystem is unreliable

Follow existing test patterns from `internal/config/config.go` and `internal/watcher/` tests.
  </action>
  <verify>
Run `go test ./internal/config -v -run TestWatcher` and confirm all watcher tests pass.

Check test coverage: `go test ./internal/config -coverprofile=coverage.out && go tool cover -func=coverage.out | grep integration_watcher.go`

Verify coverage for key branches: debouncing logic, error handling, Stop timeout.
  </verify>
  <done>
Watcher unit tests pass covering: initial load, file change detection, debouncing, invalid config rejection, callback errors, graceful shutdown. Coverage includes all major code paths.
  </done>
</task>

</tasks>

<verification>
**Debouncing verification:**
- Modify file 5+ times within 200ms
- Confirm callback fires only once after debounce period
- Verify timer resets on each modification

**Error handling verification:**
- Write invalid YAML during watching
- Confirm error logged, watcher continues
- Restore valid YAML, confirm callback fires

**Lifecycle verification:**
- Start watcher, modify file, confirm callback
- Call Stop(), verify watcher exits cleanly
- Verify no goroutine leaks (can check with `go test -race`)

**Integration:**
- Watcher uses LoadIntegrationsFile from Plan 02
- Callback receives validated IntegrationsFile
- File provider integrates with Koanf correctly
</verification>

<success_criteria>
- [ ] IntegrationWatcher implements Start/Stop lifecycle
- [ ] Debouncing prevents reload storms (500ms default)
- [ ] Invalid configs logged but don't crash watcher
- [ ] Callback fires with validated IntegrationsFile
- [ ] Stop() returns within timeout (5 seconds)
- [ ] Unit tests pass for all scenarios
- [ ] No race conditions: `go test -race ./internal/config` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-infrastructure-foundation/01-03-SUMMARY.md`
</output>
