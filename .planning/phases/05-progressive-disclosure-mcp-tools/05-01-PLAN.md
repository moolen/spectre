---
phase: 05-progressive-disclosure-mcp-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/types.go
  - internal/mcp/server.go
  - internal/integration/manager.go
autonomous: true

must_haves:
  truths:
    - "Integration.RegisterTools() can add MCP tools to server"
    - "MCP server exposes integration tools with {type}_{instance}_{tool} naming"
    - "Multiple integration instances register independent tool sets"
  artifacts:
    - path: "internal/integration/types.go"
      provides: "Concrete ToolRegistry implementation"
      exports: ["MCPToolRegistry"]
    - path: "internal/mcp/server.go"
      provides: "ToolRegistry adapter implementing integration.ToolRegistry"
      min_lines: 30
    - path: "internal/integration/manager.go"
      provides: "RegisterTools() call during instance startup"
      contains: "RegisterTools"
  key_links:
    - from: "internal/integration/manager.go"
      to: "integration.RegisterTools()"
      via: "calls after Start() succeeds"
      pattern: "RegisterTools.*registry"
    - from: "internal/mcp/server.go"
      to: "s.mcpServer.AddTool"
      via: "adapter forwards to mcp-go"
      pattern: "AddTool.*handler"
---

<objective>
Create MCP tool registration infrastructure allowing integrations to register tools with the MCP server using a standardized naming convention and lifecycle integration.

Purpose: Foundation for all Phase 5 MCP tools. Integrations must be able to expose tools via RegisterTools() that become available to AI assistants with proper namespacing.

Output: Working ToolRegistry implementation wired into integration lifecycle, supporting dynamic tool registration per instance.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-CONTEXT.md

# Prior phases
@.planning/phases/01-plugin-infrastructure-foundation/01-04-SUMMARY.md
@.planning/phases/03-victorialogs-client-pipeline/03-03-SUMMARY.md

# Key source files
@internal/integration/types.go
@internal/mcp/server.go
@internal/integration/manager.go
@internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ToolRegistry adapter in MCP server</name>
  <files>
    internal/integration/types.go
    internal/mcp/server.go
  </files>
  <action>
Create concrete ToolRegistry implementation that adapts integration.ToolRegistry to mcp-go's tool registration API.

**In internal/integration/types.go:**
- Keep existing ToolRegistry interface unchanged (placeholder from Phase 1)
- ToolHandler signature: `func(ctx context.Context, args []byte) (interface{}, error)`

**In internal/mcp/server.go:**
- Add MCPToolRegistry struct implementing integration.ToolRegistry
- Field: mcpServer *server.MCPServer
- Implement RegisterTool(name string, handler integration.ToolHandler) error:
  1. Validate name is not empty
  2. Create inputSchema as generic JSON object (no validation, tools provide their own)
  3. Marshal schema to JSON
  4. Create mcp.Tool using NewToolWithRawSchema
  5. Create adapter func wrapping handler: unmarshal args, call handler, marshal result
  6. Call s.mcpServer.AddTool with mcp.Tool and adapter
- Follow existing registerTool() pattern in server.go lines 234-250

**Adapter pattern:**
```go
func (r *MCPToolRegistry) RegisterTool(name string, handler integration.ToolHandler) error {
    // Validation
    if name == "" {
        return fmt.Errorf("tool name cannot be empty")
    }

    // Generic schema (tools provide args via JSON)
    inputSchema := map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{},
    }
    schemaJSON, _ := json.Marshal(inputSchema)

    // Create MCP tool
    mcpTool := mcp.NewToolWithRawSchema(name, "", schemaJSON)

    // Adapter: integration.ToolHandler -> server.ToolHandlerFunc
    adaptedHandler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
        // Marshal mcp arguments to []byte for integration handler
        args, err := json.Marshal(request.Params.Arguments)
        if err != nil {
            return mcp.NewToolResultError(fmt.Sprintf("Invalid arguments: %v", err)), nil
        }

        // Call integration handler
        result, err := handler(ctx, args)
        if err != nil {
            return mcp.NewToolResultError(fmt.Sprintf("Tool execution failed: %v", err)), nil
        }

        // Format result
        resultJSON, _ := json.MarshalIndent(result, "", "  ")
        return mcp.NewToolResultText(string(resultJSON)), nil
    }

    r.mcpServer.AddTool(mcpTool, adaptedHandler)
    return nil
}
```

**Key constraint:** Tools register with just name, no description/schema. Integrations will provide full schema in their RegisterTools() implementation (Plans 2-4).
  </action>
  <verify>
go build ./internal/mcp
go build ./internal/integration
  </verify>
  <done>
MCPToolRegistry struct exists in internal/mcp/server.go, implements integration.ToolRegistry interface, adapts to mcp-go AddTool API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire RegisterTools into integration lifecycle</name>
  <files>
    internal/integration/manager.go
  </files>
  <action>
Modify Manager to call RegisterTools() for each integration instance after Start() succeeds or enters degraded state.

**In internal/integration/manager.go:**

1. Add mcpRegistry field to Manager struct:
```go
type Manager struct {
    registry      *Registry
    configPath    string
    watcher       *config.IntegrationWatcher
    logger        *logging.Logger
    mcpRegistry   integration.ToolRegistry  // NEW: for MCP tool registration
    // ... existing fields
}
```

2. Add NewManagerWithMCPRegistry constructor (keep existing NewManager for backwards compatibility):
```go
func NewManagerWithMCPRegistry(configPath string, mcpRegistry integration.ToolRegistry) (*Manager, error) {
    m, err := NewManager(configPath)
    if err != nil {
        return nil, err
    }
    m.mcpRegistry = mcpRegistry
    return m, nil
}
```

3. Update Start() method to register tools after each integration starts:
- Find the loop where integrations are started (after version validation)
- After each integration.Start() call (regardless of Healthy or Degraded status), add:
```go
// Register MCP tools if registry provided
if m.mcpRegistry != nil {
    if err := instance.Integration.RegisterTools(m.mcpRegistry); err != nil {
        m.logger.Error("Failed to register tools for %s: %v", cfg.Name, err)
        // Don't fail startup - log and continue
    }
}
```

**Why after Start() regardless of status:** Degraded integrations can still expose tools that return "service unavailable" errors. This allows AI assistants to discover available tools even when backends are temporarily down.

**No changes to existing Manager.Start() signature:** Existing callers continue to work. Only cmd/spectre or tests that need MCP integration use NewManagerWithMCPRegistry.
  </action>
  <verify>
go build ./internal/integration
go test ./internal/integration -run TestManager
  </verify>
  <done>
Manager has mcpRegistry field, NewManagerWithMCPRegistry constructor exists, Start() calls RegisterTools() after each integration starts (including degraded).
  </done>
</task>

<task type="auto">
  <name>Task 3: Update VictoriaLogs integration to use registry</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Update VictoriaLogsIntegration.RegisterTools() to store registry reference for use in Plans 2-4.

**In internal/integration/victorialogs/victorialogs.go:**

1. Add registry field to struct:
```go
type VictoriaLogsIntegration struct {
    name     string
    url      string
    client   *Client
    pipeline *Pipeline
    metrics  *Metrics
    logger   *logging.Logger
    registry integration.ToolRegistry  // NEW: stored for tool registration
}
```

2. Update RegisterTools() method (currently placeholder on line 123):
```go
func (v *VictoriaLogsIntegration) RegisterTools(registry integration.ToolRegistry) error {
    v.logger.Info("Registering VictoriaLogs MCP tools for instance: %s", v.name)

    // Store registry for future tool implementations (Plans 2-4)
    v.registry = registry

    // TODO Phase 5 Plans 2-4: Register overview, patterns, logs tools
    // Tool naming convention: victorialogs_{name}_{tool}
    // Example: victorialogs_prod_overview, victorialogs_prod_patterns, victorialogs_prod_logs

    v.logger.Info("VictoriaLogs tools registration complete (tools in Plans 2-4)")
    return nil
}
```

**Rationale:** Store registry reference now so Plans 2-4 can implement actual tool handlers without modifying Manager or lifecycle code. Integrations will call registry.RegisterTool() with full schema and handler functions.
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
VictoriaLogsIntegration has registry field, RegisterTools() stores reference, placeholder comment indicates where tools will be added in Plans 2-4.
  </done>
</task>

</tasks>

<verification>
1. Build all modified packages: `go build ./internal/mcp ./internal/integration ./internal/integration/victorialogs`
2. Run integration tests: `go test ./internal/integration -v`
3. Check MCPToolRegistry implements interface: `go vet ./internal/mcp`
4. Verify Manager calls RegisterTools: grep "RegisterTools" internal/integration/manager.go
</verification>

<success_criteria>
- [ ] MCPToolRegistry struct in internal/mcp/server.go implements integration.ToolRegistry
- [ ] Adapter converts integration.ToolHandler to server.ToolHandlerFunc
- [ ] Manager.Start() calls RegisterTools() for each integration after Start()
- [ ] VictoriaLogsIntegration stores registry reference
- [ ] All packages compile without errors
- [ ] Integration tests pass
- [ ] Plans 2-4 can call v.registry.RegisterTool() to add MCP tools
</success_criteria>

<output>
After completion, create `.planning/phases/05-progressive-disclosure-mcp-tools/05-01-SUMMARY.md` documenting:
- MCPToolRegistry implementation approach
- Integration lifecycle wiring decisions
- Tool naming convention established
- Files modified and key changes
</output>
