---
phase: 05-progressive-disclosure-mcp-tools
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - internal/integration/victorialogs/tools.go
  - internal/integration/victorialogs/tools_overview.go
  - internal/integration/victorialogs/victorialogs.go
autonomous: true

must_haves:
  truths:
    - "AI assistant can call victorialogs_{instance}_overview tool"
    - "Overview returns namespace-level error/panic/timeout counts"
    - "Smart defaults highlight errors/panics/timeouts first"
    - "Time range defaults to last 1 hour, minimum 15 minutes enforced"
  artifacts:
    - path: "internal/integration/victorialogs/tools_overview.go"
      provides: "Overview tool implementation with severity aggregation"
      exports: ["OverviewTool", "OverviewParams", "OverviewResponse"]
      min_lines: 150
    - path: "internal/integration/victorialogs/tools.go"
      provides: "Shared tool utilities and types"
      exports: ["ToolContext", "parseTimeRange"]
      min_lines: 50
    - path: "internal/integration/victorialogs/victorialogs.go"
      provides: "RegisterTools() calls registry.RegisterTool for overview"
      contains: "RegisterTool.*overview"
  key_links:
    - from: "internal/integration/victorialogs/victorialogs.go"
      to: "OverviewTool.Execute"
      via: "RegisterTool with overview handler"
      pattern: "RegisterTool.*overview.*Execute"
    - from: "OverviewTool.Execute"
      to: "v.client.QueryAggregation"
      via: "VictoriaLogs aggregation query"
      pattern: "QueryAggregation"
---

<objective>
Implement overview MCP tool providing namespace-level error/panic/timeout counts for progressive log exploration starting point.

Purpose: First level of progressive disclosure - AI assistants see high-level signals (errors, panics, timeouts) aggregated by namespace before drilling into patterns or raw logs.

Output: Working victorialogs_{instance}_overview tool returning severity counts by namespace with smart defaults prioritizing errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-CONTEXT.md

# Prior phase output
@.planning/phases/05-progressive-disclosure-mcp-tools/05-01-SUMMARY.md

# Key dependencies
@internal/integration/victorialogs/client.go
@internal/integration/victorialogs/query.go
@internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared tool utilities</name>
  <files>
    internal/integration/victorialogs/tools.go
  </files>
  <action>
Create shared utilities and types used across all VictoriaLogs MCP tools (overview, patterns, logs).

**File: internal/integration/victorialogs/tools.go**

```go
package victorialogs

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
)

// ToolContext provides shared context for tool execution
type ToolContext struct {
    Client   *Client
    Logger   *logging.Logger
    Instance string  // Integration instance name (e.g., "prod", "staging")
}

// TimeRangeParams represents time range input for tools
type TimeRangeParams struct {
    StartTime int64 `json:"start_time,omitempty"` // Unix seconds or milliseconds
    EndTime   int64 `json:"end_time,omitempty"`   // Unix seconds or milliseconds
}

// parseTimeRange converts TimeRangeParams to TimeRange with defaults
// Default: last 1 hour if not specified
// Minimum: 15 minutes (enforced by BuildLogsQLQuery via VLOG-03)
func parseTimeRange(params TimeRangeParams) TimeRange {
    now := time.Now()

    // Default: last 1 hour
    if params.StartTime == 0 && params.EndTime == 0 {
        return TimeRange{
            Start: now.Add(-1 * time.Hour),
            End:   now,
        }
    }

    // Parse start time
    start := now.Add(-1 * time.Hour) // Default if only end provided
    if params.StartTime != 0 {
        start = parseTimestamp(params.StartTime)
    }

    // Parse end time
    end := now // Default if only start provided
    if params.EndTime != 0 {
        end = parseTimestamp(params.EndTime)
    }

    return TimeRange{Start: start, End: end}
}

// parseTimestamp converts Unix timestamp (seconds or milliseconds) to time.Time
func parseTimestamp(ts int64) time.Time {
    // Heuristic: if > 10^10, it's milliseconds, else seconds
    if ts > 10000000000 {
        return time.Unix(0, ts*int64(time.Millisecond))
    }
    return time.Unix(ts, 0)
}
```

**Rationale:**
- parseTimeRange handles RFC3339 parsing with defaults matching CONTEXT.md (1 hour default)
- Reusable across all three tools (overview, patterns, logs)
- parseTimestamp handles both second and millisecond Unix timestamps (common AI assistant confusion)
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
tools.go exists with ToolContext, TimeRangeParams, parseTimeRange, parseTimestamp functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement overview tool</name>
  <files>
    internal/integration/victorialogs/tools_overview.go
  </files>
  <action>
Implement overview tool providing namespace-level error/panic/timeout counts for progressive disclosure starting point.

**File: internal/integration/victorialogs/tools_overview.go**

```go
package victorialogs

import (
    "context"
    "encoding/json"
    "fmt"
    "sort"
)

// OverviewTool provides global overview of log volume and severity by namespace
type OverviewTool struct {
    ctx ToolContext
}

// OverviewParams defines input parameters for overview tool
type OverviewParams struct {
    TimeRangeParams
    Namespace string `json:"namespace,omitempty"` // Optional: filter to specific namespace
    Severity  string `json:"severity,omitempty"`  // Optional: filter to severity (error, panic, timeout)
}

// OverviewResponse returns namespace-level severity counts
type OverviewResponse struct {
    TimeRange string              `json:"time_range"`   // Human-readable time range
    Namespaces []NamespaceSeverity `json:"namespaces"`   // Counts by namespace, sorted by total desc
    TotalLogs  int                 `json:"total_logs"`   // Total log count across all namespaces
}

// NamespaceSeverity holds severity counts for a namespace
type NamespaceSeverity struct {
    Namespace string `json:"namespace"`
    Errors    int    `json:"errors"`
    Panics    int    `json:"panics"`
    Timeouts  int    `json:"timeouts"`
    Other     int    `json:"other"`    // Non-error logs
    Total     int    `json:"total"`    // Sum of all severities
}

// Execute runs the overview tool
func (t *OverviewTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    // Parse parameters
    var params OverviewParams
    if err := json.Unmarshal(args, &params); err != nil {
        return nil, fmt.Errorf("invalid parameters: %w", err)
    }

    // Parse time range with defaults
    timeRange := parseTimeRange(params.TimeRangeParams)

    // Build LogsQL queries for severity counts
    // Query structure: count by namespace, filtered by severity keywords in log message
    // Smart defaults (PROG-05): errors, panics, timeouts highlighted

    // Query 1: Error logs (message contains "error", "err:", "failed", level=error)
    errorQuery := QueryParams{
        TimeRange: timeRange,
        Query:     buildSeverityQuery("error", params.Namespace),
    }

    // Query 2: Panic logs (message contains "panic", "PANIC")
    panicQuery := QueryParams{
        TimeRange: timeRange,
        Query:     buildSeverityQuery("panic", params.Namespace),
    }

    // Query 3: Timeout logs (message contains "timeout", "timed out", "deadline exceeded")
    timeoutQuery := QueryParams{
        TimeRange: timeRange,
        Query:     buildSeverityQuery("timeout", params.Namespace),
    }

    // Query 4: Total logs for "other" calculation
    totalQuery := QueryParams{
        TimeRange: timeRange,
    }
    if params.Namespace != "" {
        totalQuery.Namespace = params.Namespace
    }

    // Execute aggregation queries (group by namespace)
    errorCounts, err := t.ctx.Client.QueryAggregation(ctx, errorQuery, "namespace")
    if err != nil {
        return nil, fmt.Errorf("error query failed: %w", err)
    }

    panicCounts, err := t.ctx.Client.QueryAggregation(ctx, panicQuery, "namespace")
    if err != nil {
        return nil, fmt.Errorf("panic query failed: %w", err)
    }

    timeoutCounts, err := t.ctx.Client.QueryAggregation(ctx, timeoutQuery, "namespace")
    if err != nil {
        return nil, fmt.Errorf("timeout query failed: %w", err)
    }

    totalCounts, err := t.ctx.Client.QueryAggregation(ctx, totalQuery, "namespace")
    if err != nil {
        return nil, fmt.Errorf("total query failed: %w", err)
    }

    // Aggregate results by namespace
    namespaceMap := make(map[string]*NamespaceSeverity)

    for ns, count := range totalCounts {
        if _, exists := namespaceMap[ns]; !exists {
            namespaceMap[ns] = &NamespaceSeverity{Namespace: ns}
        }
        namespaceMap[ns].Total = count
    }

    for ns, count := range errorCounts {
        if _, exists := namespaceMap[ns]; !exists {
            namespaceMap[ns] = &NamespaceSeverity{Namespace: ns}
        }
        namespaceMap[ns].Errors = count
    }

    for ns, count := range panicCounts {
        if _, exists := namespaceMap[ns]; !exists {
            namespaceMap[ns] = &NamespaceSeverity{Namespace: ns}
        }
        namespaceMap[ns].Panics = count
    }

    for ns, count := range timeoutCounts {
        if _, exists := namespaceMap[ns]; !exists {
            namespaceMap[ns] = &NamespaceSeverity{Namespace: ns}
        }
        namespaceMap[ns].Timeouts = count
    }

    // Calculate "other" (total - errors - panics - timeouts)
    for _, ns := range namespaceMap {
        ns.Other = ns.Total - ns.Errors - ns.Panics - ns.Timeouts
        if ns.Other < 0 {
            ns.Other = 0 // Overlap in queries possible
        }
    }

    // Convert to slice and sort by total descending (most logs first)
    namespaces := make([]NamespaceSeverity, 0, len(namespaceMap))
    totalLogs := 0
    for _, ns := range namespaceMap {
        namespaces = append(namespaces, *ns)
        totalLogs += ns.Total
    }

    sort.Slice(namespaces, func(i, j int) bool {
        return namespaces[i].Total > namespaces[j].Total
    })

    // Build response
    return &OverviewResponse{
        TimeRange:  fmt.Sprintf("%s to %s", timeRange.Start.Format(time.RFC3339), timeRange.End.Format(time.RFC3339)),
        Namespaces: namespaces,
        TotalLogs:  totalLogs,
    }, nil
}

// buildSeverityQuery constructs LogsQL query for specific severity keywords
func buildSeverityQuery(severity, namespace string) string {
    var keywords []string
    switch severity {
    case "error":
        keywords = []string{"error", "err:", "failed", "ERROR", "ERR"}
    case "panic":
        keywords = []string{"panic", "PANIC", "panicked"}
    case "timeout":
        keywords = []string{"timeout", "timed out", "deadline exceeded", "TIMEOUT"}
    default:
        return "" // No filter
    }

    // Build OR query: (_msg:error OR _msg:err OR ...)
    query := "("
    for i, kw := range keywords {
        if i > 0 {
            query += " OR "
        }
        query += fmt.Sprintf("_msg:~%q", kw) // Use ~"keyword" for substring match
    }
    query += ")"

    // Add namespace filter if provided
    if namespace != "" {
        query = fmt.Sprintf(`namespace:=%q %s`, namespace, query)
    }

    return query
}
```

**Key design decisions:**
- Smart defaults: errors/panics/timeouts prioritized via separate queries (PROG-05)
- Severity detection via message content keywords (no assumption about level field)
- Aggregation by namespace using QueryAggregation (from Phase 3)
- Sorted by total count descending (busiest namespaces first)
- Compact response format (CONTEXT.md: minimal data, counts, short summaries)
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
tools_overview.go exists with OverviewTool, OverviewParams, OverviewResponse, Execute method, buildSeverityQuery helper.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register overview tool</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Update VictoriaLogsIntegration.RegisterTools() to register overview tool with MCP server.

**In internal/integration/victorialogs/victorialogs.go:**

Replace placeholder RegisterTools() implementation (from Plan 01) with:

```go
func (v *VictoriaLogsIntegration) RegisterTools(registry integration.ToolRegistry) error {
    v.logger.Info("Registering VictoriaLogs MCP tools for instance: %s", v.name)

    // Store registry for future tool implementations (Plans 3-4)
    v.registry = registry

    // Create tool context shared across all tools
    toolCtx := ToolContext{
        Client:   v.client,
        Logger:   v.logger,
        Instance: v.name,
    }

    // Register overview tool: victorialogs_{name}_overview
    overviewTool := &OverviewTool{ctx: toolCtx}
    overviewName := fmt.Sprintf("victorialogs_%s_overview", v.name)
    if err := registry.RegisterTool(overviewName, overviewTool.Execute); err != nil {
        return fmt.Errorf("failed to register overview tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", overviewName)

    // TODO Plan 3: Register patterns tool (victorialogs_{name}_patterns)
    // TODO Plan 4: Register logs tool (victorialogs_{name}_logs)

    v.logger.Info("VictoriaLogs tools registration complete")
    return nil
}
```

**Tool naming convention (from CONTEXT.md):**
- Format: `{integration-type}_{instance-name}_{tool}`
- Example: `victorialogs_prod_overview`, `victorialogs_staging_overview`
- Each integration instance gets independent tool set (multi-environment support)

**Why check v.client != nil:** If integration is in Stopped or Degraded state at registration time, client might be nil. Tools should handle nil gracefully or skip registration.

Add nil check:
```go
if v.client == nil {
    v.logger.Warn("Client not initialized, skipping tool registration")
    return nil
}
```
  </action>
  <verify>
go build ./internal/integration/victorialogs
go test ./internal/integration/victorialogs -run TestVictoriaLogs
  </verify>
  <done>
RegisterTools() creates OverviewTool with ToolContext, registers with naming convention victorialogs_{name}_overview, includes nil client check.
  </done>
</task>

</tasks>

<verification>
1. Build package: `go build ./internal/integration/victorialogs`
2. Run tests: `go test ./internal/integration/victorialogs -v`
3. Check tool registration: grep "RegisterTool.*overview" internal/integration/victorialogs/victorialogs.go
4. Verify naming convention: tool name should be victorialogs_{instance}_overview
</verification>

<success_criteria>
- [ ] tools.go provides parseTimeRange with 1-hour default and 15-minute minimum
- [ ] tools_overview.go implements OverviewTool with Execute method
- [ ] Overview queries VictoriaLogs for error/panic/timeout counts by namespace
- [ ] Response sorted by total count descending (busiest namespaces first)
- [ ] RegisterTools() registers overview tool with victorialogs_{instance}_overview naming
- [ ] All packages compile without errors
- [ ] Plans 3-4 can follow same pattern for patterns and logs tools
</success_criteria>

<output>
After completion, create `.planning/phases/05-progressive-disclosure-mcp-tools/05-02-SUMMARY.md` documenting:
- Overview tool implementation approach
- Severity detection strategy (keyword-based)
- Smart defaults for error/panic/timeout highlighting
- Tool naming convention in practice
- Files created and key decisions
</output>
