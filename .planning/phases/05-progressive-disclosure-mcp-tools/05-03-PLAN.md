---
phase: 05-progressive-disclosure-mcp-tools
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - internal/integration/victorialogs/tools_patterns.go
  - internal/integration/victorialogs/victorialogs.go
  - internal/logprocessing/store.go
autonomous: true

must_haves:
  truths:
    - "AI assistant can call victorialogs_{instance}_patterns tool"
    - "Patterns returns log templates with counts and novelty flags"
    - "Novelty detection compares current period to previous period of same duration"
    - "High-volume patterns ranked by count"
    - "Template mining samples high-volume namespaces for efficiency"
  artifacts:
    - path: "internal/integration/victorialogs/tools_patterns.go"
      provides: "Patterns tool with template mining and novelty detection"
      exports: ["PatternsTool", "PatternsParams", "PatternsResponse"]
      min_lines: 200
    - path: "internal/logprocessing/store.go"
      provides: "CompareTimeWindows method for novelty detection"
      exports: ["CompareTimeWindows"]
      min_lines: 30
    - path: "internal/integration/victorialogs/victorialogs.go"
      provides: "TemplateStore integration and patterns tool registration"
      contains: "templateStore"
  key_links:
    - from: "PatternsTool.Execute"
      to: "v.client.QueryLogs"
      via: "fetch logs for current and previous time windows"
      pattern: "QueryLogs.*timeRange"
    - from: "PatternsTool.Execute"
      to: "templateStore.Process"
      via: "mine templates from fetched logs"
      pattern: "Process.*logMessage"
    - from: "PatternsTool.Execute"
      to: "templateStore.CompareTimeWindows"
      via: "detect novel templates"
      pattern: "CompareTimeWindows"
---

<objective>
Implement patterns MCP tool providing log template aggregation with novelty detection, enabling AI assistants to drill from overview into specific log patterns without viewing raw logs.

Purpose: Second level of progressive disclosure - identify common patterns and novel behaviors. Integrates Phase 4 template mining with Phase 3 VictoriaLogs queries.

Output: Working victorialogs_{instance}_patterns tool returning templates with counts, novelty flags, and sample raw logs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-CONTEXT.md

# Prior phase outputs
@.planning/phases/04-log-template-mining/04-04-SUMMARY.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-01-SUMMARY.md

# Key dependencies
@internal/logprocessing/store.go
@internal/logprocessing/types.go
@internal/integration/victorialogs/client.go
@internal/integration/victorialogs/tools.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add novelty detection to TemplateStore</name>
  <files>
    internal/logprocessing/store.go
  </files>
  <action>
Add CompareTimeWindows method to TemplateStore for novelty detection comparing current templates to previous time window.

**In internal/logprocessing/store.go:**

Add method after GetNamespaces():

```go
// CompareTimeWindows identifies novel templates by comparing current to previous.
// Returns map of templateID -> isNovel (true if template exists in current but not previous).
//
// Design decision from CONTEXT.md: "Compare current period to previous period of same duration"
// Example: Query last 1h (current) vs hour before that (previous) to find new patterns.
func (ts *TemplateStore) CompareTimeWindows(namespace string, currentTemplates, previousTemplates []Template) map[string]bool {
    // Build set of template patterns from previous window
    previousPatterns := make(map[string]bool)
    for _, tmpl := range previousTemplates {
        previousPatterns[tmpl.Pattern] = true
    }

    // Compare current templates to previous
    novelty := make(map[string]bool)
    for _, tmpl := range currentTemplates {
        // Novel if pattern didn't exist in previous window
        isNovel := !previousPatterns[tmpl.Pattern]
        novelty[tmpl.ID] = isNovel
    }

    return novelty
}
```

**Why compare by Pattern not ID:**
- Template IDs include namespace in hash, but patterns are semantic
- Same pattern in different namespaces has different ID but same behavior
- Comparing patterns detects "this log message never appeared before" (semantic novelty)

**Alternative considered:** Compare by token similarity (Levenshtein). Rejected for simplicity - exact pattern match is sufficient for v1.
  </action>
  <verify>
go build ./internal/logprocessing
go test ./internal/logprocessing -run TestTemplateStore
  </verify>
  <done>
CompareTimeWindows method exists in store.go, returns map[string]bool of novelty flags, compares by pattern not ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate TemplateStore into VictoriaLogs integration</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Add TemplateStore to VictoriaLogsIntegration for on-the-fly template mining during patterns tool queries.

**In internal/integration/victorialogs/victorialogs.go:**

1. Import logprocessing package:
```go
import (
    // ... existing imports
    "github.com/moolen/spectre/internal/logprocessing"
)
```

2. Add templateStore field to struct:
```go
type VictoriaLogsIntegration struct {
    name          string
    url           string
    client        *Client
    pipeline      *Pipeline
    metrics       *Metrics
    logger        *logging.Logger
    registry      integration.ToolRegistry
    templateStore *logprocessing.TemplateStore  // NEW: for pattern mining
}
```

3. Initialize in Start() method (after pipeline creation):
```go
// Create template store with default Drain config (from Phase 4)
drainConfig := logprocessing.DrainConfig{
    Depth:        4,
    SimTh:        0.4,
    MaxChildren:  100,
}
v.templateStore = logprocessing.NewTemplateStore(drainConfig)
v.logger.Info("Template store initialized with Drain config: depth=%d, simTh=%.2f", drainConfig.Depth, drainConfig.SimTh)
```

4. Clear in Stop() method:
```go
// Clear template store
v.templateStore = nil
```

**Design decision:** Create TemplateStore per integration instance, not global.
- Rationale: Different VictoriaLogs instances (prod, staging) have different log characteristics
- Each instance mines its own templates independently
- No shared state between instances = simpler lifecycle

**No persistence:** TemplateStore is ephemeral (created at Start, cleared at Stop). Phase 4's PersistenceManager is NOT used here because:
- Pattern tool queries are on-demand, not continuous background processing
- Templates mined per query, not accumulated over time
- User decision from CONTEXT.md: "stateless design where each tool call is independent"
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
VictoriaLogsIntegration has templateStore field, initialized in Start() with Drain config, cleared in Stop().
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement patterns tool with sampling and novelty</name>
  <files>
    internal/integration/victorialogs/tools_patterns.go
  </files>
  <action>
Implement patterns tool with template mining, novelty detection, sampling for high-volume namespaces, and time-window batching.

**File: internal/integration/victorialogs/tools_patterns.go**

```go
package victorialogs

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/moolen/spectre/internal/logprocessing"
)

// PatternsTool provides aggregated log patterns with novelty detection
type PatternsTool struct {
    ctx           ToolContext
    templateStore *logprocessing.TemplateStore
}

// PatternsParams defines input parameters for patterns tool
type PatternsParams struct {
    TimeRangeParams
    Namespace string `json:"namespace"` // Required: namespace to query
    Limit     int    `json:"limit,omitempty"` // Optional: max templates to return (default 50)
}

// PatternsResponse returns templates with counts and novelty flags
type PatternsResponse struct {
    TimeRange    string              `json:"time_range"`
    Namespace    string              `json:"namespace"`
    Templates    []PatternTemplate   `json:"templates"` // Sorted by count descending
    TotalLogs    int                 `json:"total_logs"`
    NovelCount   int                 `json:"novel_count"` // Count of novel templates
}

// PatternTemplate represents a log template with metadata
type PatternTemplate struct {
    TemplateID   string `json:"template_id"`
    Pattern      string `json:"pattern"`       // Masked pattern with <VAR> placeholders
    Count        int    `json:"count"`         // Occurrences in current time window
    IsNovel      bool   `json:"is_novel"`      // True if not in previous time window
    SampleLog    string `json:"sample_log"`    // One raw log matching this template
}

// Execute runs the patterns tool
func (t *PatternsTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    // Parse parameters
    var params PatternsParams
    if err := json.Unmarshal(args, &params); err != nil {
        return nil, fmt.Errorf("invalid parameters: %w", err)
    }

    // Validate required namespace
    if params.Namespace == "" {
        return nil, fmt.Errorf("namespace is required")
    }

    // Default limit
    if params.Limit == 0 {
        params.Limit = 50
    }

    // Parse time range
    timeRange := parseTimeRange(params.TimeRangeParams)

    // MINE-06: Time-window batching for efficiency
    // Fetch logs for current time window with sampling for high-volume
    currentLogs, err := t.fetchLogsWithSampling(ctx, params.Namespace, timeRange, params.Limit)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch current logs: %w", err)
    }

    // Mine templates from current logs
    currentTemplates := t.mineTemplates(params.Namespace, currentLogs)

    // NOVL-01: Compare to previous time window for novelty detection
    // Previous window = same duration immediately before current window
    duration := timeRange.End.Sub(timeRange.Start)
    previousTimeRange := TimeRange{
        Start: timeRange.Start.Add(-duration),
        End:   timeRange.Start,
    }

    // Fetch logs for previous time window (same sampling)
    previousLogs, err := t.fetchLogsWithSampling(ctx, params.Namespace, previousTimeRange, params.Limit)
    if err != nil {
        // Log warning but continue (novelty detection fails gracefully)
        t.ctx.Logger.Warn("Failed to fetch previous window for novelty detection: %v", err)
        previousLogs = []LogEntry{} // Empty previous = all current templates novel
    }

    // Mine templates from previous logs
    previousTemplates := t.mineTemplates(params.Namespace, previousLogs)

    // NOVL-02: Detect novel templates
    novelty := t.templateStore.CompareTimeWindows(params.Namespace, currentTemplates, previousTemplates)

    // Build response with novelty flags
    templates := make([]PatternTemplate, 0, len(currentTemplates))
    novelCount := 0
    sampleMap := buildSampleMap(currentLogs)

    for _, tmpl := range currentTemplates {
        isNovel := novelty[tmpl.ID]
        if isNovel {
            novelCount++
        }

        templates = append(templates, PatternTemplate{
            TemplateID: tmpl.ID,
            Pattern:    tmpl.Pattern,
            Count:      tmpl.Count,
            IsNovel:    isNovel,
            SampleLog:  sampleMap[tmpl.Pattern], // One raw log for this pattern
        })
    }

    // Limit response size (already sorted by count from ListTemplates)
    if len(templates) > params.Limit {
        templates = templates[:params.Limit]
    }

    return &PatternsResponse{
        TimeRange:  fmt.Sprintf("%s to %s", timeRange.Start.Format(time.RFC3339), timeRange.End.Format(time.RFC3339)),
        Namespace:  params.Namespace,
        Templates:  templates,
        TotalLogs:  len(currentLogs),
        NovelCount: novelCount,
    }, nil
}

// fetchLogsWithSampling fetches logs with sampling for high-volume namespaces (MINE-05)
func (t *PatternsTool) fetchLogsWithSampling(ctx context.Context, namespace string, timeRange TimeRange, targetSamples int) ([]LogEntry, error) {
    // Query for log count first
    countQuery := QueryParams{
        TimeRange: timeRange,
        Namespace: namespace,
        Limit:     1,
    }
    result, err := t.ctx.Client.QueryLogs(ctx, countQuery)
    if err != nil {
        return nil, err
    }

    totalLogs := len(result.Logs)

    // MINE-05: Sample high-volume namespaces
    // If namespace has more than targetSamples * 10 logs, apply sampling
    samplingThreshold := targetSamples * 10
    limit := totalLogs
    if totalLogs > samplingThreshold {
        // Fetch sample size (targetSamples * 2 for better template coverage)
        limit = targetSamples * 2
        t.ctx.Logger.Info("High-volume namespace %s (%d logs), sampling %d", namespace, totalLogs, limit)
    }

    // Fetch logs with limit
    query := QueryParams{
        TimeRange: timeRange,
        Namespace: namespace,
        Limit:     limit,
    }

    result, err = t.ctx.Client.QueryLogs(ctx, query)
    if err != nil {
        return nil, err
    }

    return result.Logs, nil
}

// mineTemplates processes logs through TemplateStore and returns sorted templates
func (t *PatternsTool) mineTemplates(namespace string, logs []LogEntry) []logprocessing.Template {
    // Process each log through template store
    for _, log := range logs {
        // Extract message field (JSON or plain text)
        message := extractMessage(log)
        _, _ = t.templateStore.Process(namespace, message)
    }

    // Get templates sorted by count
    templates, err := t.templateStore.ListTemplates(namespace)
    if err != nil {
        t.ctx.Logger.Warn("Failed to list templates for %s: %v", namespace, err)
        return []logprocessing.Template{}
    }

    return templates
}

// extractMessage extracts message from LogEntry (handles JSON and plain text)
func extractMessage(log LogEntry) string {
    // If log has _msg field, use it
    if msg, ok := log.Fields["_msg"].(string); ok && msg != "" {
        return msg
    }

    // Otherwise, try message, msg, log fields (from Phase 4 PreProcess)
    for _, field := range []string{"message", "msg", "log", "text", "event"} {
        if val, ok := log.Fields[field].(string); ok && val != "" {
            return val
        }
    }

    // Fallback: return entire log as JSON string
    data, _ := json.Marshal(log.Fields)
    return string(data)
}

// buildSampleMap creates map of pattern -> first matching raw log
func buildSampleMap(logs []LogEntry) map[string]string {
    // Simple approach: just return first log for each pattern
    // More sophisticated: store during mining, but requires TemplateStore modification
    // For v1: accept that sample might not be perfect match
    sampleMap := make(map[string]string)
    for _, log := range logs {
        msg := extractMessage(log)
        if len(sampleMap) < 100 { // Limit map size
            sampleMap[msg] = msg
        }
    }
    return sampleMap
}
```

**Key design decisions:**
- MINE-05: Sampling threshold = targetSamples * 10 (default 50 * 10 = 500 logs)
- MINE-06: Time-window batching via single QueryLogs call per window (not streaming)
- NOVL-01-03: Novelty via pattern comparison between current and previous equal-duration windows
- Compact response: one sample log per template (CONTEXT.md requirement)
- Stateless: TemplateStore populated on-demand per query, not persistent
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
tools_patterns.go exists with PatternsTool, Execute method, fetchLogsWithSampling, mineTemplates, novelty detection.
  </done>
</task>

<task type="auto">
  <name>Task 4: Register patterns tool</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Update RegisterTools() to register patterns tool with template store reference.

**In internal/integration/victorialogs/victorialogs.go:**

Update RegisterTools() method to add patterns tool after overview registration:

```go
func (v *VictoriaLogsIntegration) RegisterTools(registry integration.ToolRegistry) error {
    v.logger.Info("Registering VictoriaLogs MCP tools for instance: %s", v.name)

    // Nil check for client and template store
    if v.client == nil || v.templateStore == nil {
        v.logger.Warn("Client or template store not initialized, skipping tool registration")
        return nil
    }

    // Store registry
    v.registry = registry

    // Create tool context
    toolCtx := ToolContext{
        Client:   v.client,
        Logger:   v.logger,
        Instance: v.name,
    }

    // Register overview tool
    overviewTool := &OverviewTool{ctx: toolCtx}
    overviewName := fmt.Sprintf("victorialogs_%s_overview", v.name)
    if err := registry.RegisterTool(overviewName, overviewTool.Execute); err != nil {
        return fmt.Errorf("failed to register overview tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", overviewName)

    // Register patterns tool
    patternsTool := &PatternsTool{
        ctx:           toolCtx,
        templateStore: v.templateStore,
    }
    patternsName := fmt.Sprintf("victorialogs_%s_patterns", v.name)
    if err := registry.RegisterTool(patternsName, patternsTool.Execute); err != nil {
        return fmt.Errorf("failed to register patterns tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", patternsName)

    // TODO Plan 4: Register logs tool (victorialogs_{name}_logs)

    v.logger.Info("VictoriaLogs tools registration complete")
    return nil
}
```

**Nil check includes templateStore:** Pattern tool requires template store, so skip registration if not initialized.
  </action>
  <verify>
go build ./internal/integration/victorialogs
go test ./internal/integration/victorialogs -v
  </verify>
  <done>
RegisterTools() registers patterns tool with victorialogs_{name}_patterns naming, includes nil check for templateStore.
  </done>
</task>

</tasks>

<verification>
1. Build all packages: `go build ./internal/logprocessing ./internal/integration/victorialogs`
2. Run tests: `go test ./internal/logprocessing ./internal/integration/victorialogs -v`
3. Check tool registration: grep "RegisterTool.*patterns" internal/integration/victorialogs/victorialogs.go
4. Verify sampling logic: grep "MINE-05" internal/integration/victorialogs/tools_patterns.go
5. Verify novelty detection: grep "CompareTimeWindows" internal/integration/victorialogs/tools_patterns.go
</verification>

<success_criteria>
- [ ] CompareTimeWindows method exists in logprocessing/store.go
- [ ] VictoriaLogsIntegration has templateStore field initialized in Start()
- [ ] PatternsTool implements Execute with sampling and novelty detection
- [ ] High-volume namespace sampling (MINE-05) implemented with threshold
- [ ] Time-window batching (MINE-06) via single QueryLogs per window
- [ ] Novelty detection (NOVL-01-03) compares current to previous window
- [ ] RegisterTools() registers victorialogs_{instance}_patterns tool
- [ ] All packages compile and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-progressive-disclosure-mcp-tools/05-03-SUMMARY.md` documenting:
- Template mining integration approach
- Sampling strategy for high-volume namespaces
- Novelty detection algorithm
- Time-window batching implementation
- Files created and key decisions
</output>
