---
phase: 05-progressive-disclosure-mcp-tools
plan: 04
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - internal/integration/victorialogs/tools_logs.go
  - internal/integration/victorialogs/victorialogs.go
  - cmd/spectre/commands/server.go
autonomous: false

must_haves:
  truths:
    - "AI assistant can call victorialogs_{instance}_logs tool"
    - "Logs tool returns raw logs for specific namespace and time range"
    - "Tool enforces reasonable limits to prevent context overflow"
    - "All three tools (overview, patterns, logs) work together for progressive disclosure"
    - "MCP server exposes all registered integration tools"
  artifacts:
    - path: "internal/integration/victorialogs/tools_logs.go"
      provides: "Logs tool returning raw logs with pagination"
      exports: ["LogsTool", "LogsParams", "LogsResponse"]
      min_lines: 100
    - path: "cmd/spectre/commands/server.go"
      provides: "MCP server wiring with integration manager"
      contains: "NewManagerWithMCPRegistry"
  key_links:
    - from: "cmd/spectre/commands/server.go"
      to: "integration.NewManagerWithMCPRegistry"
      via: "passes MCPToolRegistry to manager"
      pattern: "NewManagerWithMCPRegistry.*registry"
    - from: "LogsTool.Execute"
      to: "v.client.QueryLogs"
      via: "fetch raw logs"
      pattern: "QueryLogs"
---

<objective>
Implement logs MCP tool for raw log viewing and wire complete progressive disclosure system into MCP server, enabling end-to-end log exploration workflow.

Purpose: Third level of progressive disclosure - view raw logs after narrowing scope via overview and patterns. Complete integration of Phases 1-4 work into functional MCP tooling.

Output: Working victorialogs_{instance}_logs tool plus complete MCP server wiring allowing AI assistants to explore logs progressively.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-CONTEXT.md

# Prior phase outputs
@.planning/phases/05-progressive-disclosure-mcp-tools/05-01-SUMMARY.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-02-SUMMARY.md
@.planning/phases/05-progressive-disclosure-mcp-tools/05-03-SUMMARY.md

# Key files
@cmd/spectre/commands/server.go
@cmd/spectre/commands/mcp.go
@internal/integration/victorialogs/tools.go
@internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement logs tool</name>
  <files>
    internal/integration/victorialogs/tools_logs.go
  </files>
  <action>
Implement logs tool returning raw logs for specific namespace and time range, with reasonable limits to prevent AI assistant context overflow.

**File: internal/integration/victorialogs/tools_logs.go**

```go
package victorialogs

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
)

// LogsTool provides raw log viewing for narrow scope queries
type LogsTool struct {
    ctx ToolContext
}

// LogsParams defines input parameters for logs tool
type LogsParams struct {
    TimeRangeParams
    Namespace string `json:"namespace"` // Required: namespace to query
    Limit     int    `json:"limit,omitempty"` // Optional: max logs to return (default 100, max 500)
}

// LogsResponse returns raw logs
type LogsResponse struct {
    TimeRange string     `json:"time_range"`
    Namespace string     `json:"namespace"`
    Logs      []LogEntry `json:"logs"`      // Raw log entries
    Count     int        `json:"count"`     // Number of logs returned
    Truncated bool       `json:"truncated"` // True if result set was truncated
}

// LogEntry represents a single raw log (already defined in types.go or client.go)
// If not, define here:
// type LogEntry struct {
//     Timestamp time.Time              `json:"timestamp"`
//     Fields    map[string]interface{} `json:"fields"`
// }

// Execute runs the logs tool
func (t *LogsTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    // Parse parameters
    var params LogsParams
    if err := json.Unmarshal(args, &params); err != nil {
        return nil, fmt.Errorf("invalid parameters: %w", err)
    }

    // Validate required namespace
    if params.Namespace == "" {
        return nil, fmt.Errorf("namespace is required")
    }

    // Enforce limits (prevent context overflow for AI assistants)
    const MaxLimit = 500
    const DefaultLimit = 100

    if params.Limit == 0 {
        params.Limit = DefaultLimit
    }
    if params.Limit > MaxLimit {
        params.Limit = MaxLimit
    }

    // Parse time range with defaults
    timeRange := parseTimeRange(params.TimeRangeParams)

    // Query raw logs
    queryParams := QueryParams{
        TimeRange: timeRange,
        Namespace: params.Namespace,
        Limit:     params.Limit + 1, // Fetch one extra to detect truncation
    }

    result, err := t.ctx.Client.QueryLogs(ctx, queryParams)
    if err != nil {
        return nil, fmt.Errorf("query failed: %w", err)
    }

    // Check truncation
    truncated := len(result.Logs) > params.Limit
    logs := result.Logs
    if truncated {
        logs = logs[:params.Limit] // Trim to requested limit
    }

    return &LogsResponse{
        TimeRange: fmt.Sprintf("%s to %s", timeRange.Start.Format(time.RFC3339), timeRange.End.Format(time.RFC3339)),
        Namespace: params.Namespace,
        Logs:      logs,
        Count:     len(logs),
        Truncated: truncated,
    }, nil
}
```

**Key design decisions:**
- Default limit: 100 logs (reasonable for AI assistant context)
- Maximum limit: 500 logs (prevent accidental context overflow)
- Truncation flag: AI assistant knows if more logs exist
- No template filtering: This tool is for raw logs after narrowing scope via patterns
- PROG-04: Filter state preserved - AI assistant passes namespace + time range from patterns response

**Why no pagination:** CONTEXT.md specifies "no pagination - return all results up to reasonable limit, truncate if too many". Truncation flag tells AI assistant to narrow time range or use patterns tool first.
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
tools_logs.go exists with LogsTool, Execute method, limit enforcement (default 100, max 500), truncation detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register logs tool</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Complete RegisterTools() implementation by registering logs tool, making all three progressive disclosure tools available.

**In internal/integration/victorialogs/victorialogs.go:**

Update RegisterTools() method to add logs tool after patterns registration:

```go
func (v *VictoriaLogsIntegration) RegisterTools(registry integration.ToolRegistry) error {
    v.logger.Info("Registering VictoriaLogs MCP tools for instance: %s", v.name)

    // Nil check
    if v.client == nil || v.templateStore == nil {
        v.logger.Warn("Client or template store not initialized, skipping tool registration")
        return nil
    }

    // Store registry
    v.registry = registry

    // Create tool context
    toolCtx := ToolContext{
        Client:   v.client,
        Logger:   v.logger,
        Instance: v.name,
    }

    // Register overview tool
    overviewTool := &OverviewTool{ctx: toolCtx}
    overviewName := fmt.Sprintf("victorialogs_%s_overview", v.name)
    if err := registry.RegisterTool(overviewName, overviewTool.Execute); err != nil {
        return fmt.Errorf("failed to register overview tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", overviewName)

    // Register patterns tool
    patternsTool := &PatternsTool{
        ctx:           toolCtx,
        templateStore: v.templateStore,
    }
    patternsName := fmt.Sprintf("victorialogs_%s_patterns", v.name)
    if err := registry.RegisterTool(patternsName, patternsTool.Execute); err != nil {
        return fmt.Errorf("failed to register patterns tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", patternsName)

    // Register logs tool
    logsTool := &LogsTool{ctx: toolCtx}
    logsName := fmt.Sprintf("victorialogs_%s_logs", v.name)
    if err := registry.RegisterTool(logsName, logsTool.Execute); err != nil {
        return fmt.Errorf("failed to register logs tool: %w", err)
    }
    v.logger.Info("Registered tool: %s", logsName)

    v.logger.Info("VictoriaLogs progressive disclosure tools registered: overview, patterns, logs")
    return nil
}
```

**All three tools now registered:**
- victorialogs_{instance}_overview - namespace-level severity counts
- victorialogs_{instance}_patterns - template aggregation with novelty
- victorialogs_{instance}_logs - raw log viewing

**Progressive disclosure workflow:**
1. AI calls overview → sees namespaces with high error counts
2. AI calls patterns with high-error namespace → sees common error templates and novel patterns
3. AI calls logs with namespace + narrowed time range → views raw logs for specific investigation
  </action>
  <verify>
go build ./internal/integration/victorialogs
  </verify>
  <done>
RegisterTools() registers all three tools (overview, patterns, logs) with proper naming convention.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire integration manager into MCP server</name>
  <files>
    cmd/spectre/commands/server.go
  </files>
  <action>
Wire integration manager into MCP server startup so RegisterTools() is called and tools become available to AI assistants.

**In cmd/spectre/commands/server.go:**

1. Find the server startup section (where MCP server is created)

2. Look for existing integration manager initialization:
```go
// Existing code creates integration manager:
integrationMgr, err := integration.NewManager(integrationConfigPath)
```

3. Add MCP server creation BEFORE integration manager:
```go
// Create MCP server first
mcpServer, err := mcp.NewSpectreServerWithOptions(mcp.ServerOptions{
    SpectreURL: spectreURL,  // From flags or config
    Version:    version,      // From build info
})
if err != nil {
    return fmt.Errorf("failed to create MCP server: %w", err)
}

// Create MCPToolRegistry adapter
mcpRegistry := &mcp.MCPToolRegistry{
    mcpServer: mcpServer.GetMCPServer(),
}

// Create integration manager WITH MCP registry
integrationMgr, err := integration.NewManagerWithMCPRegistry(integrationConfigPath, mcpRegistry)
if err != nil {
    return fmt.Errorf("failed to create integration manager: %w", err)
}
```

4. Start integration manager (existing code):
```go
if err := integrationMgr.Start(ctx); err != nil {
    return fmt.Errorf("failed to start integration manager: %w", err)
}
```

**Order matters:**
1. Create MCP server
2. Create MCPToolRegistry adapter
3. Create integration manager with registry
4. Start integration manager (calls RegisterTools for each integration)
5. Start MCP server transport (existing code)

**If MCP server already exists in server.go:** Modify existing initialization to create MCPToolRegistry and pass to NewManagerWithMCPRegistry.

**Fallback if no MCP server in server command:** Integration manager should work without MCP registry (nil check in Plan 01 Task 2). Tools simply won't be registered if MCP server not present.
  </action>
  <verify>
go build ./cmd/spectre
./spectre server --help
  </verify>
  <done>
cmd/spectre/commands/server.go creates MCPToolRegistry and passes to NewManagerWithMCPRegistry, integration tools registered at startup.
  </done>
</task>

</tasks>

<verification>
**Automated checks:**
1. Build all packages: `go build ./internal/integration/victorialogs ./cmd/spectre`
2. Run tests: `go test ./internal/integration/victorialogs -v`
3. Check tool registration: `grep -r "victorialogs_.*_logs" internal/integration/victorialogs/`
4. Verify MCP wiring: `grep "NewManagerWithMCPRegistry" cmd/spectre/commands/server.go`

**Manual verification checkpoint - see Task 4 below**
</verification>

<success_criteria>
- [ ] tools_logs.go implements LogsTool with Execute method
- [ ] Logs tool enforces limits (default 100, max 500) and detects truncation
- [ ] RegisterTools() registers all three tools (overview, patterns, logs)
- [ ] cmd/spectre/commands/server.go wires MCPToolRegistry into integration manager
- [ ] All packages compile without errors
- [ ] Integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-progressive-disclosure-mcp-tools/05-04-SUMMARY.md` documenting:
- Logs tool implementation approach
- Limit enforcement strategy
- Complete progressive disclosure workflow
- MCP server integration wiring
- Files modified and key decisions
</output>
