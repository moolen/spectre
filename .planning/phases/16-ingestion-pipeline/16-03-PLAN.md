---
phase: 16-ingestion-pipeline
plan: 03
type: execute
wave: 3
depends_on: [16-02]
files_modified:
  - internal/integration/types.go
  - internal/integration/grafana/grafana.go
  - internal/api/integration_handler.go
  - ui/src/pages/IntegrationsPage.tsx
  - ui/src/types.ts
autonomous: true

must_haves:
  truths:
    - "User can see sync status (last sync time, dashboard count) in integrations list"
    - "User can trigger manual sync from integrations table row"
    - "Sync button shows loading state during active sync"
    - "Sync errors are displayed to user with details"
    - "Sync status updates without page refresh"
  artifacts:
    - path: "internal/integration/types.go"
      provides: "SyncStatus field on IntegrationStatus"
      contains: "SyncStatus"
      min_lines: 5
    - path: "internal/api/integration_handler.go"
      provides: "POST /api/v1/integrations/{name}/sync endpoint"
      contains: "handleSyncIntegration"
      min_lines: 30
    - path: "ui/src/pages/IntegrationsPage.tsx"
      provides: "Sync button and status display"
      contains: "syncIntegration"
      min_lines: 20
  key_links:
    - from: "ui/src/pages/IntegrationsPage.tsx"
      to: "internal/api/integration_handler.go"
      via: "POST /api/v1/integrations/{name}/sync API call"
      pattern: "/api/v1/integrations/.*/sync"
    - from: "internal/api/integration_handler.go"
      to: "internal/integration/grafana/dashboard_syncer.go"
      via: "GetSyncStatus and TriggerSync methods"
      pattern: "syncer\\.(GetSyncStatus|TriggerSync)"
---

<objective>
Add UI sync status display and manual sync trigger for Grafana dashboard synchronization.

Purpose: Provide visibility into sync operations and allow users to manually refresh dashboards without waiting for hourly interval. Essential for operational transparency.

Output: Working sync status display in integrations list with manual sync button, real-time updates, and error visibility.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-ingestion-pipeline/16-CONTEXT.md
@.planning/phases/16-ingestion-pipeline/16-01-SUMMARY.md
@.planning/phases/16-ingestion-pipeline/16-02-SUMMARY.md
@internal/integration/types.go
@internal/integration/grafana/grafana.go
@internal/integration/grafana/dashboard_syncer.go
@internal/api/integration_handler.go
@ui/src/pages/IntegrationsPage.tsx
@ui/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SyncStatus to Integration API Types</name>
  <files>internal/integration/types.go</files>
  <action>
Extend IntegrationStatus struct to include sync status information.

Add to IntegrationStatus struct:
```go
type IntegrationStatus struct {
    // ... existing fields (Name, Type, Enabled, Health)

    SyncStatus *SyncStatus `json:"syncStatus,omitempty"` // Optional, only for integrations that sync
}

type SyncStatus struct {
    LastSyncTime   *time.Time `json:"lastSyncTime,omitempty"`   // Nil if never synced
    DashboardCount int        `json:"dashboardCount"`           // Total dashboards synced
    LastError      string     `json:"lastError,omitempty"`      // Empty if no error
    InProgress     bool       `json:"inProgress"`               // True during active sync
}
```

Follow existing types.go patterns (json tags, omitempty for optional fields, pointer for nullable time).
  </action>
  <verify>
go build ./internal/integration/...
# Verify types compile and follow existing patterns
  </verify>
  <done>
SyncStatus struct exists in types.go with LastSyncTime, DashboardCount, LastError, InProgress fields. IntegrationStatus includes optional SyncStatus field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expose Sync Status and Manual Sync in Grafana Integration</name>
  <files>internal/integration/grafana/grafana.go, internal/integration/grafana/dashboard_syncer.go</files>
  <action>
Add methods to Grafana integration for sync status and manual triggering.

Modifications to dashboard_syncer.go:

1. Add inProgress flag to DashboardSyncer:
```go
type DashboardSyncer struct {
    // ... existing fields
    inProgress    bool // Protected by mu
}
```

2. Update syncAll to set inProgress flag:
```go
func (s *DashboardSyncer) syncAll(ctx context.Context) error {
    s.mu.Lock()
    s.inProgress = true
    s.mu.Unlock()

    defer func() {
        s.mu.Lock()
        s.inProgress = false
        s.mu.Unlock()
    }()

    // ... existing sync logic
}
```

3. Add GetSyncStatus method:
```go
func (s *DashboardSyncer) GetSyncStatus() *integration.SyncStatus {
    s.mu.RLock()
    defer s.mu.RUnlock()

    status := &integration.SyncStatus{
        DashboardCount: s.dashboardCount,
        InProgress:     s.inProgress,
    }

    if !s.lastSyncTime.IsZero() {
        status.LastSyncTime = &s.lastSyncTime
    }

    if s.lastError != nil {
        status.LastError = s.lastError.Error()
    }

    return status
}
```

4. Add TriggerSync method for manual sync:
```go
func (s *DashboardSyncer) TriggerSync(ctx context.Context) error {
    s.mu.RLock()
    if s.inProgress {
        s.mu.RUnlock()
        return fmt.Errorf("sync already in progress")
    }
    s.mu.RUnlock()

    return s.syncAll(ctx)
}
```

Modifications to grafana.go:

Add methods to GrafanaIntegration:
```go
func (g *GrafanaIntegration) GetSyncStatus() *integration.SyncStatus {
    if g.syncer == nil {
        return nil
    }
    return g.syncer.GetSyncStatus()
}

func (g *GrafanaIntegration) TriggerSync(ctx context.Context) error {
    if g.syncer == nil {
        return fmt.Errorf("syncer not initialized")
    }
    return g.syncer.TriggerSync(ctx)
}
```

Update Status() method to include sync status:
```go
func (g *GrafanaIntegration) Status() integration.IntegrationStatus {
    status := integration.IntegrationStatus{
        // ... existing fields
        SyncStatus: g.GetSyncStatus(),
    }
    return status
}
```

Thread-safety: All access to DashboardSyncer fields protected by mutex.
  </action>
  <verify>
go test -v ./internal/integration/grafana -run TestGetSyncStatus
go test -v ./internal/integration/grafana -run TestTriggerSync
go build ./internal/integration/grafana/...
  </verify>
  <done>
GrafanaIntegration exposes GetSyncStatus and TriggerSync methods. DashboardSyncer tracks inProgress state. Status() method includes SyncStatus in response. Thread-safe access via mutex.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Manual Sync API Endpoint</name>
  <files>internal/api/integration_handler.go</files>
  <action>
Add POST endpoint for triggering manual sync on Grafana integrations.

Implementation in integration_handler.go:

1. Add route in RegisterRoutes (or equivalent handler registration):
```go
router.HandleFunc("/api/v1/integrations/{name}/sync", handleSyncIntegration).Methods("POST")
```

2. Implement handleSyncIntegration:
```go
func (h *IntegrationHandler) handleSyncIntegration(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    name := vars["name"]

    // Get integration from manager
    integration, err := h.manager.GetIntegration(name)
    if err != nil {
        http.Error(w, fmt.Sprintf("integration not found: %v", err), http.StatusNotFound)
        return
    }

    // Type assertion to Grafana integration
    grafanaIntegration, ok := integration.(*grafana.GrafanaIntegration)
    if !ok {
        http.Error(w, "sync only supported for Grafana integrations", http.StatusBadRequest)
        return
    }

    // Trigger sync
    ctx := r.Context()
    if err := grafanaIntegration.TriggerSync(ctx); err != nil {
        if err.Error() == "sync already in progress" {
            http.Error(w, err.Error(), http.StatusConflict)
            return
        }
        http.Error(w, fmt.Sprintf("sync failed: %v", err), http.StatusInternalServerError)
        return
    }

    // Return updated status
    status := grafanaIntegration.Status()
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(status)
}
```

3. Error handling:
   - 404 if integration not found
   - 400 if integration is not Grafana type
   - 409 if sync already in progress
   - 500 if sync fails
   - 200 with IntegrationStatus on success

Follow existing handler patterns in integration_handler.go (error responses, JSON encoding).
  </action>
  <verify>
go build ./internal/api/...
# Manual test: curl -X POST http://localhost:8080/api/v1/integrations/my-grafana/sync
# Verify 200 response with updated sync status
  </verify>
  <done>
POST /api/v1/integrations/{name}/sync endpoint exists and triggers manual sync. Returns 409 if sync in progress, 200 with updated status on success. Follows existing API handler patterns.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Sync Status Display and Manual Sync Button to UI</name>
  <files>ui/src/pages/IntegrationsPage.tsx, ui/src/types.ts</files>
  <action>
Add sync status column and manual sync button to integrations table.

Modifications to ui/src/types.ts:

Add SyncStatus interface:
```typescript
export interface SyncStatus {
  lastSyncTime?: string;      // ISO timestamp
  dashboardCount: number;
  lastError?: string;
  inProgress: boolean;
}

export interface IntegrationStatus {
  // ... existing fields
  syncStatus?: SyncStatus;
}
```

Modifications to ui/src/pages/IntegrationsPage.tsx:

1. Add sync state management:
```typescript
const [syncingIntegrations, setSyncingIntegrations] = useState<Set<string>>(new Set());
```

2. Implement syncIntegration function:
```typescript
const syncIntegration = async (name: string) => {
  setSyncingIntegrations(prev => new Set(prev).add(name));

  try {
    const response = await fetch(`/api/v1/integrations/${name}/sync`, {
      method: 'POST',
    });

    if (!response.ok) {
      if (response.status === 409) {
        toast.error('Sync already in progress');
      } else {
        const error = await response.text();
        toast.error('Sync failed', error);
      }
      return;
    }

    // Refresh integrations list to show updated status
    await loadIntegrations();
    toast.success('Dashboard sync completed');

  } catch (error) {
    toast.apiError(error, 'Syncing dashboards');
  } finally {
    setSyncingIntegrations(prev => {
      const next = new Set(prev);
      next.delete(name);
      return next;
    });
  }
};
```

3. Add sync status column to table (after health column):
```tsx
<td>
  {integration.syncStatus ? (
    <div className="text-sm">
      {integration.syncStatus.lastSyncTime ? (
        <>
          <div>{formatDistanceToNow(new Date(integration.syncStatus.lastSyncTime))} ago</div>
          <div className="text-gray-500">{integration.syncStatus.dashboardCount} dashboards</div>
          {integration.syncStatus.lastError && (
            <div className="text-red-600 text-xs">{integration.syncStatus.lastError}</div>
          )}
        </>
      ) : (
        <span className="text-gray-500">Never synced</span>
      )}
    </div>
  ) : (
    <span className="text-gray-400">—</span>
  )}
</td>
```

4. Add sync button to actions column (for Grafana integrations only):
```tsx
{integration.type === 'grafana' && (
  <button
    onClick={() => syncIntegration(integration.name)}
    disabled={syncingIntegrations.has(integration.name) || integration.syncStatus?.inProgress}
    className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
  >
    {syncingIntegrations.has(integration.name) || integration.syncStatus?.inProgress ? (
      <>
        <span className="animate-spin inline-block mr-1">⟳</span>
        Syncing...
      </>
    ) : (
      'Sync Now'
    )}
  </button>
)}
```

5. Import formatDistanceToNow from date-fns:
```typescript
import { formatDistanceToNow } from 'date-fns';
```

6. Add "Sync Status" header to table headers array.

Follow existing IntegrationsPage patterns for table columns, buttons, and toast notifications.

Reference 16-CONTEXT.md UI Feedback decisions for status display requirements.
  </action>
  <verify>
npm run build
# Manual test: Navigate to /integrations, verify sync status column and sync button visible
# Click sync button, verify loading state and status updates
  </verify>
  <done>
IntegrationsPage displays sync status (last sync time, dashboard count, errors) for Grafana integrations. Manual sync button triggers sync and shows loading state. Status updates after sync completes. Error handling with toast notifications.
  </done>
</task>

</tasks>

<verification>
Manual verification:
1. Navigate to /integrations page
2. See sync status column with "Never synced" for new integration
3. Click "Sync Now" button
4. Button shows "Syncing..." with spinner during active sync
5. After completion, sync status shows "X seconds ago" and dashboard count
6. If error occurs, error message displayed in red text
7. Clicking sync during active sync shows "Sync already in progress" toast

Automated checks:
- UI builds: npm run build
- Backend compiles: go build ./internal/api/... ./internal/integration/...
- Types match: TypeScript types align with Go types
</verification>

<success_criteria>
Requirements satisfied:
- UICF-05: UI displays sync status and last sync time

Observable outcomes:
- Sync status visible in integrations table (last sync time, dashboard count)
- Manual sync button triggers sync and shows loading state
- Sync errors displayed to user with details
- Concurrent sync prevented with 409 status
- Status updates automatically after sync completion
</success_criteria>

<output>
After completion, create `.planning/phases/16-ingestion-pipeline/16-03-SUMMARY.md`
</output>
