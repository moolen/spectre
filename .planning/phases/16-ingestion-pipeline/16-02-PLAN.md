---
phase: 16-ingestion-pipeline
plan: 02
type: execute
wave: 2
depends_on: [16-01]
files_modified:
  - internal/integration/grafana/dashboard_syncer.go
  - internal/integration/grafana/dashboard_syncer_test.go
  - internal/integration/grafana/graph_builder.go
  - internal/integration/grafana/graph_builder_test.go
  - internal/graph/models.go
  - internal/integration/grafana/grafana.go
autonomous: true

must_haves:
  truths:
    - "Changed dashboards are detected via version field comparison"
    - "Dashboard sync creates Panel, Query, Metric nodes in graph"
    - "Relationships (CONTAINS, HAS, USES) connect Dashboard->Panel->Query->Metric"
    - "Sync runs on startup and hourly thereafter"
    - "Full dashboard replace on update (delete old panels/queries, recreate)"
    - "Metric nodes are preserved when dashboard deleted (shared across dashboards)"
  artifacts:
    - path: "internal/integration/grafana/dashboard_syncer.go"
      provides: "Incremental sync orchestrator with version comparison"
      exports: ["DashboardSyncer", "Start", "Stop"]
      min_lines: 200
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "Graph node and edge creation logic"
      exports: ["CreateDashboardGraph", "DeletePanelsForDashboard"]
      min_lines: 150
    - path: "internal/graph/models.go"
      provides: "Panel, Query, Metric node types"
      contains: "NodeTypePanel"
  key_links:
    - from: "internal/integration/grafana/dashboard_syncer.go"
      to: "internal/integration/grafana/promql_parser.go"
      via: "ExtractFromPromQL call in syncDashboard"
      pattern: "ExtractFromPromQL\\("
    - from: "internal/integration/grafana/graph_builder.go"
      to: "internal/graph/client.go"
      via: "graph.Client interface for Cypher queries"
      pattern: "graph\\.Client"
    - from: "internal/integration/grafana/grafana.go"
      to: "internal/integration/grafana/dashboard_syncer.go"
      via: "Start/Stop lifecycle calls"
      pattern: "syncer\\.(Start|Stop)"
---

<objective>
Implement incremental dashboard synchronization with version-based change detection and full semantic graph storage (Dashboard->Panel->Query->Metric relationships).

Purpose: Build comprehensive knowledge graph from Grafana dashboards to enable service inference (Phase 17) and query execution (Phase 18). Incremental sync minimizes API calls and graph operations.

Output: Production-ready dashboard syncer with periodic sync loop, graceful error handling, and graph builder creating nodes/edges in FalkorDB.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-ingestion-pipeline/16-CONTEXT.md
@.planning/phases/16-ingestion-pipeline/16-RESEARCH.md
@.planning/phases/16-ingestion-pipeline/16-01-SUMMARY.md
@internal/integration/grafana/types.go
@internal/integration/grafana/client.go
@internal/integration/grafana/grafana.go
@internal/integration/grafana/promql_parser.go
@internal/graph/models.go
@internal/graph/client.go
@internal/config/integration_watcher.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Panel, Query, Metric Node Types to Graph Models</name>
  <files>internal/graph/models.go</files>
  <action>
Extend graph models with new node types for dashboard semantic structure.

Add to NodeType enum:
- NodeTypePanel NodeType = "Panel"
- NodeTypeQuery NodeType = "Query"
- NodeTypeMetric NodeType = "Metric"

Add to EdgeType enum:
- EdgeTypeContains EdgeType = "CONTAINS" // Dashboard -> Panel
- EdgeTypeHas EdgeType = "HAS"           // Panel -> Query
- EdgeTypeUses EdgeType = "USES"         // Query -> Metric

Add node structs (following existing DashboardNode pattern):

```go
type PanelNode struct {
    ID           string `json:"id"`           // Unique: dashboardUID + panelID
    DashboardUID string `json:"dashboardUID"` // Parent dashboard
    Title        string `json:"title"`
    Type         string `json:"type"`         // Panel type (graph, table, etc.)
    GridPosX     int    `json:"gridPosX"`     // Layout position
    GridPosY     int    `json:"gridPosY"`
}

type QueryNode struct {
    ID             string            `json:"id"`             // Unique: dashboardUID + panelID + refID
    RefID          string            `json:"refId"`          // Query reference (A, B, C, etc.)
    RawPromQL      string            `json:"rawPromQL"`      // Original PromQL
    DatasourceUID  string            `json:"datasourceUID"`
    Aggregations   []string          `json:"aggregations"`   // Extracted functions
    LabelSelectors map[string]string `json:"labelSelectors"` // Extracted matchers
    HasVariables   bool              `json:"hasVariables"`   // Contains Grafana variables
}

type MetricNode struct {
    Name      string `json:"name"`      // Metric name (e.g., http_requests_total)
    FirstSeen int64  `json:"firstSeen"` // Unix nano timestamp
    LastSeen  int64  `json:"lastSeen"`  // Unix nano timestamp
}
```

Follow existing node struct patterns (json tags, simple types).
  </action>
  <verify>
go build ./internal/graph/...
# Verify models compile and follow existing patterns
  </verify>
  <done>
NodeTypePanel, NodeTypeQuery, NodeTypeMetric exist in models.go. EdgeTypeContains, EdgeTypeHas, EdgeTypeUses exist. PanelNode, QueryNode, MetricNode structs defined with proper json tags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Graph Builder for Dashboard Structure</name>
  <files>internal/integration/grafana/graph_builder.go, internal/integration/grafana/graph_builder_test.go</files>
  <action>
Create graph builder that transforms Grafana dashboard JSON into FalkorDB nodes and edges.

Implementation in graph_builder.go:

1. Define GraphBuilder struct:
```go
type GraphBuilder struct {
    graphClient graph.Client
    parser      *PromQLParser // Use ExtractFromPromQL
    logger      *logging.Logger
}
```

2. Implement CreateDashboardGraph(ctx context.Context, dashboard *GrafanaDashboard) error:
   - Update Dashboard node (MERGE with version, lastSeen)
   - Store variables as JSON property on Dashboard node
   - For each panel in dashboard.Panels:
     * Create Panel node with MERGE (id = dashboardUID + panelID)
     * Create CONTAINS edge: Dashboard -> Panel
     * For each target in panel.Targets:
       - Create Query node with MERGE (id = dashboardUID + panelID + refID)
       - Store raw PromQL in rawPromQL field
       - Call ExtractFromPromQL to get extraction
       - Store aggregations and labelSelectors from extraction
       - Create HAS edge: Panel -> Query
       - For each metricName in extraction.MetricNames:
         * Skip if extraction.HasVariables (don't create Metric node for variable-containing names)
         * Create Metric node with MERGE (only on name field - upsert semantics)
         * Set lastSeen = now, firstSeen only on CREATE
         * Create USES edge: Query -> Metric

3. Implement DeletePanelsForDashboard(ctx context.Context, dashboardUID string) error:
   - Cypher query:
     ```cypher
     MATCH (d:Dashboard {uid: $uid})-[:CONTAINS]->(p:Panel)
     OPTIONAL MATCH (p)-[:HAS]->(q:Query)
     DETACH DELETE p, q
     ```
   - Do NOT delete Metric nodes (shared across dashboards - see Pitfall 4 in research)

4. Error handling:
   - Log parse errors but continue: "Failed to parse PromQL for query %s: %v" - skip that query, continue with others
   - Wrap graph client errors: "failed to create panel node: %w"

Tests in graph_builder_test.go:
- TestCreateDashboardGraph_SimplePanel - single panel, single query
- TestCreateDashboardGraph_MultipleQueries - panel with multiple targets
- TestCreateDashboardGraph_VariableInMetric - skip Metric node when HasVariables=true
- TestDeletePanelsForDashboard - verify panels/queries deleted, metrics preserved

Use mock graph.Client interface for testing (follow existing graph client test patterns).

Reference 16-RESEARCH.md Pattern 3 (Graph Schema) and Pattern 4 (Variable Handling).
  </action>
  <verify>
go test -v ./internal/integration/grafana -run TestGraphBuilder
go build ./internal/integration/grafana/...
  </verify>
  <done>
GraphBuilder successfully creates Dashboard/Panel/Query/Metric nodes with CONTAINS/HAS/USES edges. DeletePanelsForDashboard removes panels/queries but preserves metrics. Tests verify variable handling and multi-query panels.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Dashboard Syncer with Version-Based Change Detection</name>
  <files>internal/integration/grafana/dashboard_syncer.go, internal/integration/grafana/dashboard_syncer_test.go</files>
  <action>
Create dashboard syncer orchestrator with incremental sync and periodic loop.

Implementation in dashboard_syncer.go:

1. Define DashboardSyncer struct:
```go
type DashboardSyncer struct {
    grafanaClient *GrafanaClient
    graphClient   graph.Client
    graphBuilder  *GraphBuilder
    logger        *logging.Logger

    syncInterval  time.Duration
    cancel        context.CancelFunc
    stopped       chan struct{}

    mu            sync.RWMutex
    lastSyncTime  time.Time
    dashboardCount int
    lastError     error
}
```

2. Implement Start(ctx context.Context) error:
   - Create cancellable context
   - Run initial sync: syncAll(ctx)
   - Start background goroutine: syncLoop(ctx)
   - Reference 16-RESEARCH.md Pattern 5 (Periodic Sync)

3. Implement syncLoop(ctx context.Context):
   - Ticker with syncInterval (1 hour)
   - Select on ctx.Done() and ticker.C
   - Call syncAll(ctx) on each tick
   - Log errors but don't crash

4. Implement syncAll(ctx context.Context) error:
   - Call grafanaClient.SearchDashboards(ctx) to get list
   - Update lastSyncTime, dashboardCount
   - For each dashboard in list:
     * Log progress: "Syncing dashboard %d of %d: %s"
     * Check needsSync(dashboard) - compare version with cached version
     * If needs sync:
       - Call grafanaClient.GetDashboard(ctx, uid) for full details
       - Call syncDashboard(ctx, full)
     * Log errors but continue (don't fail entire sync for one dashboard)

5. Implement needsSync(dashboard SearchDashboard) bool:
   - Query graph for existing Dashboard node with uid
   - Compare version field
   - Return true if: node doesn't exist OR dashboard.Version > node.Version

6. Implement syncDashboard(ctx context.Context, dashboard *GrafanaDashboard) error:
   - Call graphBuilder.DeletePanelsForDashboard(dashboard.UID) - full replace pattern
   - Call graphBuilder.CreateDashboardGraph(dashboard)

7. Implement Stop():
   - Call cancel()
   - Wait on stopped channel with timeout

8. Thread-safe getters for UI (used in Plan 3):
   - GetSyncStatus() (lastSyncTime, dashboardCount, lastError)

Tests in dashboard_syncer_test.go:
- TestSyncAll_NewDashboards - creates new dashboard nodes
- TestSyncAll_UpdatedDashboard - detects version change and re-syncs
- TestSyncAll_UnchangedDashboard - skips sync when version matches
- TestSyncAll_ContinuesOnError - handles parse errors in one dashboard, continues with others

Use mock clients for testing.

Reference 16-RESEARCH.md Pattern 1 (Incremental Sync) and Pattern 5 (Periodic Sync).
  </action>
  <verify>
go test -v ./internal/integration/grafana -run TestDashboardSyncer
go build ./internal/integration/grafana/...
  </verify>
  <done>
DashboardSyncer starts periodic sync loop, detects changes via version comparison, handles errors gracefully, and provides sync status for UI. Tests verify incremental sync and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate Dashboard Syncer into Grafana Integration Lifecycle</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
Wire DashboardSyncer into Grafana integration Start/Stop lifecycle.

Modifications to grafana.go:

1. Add syncer field to GrafanaIntegration:
```go
type GrafanaIntegration struct {
    // ... existing fields
    syncer *DashboardSyncer
}
```

2. In Start() method:
   - After secretWatcher.Start(), create DashboardSyncer:
     ```go
     g.syncer = NewDashboardSyncer(
         g.client,
         graphClient, // Passed from integration manager
         time.Hour,   // Sync interval
         g.logger,
     )
     if err := g.syncer.Start(ctx); err != nil {
         return fmt.Errorf("failed to start dashboard syncer: %w", err)
     }
     ```

3. In Stop() method:
   - Add g.syncer.Stop() before secretWatcher.Stop()

4. Pass graph.Client to integration:
   - Check integration factory signature - may need to add graphClient parameter
   - Follow existing integration patterns (check VictoriaLogs integration)

5. Health check update:
   - Existing health check tests API connectivity
   - Add sync status check (optional, warn if last sync failed)

Reference existing VictoriaLogs integration lifecycle pattern for consistency.
  </action>
  <verify>
go build ./internal/integration/grafana/...
go test -v ./internal/integration/grafana -run TestGrafanaIntegration
# Verify integration starts syncer and stops cleanly
  </verify>
  <done>
Grafana integration starts DashboardSyncer in Start(), stops in Stop(). Syncer runs initial sync and periodic hourly sync. Integration compiles and lifecycle tests pass.
  </done>
</task>

</tasks>

<verification>
Manual verification:
1. Dashboard nodes updated with version and lastSeen fields
2. Panel, Query, Metric nodes created in graph with correct relationships
3. Incremental sync detects version changes and skips unchanged dashboards
4. Periodic sync loop runs hourly without blocking
5. Parse errors logged but don't crash entire sync
6. Full dashboard replace deletes old panels/queries, preserves metrics

Automated checks:
- All tests pass: go test ./internal/integration/grafana/...
- Integration compiles: go build ./internal/integration/grafana/...
- Graph models compile: go build ./internal/graph/...
</verification>

<success_criteria>
Requirements satisfied:
- FOUN-04: Incremental sync detects changed dashboards via version field
- GRPH-02: Panel nodes created with title, type, grid position
- GRPH-03: Query nodes created with raw PromQL, datasource UID
- GRPH-04: Metric nodes created with name, firstSeen, lastSeen
- GRPH-06: Relationships Dashboard CONTAINS Panel, Panel HAS Query, Query USES Metric

Observable outcomes:
- DashboardSyncer runs periodic sync (startup + hourly)
- Version comparison skips unchanged dashboards (incremental sync)
- Graph contains Dashboard->Panel->Query->Metric structure
- Metric nodes preserved when dashboard deleted (shared entities)
- Parse errors logged and skipped (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/16-ingestion-pipeline/16-02-SUMMARY.md`
</output>
