---
phase: 16-ingestion-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/promql_parser.go
  - internal/integration/grafana/promql_parser_test.go
autonomous: true

must_haves:
  truths:
    - "PromQL queries are parsed to extract metric names"
    - "Label selectors are extracted from PromQL queries"
    - "Aggregation functions are extracted from PromQL queries"
    - "Variable syntax ($var, ${var}, [[var]]) is preserved as-is"
    - "Unparseable queries log warning and continue (no crashes)"
  artifacts:
    - path: "internal/integration/grafana/promql_parser.go"
      provides: "PromQL AST traversal and extraction logic"
      exports: ["ExtractFromPromQL", "QueryExtraction"]
      min_lines: 100
    - path: "internal/integration/grafana/promql_parser_test.go"
      provides: "Test coverage for parser edge cases"
      min_lines: 150
  key_links:
    - from: "internal/integration/grafana/promql_parser.go"
      to: "github.com/prometheus/prometheus/promql/parser"
      via: "parser.ParseExpr and parser.Inspect"
      pattern: "parser\\.(ParseExpr|Inspect)"
---

<objective>
Implement PromQL parser using official Prometheus library to extract semantic components (metric names, label selectors, aggregations) from Grafana dashboard queries.

Purpose: Enable downstream graph building by extracting structured data from PromQL expressions. Full semantic extraction is critical for service inference (Phase 17) and query execution (Phase 18).

Output: Production-ready PromQL parser with comprehensive test coverage for edge cases (variables, nested aggregations, empty metric names).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-ingestion-pipeline/16-CONTEXT.md
@.planning/phases/16-ingestion-pipeline/16-RESEARCH.md
@internal/integration/grafana/types.go
@internal/integration/grafana/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PromQL Parser with AST Extraction</name>
  <files>internal/integration/grafana/promql_parser.go</files>
  <action>
Create PromQL parser package using github.com/prometheus/prometheus/promql/parser library for AST-based extraction.

Implementation requirements:
1. Define QueryExtraction struct with fields:
   - MetricNames []string - extracted from VectorSelector nodes
   - LabelSelectors map[string]string - key-value pairs from LabelMatchers
   - Aggregations []string - function names from AggregateExpr and Call nodes
   - HasVariables bool - flag indicating presence of Grafana variables

2. Implement ExtractFromPromQL(queryStr string) (*QueryExtraction, error):
   - Call parser.ParseExpr(queryStr) to get AST
   - Use parser.Inspect() to walk AST in depth-first order
   - Extract VectorSelector nodes:
     * Check if vs.Name != "" before adding to MetricNames (handle label-only selectors)
     * Detect variable syntax patterns ($var, ${var}, [[var]]) in metric name
     * Set HasVariables=true if patterns found, skip creating Metric node for this
   - Extract LabelMatchers from VectorSelector:
     * Convert to map[string]string (label name -> matcher value)
     * Handle equality matchers only (=~, != are passthrough for now)
   - Extract AggregateExpr nodes -> aggregations (sum, avg, min, max, count, etc.)
   - Extract Call nodes -> aggregations (rate, increase, irate, delta, etc.)
   - Return error if parser.ParseExpr fails, wrap with context

3. Variable syntax detection:
   - Regex patterns: `\$\w+`, `\$\{\w+\}`, `\$\{\w+:\w+\}`, `\[\[\w+\]\]`
   - Function hasVariableSyntax(str string) bool for reusability

4. Error handling:
   - Graceful parsing: if parser.ParseExpr fails, return nil extraction with error
   - Log context: "failed to parse PromQL: %w" with original query string
   - Don't panic on malformed queries

Reference patterns from 16-RESEARCH.md Pattern 2 (PromQL AST Traversal) and Pattern 4 (Variable Handling).

Use prometheus/prometheus/promql/parser (NOT custom regex parsing - see "Don't Hand-Roll" section in research).
  </action>
  <verify>
go build ./internal/integration/grafana/...
go test -v ./internal/integration/grafana -run TestExtractFromPromQL
  </verify>
  <done>
ExtractFromPromQL successfully extracts metrics, labels, and aggregations from valid PromQL queries. Variable syntax is detected and flagged. Parse errors return non-nil error with context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Comprehensive Parser Tests</name>
  <files>internal/integration/grafana/promql_parser_test.go</files>
  <action>
Create comprehensive test suite covering edge cases identified in 16-RESEARCH.md Common Pitfalls.

Test cases:
1. TestExtractFromPromQL_SimpleMetric - `http_requests_total`
   - Expected: MetricNames=["http_requests_total"], Aggregations=[], HasVariables=false

2. TestExtractFromPromQL_WithAggregation - `sum(rate(http_requests_total[5m])) by (status)`
   - Expected: MetricNames=["http_requests_total"], Aggregations=["sum", "rate"]

3. TestExtractFromPromQL_WithLabelSelectors - `http_requests_total{job="api", handler="/health"}`
   - Expected: LabelSelectors={"job": "api", "handler": "/health"}

4. TestExtractFromPromQL_LabelOnlySelector - `{job="api", handler="/health"}`
   - Expected: MetricNames=[], LabelSelectors={"job": "api", "handler": "/health"}
   - Tests Pitfall 1: VectorSelector without metric name

5. TestExtractFromPromQL_VariableSyntax - Test all 4 patterns:
   - `http_requests_$service_total` -> HasVariables=true
   - `http_requests_${service}_total` -> HasVariables=true
   - `http_requests_${service:csv}_total` -> HasVariables=true
   - `http_requests_[[service]]_total` -> HasVariables=true (deprecated syntax)

6. TestExtractFromPromQL_NestedAggregations - `avg(sum(rate(metric[5m])) by (label))`
   - Expected: Aggregations=["avg", "sum", "rate"] (order may vary based on traversal)

7. TestExtractFromPromQL_InvalidQuery - Malformed PromQL
   - Expected: error returned, extraction=nil
   - Tests Pitfall 2: graceful error handling

8. TestExtractFromPromQL_EmptyQuery - Empty string
   - Expected: error returned

9. TestExtractFromPromQL_ComplexQuery - Real-world Grafana query with multiple metrics
   - Example: `(sum(container_memory_usage_bytes{namespace="$namespace"}) / sum(container_spec_memory_limit_bytes{namespace="$namespace"})) * 100`
   - Tests multiple VectorSelectors in binary expression

Use table-driven tests where appropriate to reduce duplication.
  </action>
  <verify>
go test -v ./internal/integration/grafana -run TestExtractFromPromQL
go test -cover ./internal/integration/grafana
# Verify coverage > 80%
  </verify>
  <done>
All parser tests pass with >80% coverage. Edge cases from research pitfalls are covered (empty metric names, variables, parse errors, complex nested queries).
  </done>
</task>

</tasks>

<verification>
Manual verification:
1. Parser extracts metrics from simple queries: `http_requests_total`
2. Parser extracts aggregations from nested queries: `sum(rate(...))`
3. Parser detects variables and sets HasVariables flag
4. Parser returns error for malformed PromQL without crashing
5. Tests cover all edge cases from 16-RESEARCH.md Common Pitfalls

Automated checks:
- go test passes all parser tests
- go build compiles without errors
- Test coverage >80%
</verification>

<success_criteria>
Requirements satisfied:
- PROM-01: Uses prometheus/prometheus/promql/parser library
- PROM-02: Extracts metric names from VectorSelector nodes
- PROM-03: Extracts label selectors from LabelMatchers
- PROM-04: Extracts aggregation functions from AggregateExpr and Call
- PROM-05: Handles variable syntax as passthrough (detects, doesn't interpolate)
- PROM-06: Best-effort extraction with graceful error handling

Observable outcomes:
- ExtractFromPromQL function exists and works for valid PromQL
- Variable syntax patterns are detected correctly
- Unparseable queries return error without panic
- Test coverage demonstrates edge case handling
</success_criteria>

<output>
After completion, create `.planning/phases/16-ingestion-pipeline/16-01-SUMMARY.md`
</output>
