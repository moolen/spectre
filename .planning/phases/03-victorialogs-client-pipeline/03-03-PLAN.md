---
phase: 03-victorialogs-client-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - internal/integration/victorialogs/victorialogs.go
autonomous: false

must_haves:
  truths:
    - "VictoriaLogsIntegration creates HTTP client on Start()"
    - "Integration initializes pipeline with metrics"
    - "Integration health check uses client connectivity"
    - "Integration registers query tools (placeholder for Phase 5)"
    - "Integration properly shuts down client and pipeline on Stop()"
  artifacts:
    - path: "internal/integration/victorialogs/victorialogs.go"
      provides: "Complete VictoriaLogs integration implementation"
      exports: ["VictoriaLogsIntegration", "NewVictoriaLogsIntegration"]
      contains: "NewClient.*NewPipeline.*NewMetrics"
  key_links:
    - from: "internal/integration/victorialogs/victorialogs.go"
      to: "internal/integration/victorialogs/client.go"
      via: "Integration creates Client in Start()"
      pattern: "NewClient\\(v\\.url"
    - from: "internal/integration/victorialogs/victorialogs.go"
      to: "internal/integration/victorialogs/pipeline.go"
      via: "Integration creates Pipeline in Start()"
      pattern: "NewPipeline\\(.*client"
    - from: "internal/integration/victorialogs/victorialogs.go"
      to: "internal/integration/victorialogs/metrics.go"
      via: "Integration creates Metrics in Start()"
      pattern: "NewMetrics\\(.*instanceName"
---

<objective>
Wire VictoriaLogs client and pipeline into integration interface, replacing placeholder implementation.

Purpose: Complete the VictoriaLogs integration by initializing client, metrics, and pipeline in Start(), using client for health checks, and ensuring proper shutdown. This makes the integration production-ready for log querying and ingestion.

Output: Fully functional VictoriaLogs integration that connects to instance, executes queries, handles backpressure, and exposes Prometheus metrics.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-RESEARCH.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-01-SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-02-SUMMARY.md
@/home/moritz/dev/spectre-via-ssh/internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire client and pipeline into integration</name>
  <files>
internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Update victorialogs.go to replace placeholder implementation with full client and pipeline wiring:

Update VictoriaLogsIntegration struct:
- Remove: client *http.Client, healthy bool
- Add: client *Client (VictoriaLogs HTTP client from client.go)
- Add: pipeline *Pipeline (backpressure pipeline from pipeline.go)
- Add: metrics *Metrics (Prometheus metrics from metrics.go)
- Keep: name string, url string, logger *logging.Logger

Update NewVictoriaLogsIntegration:
- Remove http.Client creation
- Keep url validation
- Return &VictoriaLogsIntegration with name, url, logger, client=nil, pipeline=nil, metrics=nil
- Note: client/pipeline/metrics created in Start() to avoid premature initialization

Update Start(ctx context.Context) error:
- Log "Starting VictoriaLogs integration: {name} (url: {url})"
- Create Prometheus metrics: v.metrics = NewMetrics(prometheus.DefaultRegisterer, v.name)
- Create HTTP client: v.client = NewClient(v.url, 30*time.Second)
- Create pipeline: v.pipeline = NewPipeline(v.client, v.metrics, v.name)
- Start pipeline: if err := v.pipeline.Start(ctx); err != nil { return err }
- Test connectivity: if err := v.testConnection(ctx); err != nil { log warning but continue (degraded state) }
- Log "VictoriaLogs integration started successfully"
- Return nil

Update Stop(ctx context.Context) error:
- Log "Stopping VictoriaLogs integration: {name}"
- If v.pipeline != nil: call v.pipeline.Stop(ctx), log error if fails but continue
- Set v.client, v.pipeline, v.metrics to nil
- Log "VictoriaLogs integration stopped"
- Return nil

Update Health(ctx context.Context) HealthStatus:
- If v.client == nil: return integration.Stopped
- Test connectivity: if err := v.testConnection(ctx); err != nil { return integration.Degraded }
- Return integration.Healthy

Add testConnection(ctx context.Context) error (private method):
- Create test query params: DefaultTimeRange(), Limit: 1
- Call v.client.QueryLogs(ctx, params)
- If err != nil: return fmt.Errorf("connectivity test failed: %w", err)
- Return nil

Update RegisterTools(registry integration.ToolRegistry) error:
- Keep placeholder comment for Phase 5
- Add comment: "// Phase 3: Client and pipeline ready for MCP tool registration"
- Add comment: "// Tools to be added in Phase 5: victorialogs_overview, victorialogs_patterns, victorialogs_logs"
- Return nil

Remove checkHealth method (replaced by testConnection)

IMPORTANT:
- Don't create client/pipeline in constructor - wait for Start() (lifecycle pattern)
- Test connectivity in Start() but continue even if it fails (degraded state, auto-recovery)
- Gracefully handle nil client/pipeline in Health() and Stop()
- Use prometheus.DefaultRegisterer (global registry) for metrics
- 30-second query timeout per requirements (pass to NewClient)
  </action>
  <verify>
go build ./internal/integration/victorialogs/... succeeds
go build ./cmd/spectre/... succeeds (server includes victorialogs integration)
grep -r "NewClient.*30.*time.Second" internal/integration/victorialogs/victorialogs.go confirms 30s timeout
grep -r "NewPipeline.*client.*metrics" internal/integration/victorialogs/victorialogs.go confirms wiring
grep -r "pipeline.Start\|pipeline.Stop" internal/integration/victorialogs/victorialogs.go confirms lifecycle
  </verify>
  <done>
VictoriaLogsIntegration uses Client, Pipeline, Metrics (not raw http.Client)
Start() initializes metrics, client, pipeline in correct order
Stop() gracefully shuts down pipeline with timeout
Health() uses client connectivity test (not placeholder)
RegisterTools has placeholder comment for Phase 5
Code compiles without errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete VictoriaLogs integration with HTTP client, LogsQL query builder, backpressure pipeline, and Prometheus metrics. Integration replaces placeholder implementation with production-ready components.
  </what-built>

  <how-to-verify>
Prerequisites:
- VictoriaLogs instance running locally or accessible URL
- Update integrations.yaml with VictoriaLogs URL (or use UI to configure)

Step 1: Build and start server
```bash
cd /home/moritz/dev/spectre-via-ssh
go build -o spectre ./cmd/spectre
./spectre server --integrations-config integrations.yaml
```
Expected: Server starts, VictoriaLogs integration initializes, logs show "VictoriaLogs integration started successfully"

Step 2: Check integration health via UI
- Open http://localhost:8080
- Navigate to Integrations page
- Find VictoriaLogs integration entry
Expected: Status shows "Healthy" (green) if VictoriaLogs reachable, "Degraded" (yellow) if unreachable

Step 3: Verify Prometheus metrics exposure
```bash
curl http://localhost:9090/metrics | grep victorialogs_pipeline
```
Expected: See three metrics:
- victorialogs_pipeline_queue_depth{instance="victorialogs-prod"} 0
- victorialogs_pipeline_logs_total{instance="victorialogs-prod"} 0
- victorialogs_pipeline_errors_total{instance="victorialogs-prod"} 0

Step 4: Test LogsQL query execution (VLOG-02 verification)
Add temporary test code in victorialogs.go Start() after pipeline start:
```go
// Test LogsQL query execution (VLOG-02 verification)
testParams := QueryParams{
    TimeRange: DefaultTimeRange(),
    Limit:     10,
}
logsResp, logsErr := v.client.QueryLogs(ctx, testParams)
v.logger.Info("Test LogsQL query: logs=%d, hasMore=%v, err=%v", logsResp.Count, logsResp.HasMore, logsErr)

// Verify query with namespace filter
nsTestParams := QueryParams{
    Namespace: "default",
    TimeRange: DefaultTimeRange(),
    Limit:     5,
}
nsResp, nsErr := v.client.QueryLogs(ctx, nsTestParams)
v.logger.Info("Test namespace filter query: logs=%d, err=%v", nsResp.Count, nsErr)
```
Rebuild and restart server.
Expected:
- Logs show "Test LogsQL query: logs=X, hasMore=false, err=<nil>" (X depends on logs in VictoriaLogs)
- Logs show "Test namespace filter query: logs=Y, err=<nil>"
- No LogsQL syntax errors in VictoriaLogs logs (verify valid query syntax)

Step 5: Test histogram queries (VLOG-05 verification)
Add test code after previous tests:
```go
// Test histogram query (VLOG-05 verification)
histParams := QueryParams{
    TimeRange: DefaultTimeRange(),
}
histResp, histErr := v.client.QueryHistogram(ctx, histParams, "5m")
v.logger.Info("Test histogram query: buckets=%d, err=%v", len(histResp.Buckets), histErr)
```
Rebuild and restart server.
Expected:
- Logs show "Test histogram query: buckets=X, err=<nil>"
- No errors from VictoriaLogs API

Step 6: Test aggregation queries (VLOG-06 verification)
Add test code after previous tests:
```go
// Test aggregation query (VLOG-06 verification)
aggParams := QueryParams{
    TimeRange: DefaultTimeRange(),
}
aggResp, aggErr := v.client.QueryAggregation(ctx, aggParams, []string{"namespace"})
v.logger.Info("Test aggregation query: groups=%d, err=%v", len(aggResp.Groups), aggErr)
```
Rebuild and restart server.
Expected:
- Logs show "Test aggregation query: groups=X, err=<nil>"
- Groups returned with namespace dimension and counts

Step 7: Verify connection pooling
```bash
# Check established connections to VictoriaLogs
netstat -an | grep <victorialogs-port> | grep ESTABLISHED | wc -l
```
Expected: Small number of connections (1-3), stable over time (connection reuse working)

Step 8: Verify graceful shutdown
```bash
# Start server, then Ctrl+C
./spectre server --integrations-config integrations.yaml
# Wait 2 seconds, then press Ctrl+C
```
Expected: Logs show "Stopping pipeline, draining buffer..." and "Pipeline stopped cleanly" (no timeout errors)

Verification complete when:
- Integration initializes successfully and shows correct health status
- Prometheus metrics exposed at /metrics endpoint
- LogsQL queries execute successfully with valid syntax (VLOG-02)
- Histogram queries return results without errors (VLOG-05)
- Aggregation queries return grouped results (VLOG-06)
- Connection pooling working (stable connection count)
- Graceful shutdown completes without timeout errors
  </how-to-verify>

  <resume-signal>
Type "approved" when verification passes, or describe any issues found for auto-fixing.
  </resume-signal>
</task>

</tasks>

<verification>
After Task 1 complete and before human verification:
- All files compile: go build ./internal/integration/victorialogs/...
- Server compiles: go build ./cmd/spectre/...
- Integration wires client, pipeline, metrics in Start()
- Integration properly shuts down in Stop()
- Health check uses client connectivity test
</verification>

<success_criteria>
1. VictoriaLogsIntegration creates client, pipeline, metrics in Start()
2. Integration tests connectivity on startup (degraded if unreachable)
3. Health() returns accurate status based on client connectivity
4. Stop() gracefully shuts down pipeline with timeout
5. Prometheus metrics exposed and updated by pipeline
6. LogsQL queries validated to execute successfully (VLOG-02)
7. Histogram queries tested and return results (VLOG-05)
8. Aggregation queries tested and return grouped results (VLOG-06)
9. Server starts successfully with VictoriaLogs integration enabled
</success_criteria>

<output>
After completion, create `.planning/phases/03-victorialogs-client-pipeline/03-03-SUMMARY.md`
</output>
