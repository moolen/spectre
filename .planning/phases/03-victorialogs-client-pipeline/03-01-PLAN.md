---
phase: 03-victorialogs-client-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/victorialogs/types.go
  - internal/integration/victorialogs/query.go
  - internal/integration/victorialogs/client.go
autonomous: true

must_haves:
  truths:
    - "VictoriaLogs client can connect to instance via HTTP"
    - "Client constructs LogsQL queries from structured parameters"
    - "Client executes queries against /select/logsql/query endpoint"
    - "Client parses JSON line responses into structured LogEntry slices"
    - "Client handles histogram and aggregation queries via dedicated endpoints"
  artifacts:
    - path: "internal/integration/victorialogs/types.go"
      provides: "Request/response types for VictoriaLogs API"
      exports: ["QueryParams", "TimeRange", "QueryResponse", "LogEntry", "HistogramResponse", "AggregationResponse"]
    - path: "internal/integration/victorialogs/query.go"
      provides: "LogsQL query builder from structured parameters"
      exports: ["BuildLogsQLQuery", "BuildHistogramQuery", "BuildAggregationQuery"]
    - path: "internal/integration/victorialogs/client.go"
      provides: "HTTP client wrapper for VictoriaLogs API"
      exports: ["Client", "NewClient", "QueryLogs", "QueryHistogram", "QueryAggregation"]
      min_lines: 100
  key_links:
    - from: "internal/integration/victorialogs/query.go"
      to: "internal/integration/victorialogs/types.go"
      via: "QueryParams struct used in all Build* functions"
      pattern: "func Build.*\\(params QueryParams\\)"
    - from: "internal/integration/victorialogs/client.go"
      to: "internal/integration/victorialogs/query.go"
      via: "Client calls Build* functions to construct LogsQL"
      pattern: "BuildLogsQLQuery\\(params\\)"
    - from: "internal/integration/victorialogs/client.go"
      to: "VictoriaLogs HTTP API"
      via: "POST requests to /select/logsql/* endpoints"
      pattern: "/select/logsql/(query|hits|stats_query)"
---

<objective>
Implement VictoriaLogs HTTP client with LogsQL query capabilities for log retrieval, histograms, and aggregations.

Purpose: Enable structured querying of VictoriaLogs instance with K8s-focused filters (namespace, pod, container, level) and time range constraints. This client forms the foundation for log ingestion pipeline and MCP tools.

Output: Production-ready HTTP client with connection pooling, timeout control, and proper response body handling. Supports three query types: raw logs, histograms, and aggregations.
</objective>

<execution_context>
@/home/moritz/.claude/get-shit-done/workflows/execute-plan.md
@/home/moritz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/moritz/dev/spectre-via-ssh/.planning/PROJECT.md
@/home/moritz/dev/spectre-via-ssh/.planning/ROADMAP.md
@/home/moritz/dev/spectre-via-ssh/.planning/STATE.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-CONTEXT.md
@/home/moritz/dev/spectre-via-ssh/.planning/phases/03-victorialogs-client-pipeline/03-RESEARCH.md
@/home/moritz/dev/spectre-via-ssh/internal/integration/types.go
@/home/moritz/dev/spectre-via-ssh/internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and LogsQL query builder</name>
  <files>
internal/integration/victorialogs/types.go
internal/integration/victorialogs/query.go
  </files>
  <action>
Create types.go with VictoriaLogs API request/response types:
- QueryParams struct: Namespace, Pod, Container, Level (all strings), TimeRange, Limit (int, max 1000)
- TimeRange struct: Start, End (time.Time), IsZero() method
- LogEntry struct: Message (_msg), Stream (_stream), Time (_time as time.Time), Namespace, Pod, Container, Level (all with json tags matching VictoriaLogs field names)
- QueryResponse struct: Logs ([]LogEntry), Count (int), HasMore (bool)
- HistogramResponse struct: Buckets ([]HistogramBucket with Timestamp time.Time and Count int)
- AggregationResponse struct: Groups ([]AggregationGroup with Dimension string, Value string, Count int)
- DefaultTimeRange() function: returns TimeRange with Start = now - 1 hour, End = now

Create query.go with structured LogsQL query builders:
- BuildLogsQLQuery(params QueryParams) string:
  - Build filters using := operator for exact matches (namespace:="prod", pod:="mypod-123")
  - Always include _time:[start, end] filter (use RFC3339 format for timestamps)
  - Default to "_time:[1h ago, now]" when TimeRange.IsZero()
  - Join filters with " AND "
  - Append "| limit {params.Limit}" if Limit > 0
  - Return complete LogsQL query string
- BuildHistogramQuery(params QueryParams) string:
  - Call BuildLogsQLQuery to get base query
  - Return base query (hits endpoint handles bucketing with step parameter)
- BuildAggregationQuery(params QueryParams, groupBy []string) string:
  - Call BuildLogsQLQuery to get base query
  - Append "| stats count() by {joined groupBy fields}" using strings.Join(groupBy, ", ")
  - Return aggregation query

IMPORTANT:
- Use time.RFC3339 for timestamp formatting (ISO 8601 compliant)
- Always include time range filter to prevent full history scans
- Exact match operator is := not = in LogsQL
- Empty field values should be omitted from query (not included as empty strings)
  </action>
  <verify>
go build ./internal/integration/victorialogs/... succeeds with no errors
go test ./internal/integration/victorialogs/... runs (expect no tests yet, just compilation)
  </verify>
  <done>
types.go defines all request/response structs with proper json tags
query.go exports Build* functions that construct valid LogsQL from structured parameters
Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VictoriaLogs HTTP client</name>
  <files>
internal/integration/victorialogs/client.go
  </files>
  <action>
Create client.go with HTTP client wrapper for VictoriaLogs API:

Client struct:
- baseURL string (VictoriaLogs instance URL)
- httpClient *http.Client (reusable with tuned transport)
- logger *logging.Logger (from internal/logging)

NewClient(baseURL string, queryTimeout time.Duration) *Client:
- Create http.Transport with tuned settings:
  - MaxIdleConns: 100
  - MaxConnsPerHost: 20
  - MaxIdleConnsPerHost: 10 (CRITICAL - default 2 causes connection churn)
  - IdleConnTimeout: 90 * time.Second
  - TLSHandshakeTimeout: 10 * time.Second
  - DialContext with Timeout: 5s, KeepAlive: 30s
- Create http.Client with Transport and Timeout set to queryTimeout (30s per requirements)
- Create logger with component name "victorialogs.client"
- Return &Client{baseURL, httpClient, logger}

QueryLogs(ctx context.Context, params QueryParams) (*QueryResponse, error):
- Call BuildLogsQLQuery(params) to construct query
- Build url.Values with "query" and "limit" (if params.Limit > 0)
- POST to {baseURL}/select/logsql/query with application/x-www-form-urlencoded
- Use http.NewRequestWithContext for timeout control
- Execute with c.httpClient.Do(req)
- CRITICAL: defer resp.Body.Close() AND io.ReadAll(resp.Body) even on error (connection reuse)
- Check resp.StatusCode != 200 â†’ return error with full response body
- Parse response body as JSON lines using bufio.Scanner
- For each line: json.Unmarshal into LogEntry, append to slice
- Set hasMore = (params.Limit > 0 && len(entries) >= params.Limit)
- Return &QueryResponse{Logs: entries, Count: len(entries), HasMore: hasMore}

QueryHistogram(ctx context.Context, params QueryParams, step string) (*HistogramResponse, error):
- Call BuildHistogramQuery(params)
- Build url.Values with "query", "start" (RFC3339), "end" (RFC3339), "step" (e.g., "5m")
- POST to {baseURL}/select/logsql/hits
- Same error handling pattern as QueryLogs (read body to completion!)
- Parse response as JSON into HistogramResponse
- Return result

QueryAggregation(ctx context.Context, params QueryParams, groupBy []string) (*AggregationResponse, error):
- Call BuildAggregationQuery(params, groupBy)
- Build url.Values with "query", "time" (params.TimeRange.End in RFC3339)
- POST to {baseURL}/select/logsql/stats_query
- Same error handling pattern
- Parse response as JSON into AggregationResponse
- Return result

CRITICAL PATTERNS:
- Always io.ReadAll(resp.Body) before closing (even on error status codes) - enables connection reuse
- Always use context.Context for timeout control
- Log errors with full VictoriaLogs error details for debugging
- Return wrapped errors with fmt.Errorf("action: %w", err) for context
  </action>
  <verify>
go build ./internal/integration/victorialogs/... succeeds
go test ./internal/integration/victorialogs/... compiles
grep -r "io.ReadAll.*Body" internal/integration/victorialogs/client.go confirms response body read
grep -r "MaxIdleConnsPerHost.*10" internal/integration/victorialogs/client.go confirms tuned connection pool
  </verify>
  <done>
client.go exports Client struct and NewClient constructor
Client has QueryLogs, QueryHistogram, QueryAggregation methods
HTTP client properly configured with connection pooling (MaxIdleConnsPerHost: 10)
Response bodies always read to completion for connection reuse
Code compiles without errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
- All files compile: go build ./internal/integration/victorialogs/...
- Types defined with proper json tags for VictoriaLogs field names
- Query builder constructs valid LogsQL with := operator and _time filter
- HTTP client uses tuned transport settings (MaxIdleConnsPerHost: 10)
- Response body always read to completion (grep confirms io.ReadAll)
</verification>

<success_criteria>
1. types.go defines all request/response structs matching VictoriaLogs API schema
2. query.go builds LogsQL queries from structured parameters without exposing raw LogsQL
3. client.go implements HTTP client with proper connection pooling and timeout control
4. Client methods handle errors gracefully and include VictoriaLogs error details
5. All code compiles without errors and follows project conventions
</success_criteria>

<output>
After completion, create `.planning/phases/03-victorialogs-client-pipeline/03-01-SUMMARY.md`
</output>
