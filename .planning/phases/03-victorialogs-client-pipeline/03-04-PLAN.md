---
phase: 03-victorialogs-client-pipeline
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/victorialogs/types.go
  - internal/integration/victorialogs/types_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Time range validation rejects queries with duration < 15 minutes"
    - "Validation error message clearly explains the 15-minute minimum constraint"
    - "Valid time ranges (>= 15 minutes) pass validation without error"
  artifacts:
    - path: "internal/integration/victorialogs/types.go"
      provides: "TimeRange validation method"
      exports: ["ValidateMinimumDuration"]
      min_lines: 95
    - path: "internal/integration/victorialogs/types_test.go"
      provides: "Unit tests for time range validation"
      min_lines: 80
  key_links:
    - from: "internal/integration/victorialogs/query.go"
      to: "types.TimeRange.ValidateMinimumDuration"
      via: "Validation in BuildLogsQLQuery"
      pattern: "ValidateMinimumDuration"
---

<objective>
Enforce 15-minute minimum time range constraint for VictoriaLogs queries to prevent excessive query load and poor performance.

Purpose: Close gap in VLOG-03 requirement where default 60min is implemented but minimum constraint is not enforced. This protects VictoriaLogs from very short time range queries (e.g., 1 second) that could cause performance issues.

Output: TimeRange validation method with comprehensive tests, preventing queries with duration < 15 minutes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-victorialogs-client-pipeline/03-VERIFICATION.md
@internal/integration/victorialogs/types.go
@internal/integration/victorialogs/query.go
@internal/integration/registry_test.go
</context>

<tasks>

<task type="auto">
  <name>Add time range validation method to types.go</name>
  <files>internal/integration/victorialogs/types.go</files>
  <action>
Add validation method to TimeRange struct in types.go:

```go
// ValidateMinimumDuration checks that the time range duration meets the minimum requirement.
// Returns an error if the duration is less than the specified minimum.
func (tr TimeRange) ValidateMinimumDuration(minDuration time.Duration) error {
	if tr.IsZero() {
		return nil // Zero time ranges use defaults, no validation needed
	}

	duration := tr.End.Sub(tr.Start)
	if duration < minDuration {
		return fmt.Errorf("time range duration %v is below minimum %v", duration, minDuration)
	}

	return nil
}

// Duration returns the duration of the time range (End - Start).
func (tr TimeRange) Duration() time.Duration {
	return tr.End.Sub(tr.Start)
}
```

Place this method after the `IsZero()` method and before `DefaultTimeRange()` to maintain logical grouping.

**Why this approach:**
- Validates only non-zero time ranges (zero ranges use defaults)
- Returns descriptive error message with actual vs minimum duration
- Simple, focused validation without side effects
- Duration() helper method for reusability
  </action>
  <verify>
Build the package to ensure no syntax errors:
```bash
cd /home/moritz/dev/spectre-via-ssh && go build ./internal/integration/victorialogs/
```
  </verify>
  <done>
- TimeRange has ValidateMinimumDuration method
- TimeRange has Duration helper method
- Package builds without errors
  </done>
</task>

<task type="auto">
  <name>Create comprehensive unit tests for time range validation</name>
  <files>internal/integration/victorialogs/types_test.go</files>
  <action>
Create new test file types_test.go following the pattern from registry_test.go:

```go
package victorialogs

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTimeRange_ValidateMinimumDuration(t *testing.T) {
	tests := []struct {
		name        string
		timeRange   TimeRange
		minDuration time.Duration
		expectError bool
		errorMsg    string
	}{
		{
			name: "valid range - exactly 15 minutes",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 15, 0, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: false,
		},
		{
			name: "valid range - 30 minutes",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 30, 0, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: false,
		},
		{
			name: "valid range - 1 hour",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 13, 0, 0, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: false,
		},
		{
			name: "invalid range - 14 minutes",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 14, 0, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: true,
			errorMsg:    "time range duration 14m0s is below minimum 15m0s",
		},
		{
			name: "invalid range - 1 minute",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 1, 0, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: true,
			errorMsg:    "time range duration 1m0s is below minimum 15m0s",
		},
		{
			name: "invalid range - 1 second",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 0, 1, 0, time.UTC),
			},
			minDuration: 15 * time.Minute,
			expectError: true,
			errorMsg:    "time range duration 1s is below minimum 15m0s",
		},
		{
			name:        "zero time range - no validation",
			timeRange:   TimeRange{},
			minDuration: 15 * time.Minute,
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.timeRange.ValidateMinimumDuration(tt.minDuration)

			if tt.expectError {
				require.Error(t, err, "Expected validation error but got none")
				assert.Contains(t, err.Error(), tt.errorMsg, "Error message mismatch")
			} else {
				assert.NoError(t, err, "Expected no validation error")
			}
		})
	}
}

func TestTimeRange_Duration(t *testing.T) {
	tests := []struct {
		name      string
		timeRange TimeRange
		expected  time.Duration
	}{
		{
			name: "15 minutes",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 12, 15, 0, 0, time.UTC),
			},
			expected: 15 * time.Minute,
		},
		{
			name: "1 hour",
			timeRange: TimeRange{
				Start: time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				End:   time.Date(2024, 1, 1, 13, 0, 0, 0, time.UTC),
			},
			expected: 1 * time.Hour,
		},
		{
			name:      "zero time range",
			timeRange: TimeRange{},
			expected:  0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			duration := tt.timeRange.Duration()
			assert.Equal(t, tt.expected, duration)
		})
	}
}

func TestDefaultTimeRange(t *testing.T) {
	tr := DefaultTimeRange()

	// Verify it returns approximately 1 hour duration
	duration := tr.Duration()
	assert.InDelta(t, float64(time.Hour), float64(duration), float64(time.Second),
		"DefaultTimeRange should return approximately 1 hour")

	// Verify End is after Start
	assert.True(t, tr.End.After(tr.Start), "End should be after Start")

	// Verify time range is recent (within last 2 seconds)
	assert.WithinDuration(t, time.Now(), tr.End, 2*time.Second,
		"End should be close to current time")
}
```

Use testify/assert and testify/require for assertions (consistent with existing test patterns).

Test coverage:
- Valid ranges: exactly 15min, 30min, 1 hour
- Invalid ranges: 14min, 1min, 1 second (edge cases)
- Zero time range (should skip validation)
- Duration() helper method
- DefaultTimeRange() correctness
  </action>
  <verify>
Run the tests:
```bash
cd /home/moritz/dev/spectre-via-ssh && go test -v ./internal/integration/victorialogs/ -run TestTimeRange
```

All tests should pass with clear output showing each test case.
  </verify>
  <done>
- types_test.go created with comprehensive test coverage
- All tests pass (7 validation test cases + 3 duration cases + 1 default test)
- Tests verify both valid and invalid time ranges
- Error messages validated
  </done>
</task>

<task type="auto">
  <name>Update BuildLogsQLQuery to enforce 15-minute minimum</name>
  <files>internal/integration/victorialogs/query.go</files>
  <action>
Add validation call at the start of BuildLogsQLQuery function in query.go:

```go
func BuildLogsQLQuery(params QueryParams) string {
	// Validate time range meets minimum duration requirement (15 minutes per VLOG-03)
	if !params.TimeRange.IsZero() {
		if err := params.TimeRange.ValidateMinimumDuration(15 * time.Minute); err != nil {
			// Return empty query on validation failure - caller should check for empty result
			// Alternative: log warning and clamp to 15min, but explicit failure is clearer
			return ""
		}
	}

	var filters []string
	// ... rest of function unchanged
```

Place this validation check immediately after the function signature and before any query construction.

**Why this approach:**
- Validates early, before constructing query
- Returns empty string on validation failure (caller detects invalid query)
- Only validates non-zero time ranges (zero ranges use defaults)
- 15 minutes hardcoded per VLOG-03 requirement
- Clear comment explaining the constraint

**Note:** This is a simple implementation. In production, you might want to return an error instead of empty string, but that would require changing the function signature. Empty string is sufficient for gap closure.
  </action>
  <verify>
Build the package to ensure no syntax errors:
```bash
cd /home/moritz/dev/spectre-via-ssh && go build ./internal/integration/victorialogs/
```

Create a simple integration test:
```bash
cd /home/moritz/dev/spectre-via-ssh && go test -v ./internal/integration/victorialogs/ -run TestBuildLogsQLQuery
```
  </verify>
  <done>
- BuildLogsQLQuery validates time range at function start
- Invalid time ranges return empty query string
- Package builds without errors
- Validation enforces 15-minute minimum per VLOG-03
  </done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
cd /home/moritz/dev/spectre-via-ssh && go build ./internal/integration/victorialogs/
```

**Unit test verification:**
```bash
cd /home/moritz/dev/spectre-via-ssh && go test -v ./internal/integration/victorialogs/
```

**Manual validation:**
1. Check that TimeRange has ValidateMinimumDuration method
2. Verify tests cover edge cases (exactly 15min, below 15min, zero range)
3. Confirm BuildLogsQLQuery rejects queries with duration < 15 minutes
4. Verify error messages are descriptive and helpful

**Gap closure validation:**
Reference VERIFICATION.md gap criteria:
- ✓ Validation enforces 15-minute minimum time range
- ✓ Error returned when user provides time range < 15 minutes
- ✓ Zero time ranges (using defaults) bypass validation
</verification>

<success_criteria>
1. TimeRange.ValidateMinimumDuration method exists and returns error for duration < minimum
2. TimeRange.Duration helper method returns correct duration
3. Unit tests pass with 100% coverage of validation logic
4. BuildLogsQLQuery validates time range and rejects invalid queries
5. Gap from 03-VERIFICATION.md is closed (VLOG-03 requirement fully satisfied)
6. All code builds without errors
7. Tests demonstrate validation behavior with edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/03-victorialogs-client-pipeline/03-04-SUMMARY.md` with:
- Gap closure summary (VLOG-03 constraint now enforced)
- Implementation approach (validation method + tests)
- Test results
- Files modified count
</output>
