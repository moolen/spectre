---
phase: 22-historical-analysis
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/flappiness.go
  - internal/integration/grafana/flappiness_test.go
  - internal/integration/grafana/baseline.go
  - internal/integration/grafana/baseline_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Flappiness score normalizes to 0.0-1.0 range for consistent comparison"
    - "Score penalizes short-lived states more than long-lived states"
    - "Baseline computation handles partial data (24h-7d) without error"
    - "Deviation score indicates how many standard deviations from baseline"
    - "Statistical functions use unbiased estimators (sample variance)"
  artifacts:
    - path: "internal/integration/grafana/flappiness.go"
      provides: "Flappiness score computation"
      exports: ["ComputeFlappinessScore"]
    - path: "internal/integration/grafana/baseline.go"
      provides: "Baseline computation and deviation analysis"
      exports: ["ComputeRollingBaseline", "CompareToBaseline"]
    - path: "internal/integration/grafana/flappiness_test.go"
      provides: "Flappiness computation tests"
      min_lines: 100
    - path: "internal/integration/grafana/baseline_test.go"
      provides: "Baseline computation tests"
      min_lines: 100
  key_links:
    - from: "internal/integration/grafana/flappiness.go"
      to: "gonum.org/v1/gonum/stat"
      via: "statistical computations"
      pattern: "stat\\.(Mean|StdDev|Variance)"
    - from: "internal/integration/grafana/baseline.go"
      to: "gonum.org/v1/gonum/stat"
      via: "statistical computations"
      pattern: "stat\\.(Mean|StdDev|Variance)"
---

<objective>
Create statistical analysis functions for alert flappiness scoring and baseline comparison using TDD methodology.

Purpose: Provide core mathematical functions for identifying flapping alerts and comparing current behavior to 7-day historical baseline using standard deviation analysis.

Output: Battle-tested statistical functions with comprehensive test coverage, ready for AlertAnalysisService integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-historical-analysis/22-CONTEXT.md
@.planning/phases/22-historical-analysis/22-RESEARCH.md
@.planning/phases/21-alert-sync-pipeline/21-01-SUMMARY.md
@.planning/phases/21-alert-sync-pipeline/21-02-SUMMARY.md

# Existing patterns
@internal/integration/grafana/statistical_detector.go
@internal/integration/grafana/statistical_detector_test.go
@internal/integration/grafana/baseline_cache.go
</context>

<feature>
  <name>Flappiness Score Computation</name>
  <files>internal/integration/grafana/flappiness.go, internal/integration/grafana/flappiness_test.go</files>

  <behavior>
    **Input:**
    - transitions []StateTransition (from_state, to_state, timestamp)
    - windowSize time.Duration (6 hours for flappiness detection)
    - currentTime time.Time (end of analysis window)

    **Output:**
    - score float64 (0.0-1.0, normalized flappiness score)

    **Expected behavior:**
    - Score 0.0 for stable alerts (0-1 transitions in window)
    - Score increases with transition frequency
    - Score penalizes short-lived states (brief firing then normal repeatedly)
    - Score normalized using maxPossibleTransitions (windowSize / 5min sync interval)
    - Score capped at 1.0 (alerts with extreme flapping don't exceed)

    **Test cases:**
    1. Empty transitions array → 0.0
    2. Single transition in window → low score (~0.1)
    3. 5 transitions in 6h window → moderate score (~0.5)
    4. 10 transitions with short state durations → high score (~0.8)
    5. Many transitions but long-lived states → lower score than same count with short states
    6. Transitions outside window → ignored in computation
  </behavior>

  <implementation>
    **StateTransition type:**
    ```go
    type StateTransition struct {
        FromState string    // "normal", "pending", "firing"
        ToState   string    // "normal", "pending", "firing"
        Timestamp time.Time // RFC3339 timestamp from graph edge
    }
    ```

    **Formula approach (Claude's discretion on exact weights):**
    - Frequency component: transitionCount / maxPossible (where maxPossible = windowSize / 5min)
    - Duration penalty: 1 - (avgStateDuration / windowSize) to penalize short-lived states
    - Combined score: frequency * durationPenalty, capped at 1.0

    **Use gonum/stat for any statistical operations (mean, stddev).**

    **Follow TDD RED-GREEN-REFACTOR cycle:**
    1. Write test describing expected behavior
    2. Run test - it MUST fail initially
    3. Implement minimal code to pass test
    4. Refactor if needed while keeping tests green
  </implementation>
</feature>

<feature>
  <name>Baseline Computation and Deviation Analysis</name>
  <files>internal/integration/grafana/baseline.go, internal/integration/grafana/baseline_test.go</files>

  <behavior>
    **Input:**
    - transitions []StateTransition (7 days of history)
    - lookbackDays int (typically 7)

    **Output:**
    - baseline StateDistribution (% normal, % pending, % firing)
    - stdDev float64 (standard deviation of firing percentage across days)
    - error if insufficient data (<24h)

    **StateDistribution type:**
    ```go
    type StateDistribution struct {
        PercentNormal  float64 // 0.0-1.0
        PercentPending float64 // 0.0-1.0
        PercentFiring  float64 // 0.0-1.0
    }
    ```

    **Expected behavior:**
    - Compute time in each state using LOCF interpolation for gaps
    - Calculate rolling average across available days (not time-of-day matching)
    - Use gonum/stat for standard deviation (sample variance, unbiased estimator)
    - Return ErrInsufficientData if <24h history available
    - Handle 24h-7d partial data gracefully (compute baseline from what exists)

    **Test cases:**
    1. <24h history → ErrInsufficientData
    2. Exactly 24h history → baseline computed, partial data warning
    3. Full 7 days, stable firing → high PercentFiring, low stdDev
    4. Full 7 days, alternating states → mixed distribution, high stdDev
    5. Gaps in data → LOCF interpolation fills gaps
    6. Empty states (all normal) → 100% normal, 0% others

    **Deviation comparison:**
    - Input: current StateDistribution, baseline StateDistribution, stdDev float64
    - Output: deviationScore float64 (how many standard deviations from baseline)
    - Formula: abs(current.PercentFiring - baseline.PercentFiring) / stdDev
    - Test: 2σ deviation (deviationScore = 2.0) indicates abnormal behavior
  </behavior>

  <implementation>
    **Add gonum dependency:**
    ```bash
    go get gonum.org/v1/gonum/stat
    ```

    **LOCF interpolation:**
    - Sort transitions chronologically
    - For each consecutive pair, compute duration in ToState
    - Last state duration: carry forward to end of analysis window

    **Daily distribution computation:**
    - Split transitions into 24-hour buckets
    - Compute state distribution per day
    - Use gonum/stat.StdDev for sample standard deviation (unbiased)

    **Error handling:**
    - Define ErrInsufficientData error type with Available and Required durations
    - Return structured error for <24h data

    **Follow existing patterns:**
    - Use time.Duration for all time calculations
    - Convert timestamps to UTC before comparisons
    - Follow statistical_detector.go pattern for detector struct
  </implementation>
</feature>

<verification>
**TDD cycle verification:**
- [ ] RED phase: Tests written and fail initially (before implementation)
- [ ] GREEN phase: Tests pass after implementation
- [ ] REFACTOR phase: Code cleaned up while maintaining green tests

**Test coverage:**
- [ ] `go test ./internal/integration/grafana/... -run TestFlappiness -v` passes all tests
- [ ] `go test ./internal/integration/grafana/... -run TestBaseline -v` passes all tests
- [ ] Test coverage >80% for flappiness.go and baseline.go

**Statistical correctness:**
- [ ] Sample variance used (N-1 divisor, unbiased estimator)
- [ ] Flappiness score always in 0.0-1.0 range
- [ ] Deviation score correctly computes σ distance from baseline
- [ ] LOCF interpolation fills gaps without data loss
</verification>

<success_criteria>
**Measurable completion:**
- [ ] gonum.org/v1/gonum/stat added to go.mod
- [ ] flappiness.go exports ComputeFlappinessScore function
- [ ] baseline.go exports ComputeRollingBaseline and CompareToBaseline functions
- [ ] flappiness_test.go has 6+ test cases covering edge cases
- [ ] baseline_test.go has 6+ test cases covering partial data and LOCF
- [ ] All tests pass: `go test ./internal/integration/grafana/... -v`
- [ ] No golangci-lint errors: `golangci-lint run internal/integration/grafana/flappiness.go internal/integration/grafana/baseline.go`
- [ ] Flappiness score computation handles empty/single/many transitions correctly
- [ ] Baseline computation uses sample variance (stat.Variance, not stat.PopVariance)
- [ ] ErrInsufficientData returned for <24h history with clear error message
</success_criteria>

<output>
After completion, create `.planning/phases/22-historical-analysis/22-01-SUMMARY.md` documenting:
- TDD cycle commits (RED, GREEN, REFACTOR)
- Test coverage metrics
- Statistical formula decisions
- Edge cases handled
</output>
