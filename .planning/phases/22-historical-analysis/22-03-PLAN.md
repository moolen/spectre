---
phase: 22-historical-analysis
plan: 03
type: execute
wave: 3
depends_on: ["22-02"]
files_modified:
  - internal/integration/grafana/grafana.go
  - internal/integration/grafana/integration_lifecycle_test.go
autonomous: true

must_haves:
  truths:
    - "AlertAnalysisService is created during GrafanaIntegration.Start lifecycle"
    - "Service is accessible via GrafanaIntegration.GetAnalysisService method"
    - "Service shares graphClient with AlertSyncer and AlertStateSyncer"
    - "Integration tests verify end-to-end analysis flow with mocked graph data"
    - "Service lifecycle follows established pattern (create on Start, nil on Stop)"
  artifacts:
    - path: "internal/integration/grafana/grafana.go"
      provides: "AlertAnalysisService lifecycle wiring"
      contains: "analysisService *AlertAnalysisService"
      min_lines: 250
    - path: "internal/integration/grafana/integration_lifecycle_test.go"
      provides: "Integration tests for analysis service"
      contains: "TestGrafanaIntegration_AlertAnalysis"
      min_lines: 100
  key_links:
    - from: "internal/integration/grafana/grafana.go"
      to: "internal/integration/grafana/alert_analysis_service.go"
      via: "NewAlertAnalysisService constructor call"
      pattern: "NewAlertAnalysisService\\("
    - from: "internal/integration/grafana/grafana.go"
      to: "internal/graph.Client"
      via: "shared graphClient passed to analysis service"
      pattern: "graphClient.*AlertAnalysisService"
---

<objective>
Wire AlertAnalysisService into GrafanaIntegration lifecycle and verify end-to-end functionality with integration tests.

Purpose: Make historical analysis available to Phase 23 MCP tools through established integration lifecycle pattern.

Output: Working service accessible via integration instance, tested with realistic state transition scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-historical-analysis/22-CONTEXT.md

# Plan 22-02 outputs
@internal/integration/grafana/alert_analysis_service.go
@internal/integration/grafana/categorization.go
@internal/integration/grafana/transitions.go

# Lifecycle patterns
@internal/integration/grafana/grafana.go
@internal/integration/grafana/alert_state_syncer.go
@internal/integration/grafana/integration_lifecycle_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AlertAnalysisService into integration lifecycle</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
Add AlertAnalysisService to GrafanaIntegration struct and lifecycle methods.

**Struct changes:**
```go
type GrafanaIntegration struct {
    // ... existing fields ...
    stateSyncer     *AlertStateSyncer
    analysisService *AlertAnalysisService // NEW
    logger          *logging.Logger
}
```

**Start method changes (after stateSyncer creation):**
```go
// Create alert analysis service (shares graph client)
g.analysisService = NewAlertAnalysisService(
    graphClient,
    config.Name,
    g.logger,
)
g.logger.Info("Alert analysis service created for integration %s", config.Name)
```

**Key points:**
- Create AFTER graphClient is initialized (same as AlertSyncer/AlertStateSyncer pattern)
- Share graphClient instance (no separate graph client needed)
- No Start/Stop methods on service (stateless, cache is automatic)
- Non-fatal: if creation fails, log warning but continue (alerts still work)

**Add getter method for Phase 23 MCP tools:**
```go
// GetAnalysisService returns the alert analysis service for this integration
// Returns nil if service not initialized (graph disabled or startup failed)
func (g *GrafanaIntegration) GetAnalysisService() *AlertAnalysisService {
    return g.analysisService
}
```

**Stop method changes:**
```go
// Stop method cleanup (before graphClient cleanup)
if g.analysisService != nil {
    g.logger.Info("Clearing alert analysis service for integration %s", g.config.Name)
    g.analysisService = nil // Clear reference
}
```

**Follow Phase 21-02 pattern:**
- AlertStateSyncer has lifecycle (Start/Stop) because it runs background sync
- AlertAnalysisService is stateless (no background work), just created and held
- Cache cleanup is automatic (golang-lru handles expiration)
  </action>
  <verify>
Check that service is created on Start:
```bash
grep -A 5 "NewAlertAnalysisService" internal/integration/grafana/grafana.go
```

Verify getter method exists:
```bash
grep "GetAnalysisService" internal/integration/grafana/grafana.go
```

Run existing lifecycle tests to ensure no regressions:
```bash
go test ./internal/integration/grafana/... -run TestGrafanaIntegration_Lifecycle -v
```
  </verify>
  <done>
GrafanaIntegration.analysisService field added, NewAlertAnalysisService called in Start after graphClient init, GetAnalysisService getter method exists, analysisService cleared in Stop, service shares graphClient with syncers, no background goroutines (stateless service).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for end-to-end analysis flow</name>
  <files>internal/integration/grafana/integration_lifecycle_test.go</files>
  <action>
Add integration tests verifying AlertAnalysisService functionality with mocked graph data.

**Test 1: Alert analysis with full history**
```go
func TestGrafanaIntegration_AlertAnalysis_FullHistory(t *testing.T) {
    // Setup: integration with mocked graph client
    // Mock returns 7 days of state transitions (stable firing)
    // Action: Call analysisService.AnalyzeAlert
    // Verify:
    //   - FlappinessScore is low (stable alert)
    //   - Categories.Onset contains "chronic" (>7d firing)
    //   - Categories.Pattern contains "stable-firing"
    //   - DeviationScore computed (not zero)
    //   - Baseline contains state distribution
}
```

**Test 2: Alert analysis with flapping pattern**
```go
func TestGrafanaIntegration_AlertAnalysis_Flapping(t *testing.T) {
    // Setup: integration with mocked graph client
    // Mock returns transitions with 10+ state changes in 6h window
    // Action: Call analysisService.AnalyzeAlert
    // Verify:
    //   - FlappinessScore is high (>0.7)
    //   - Categories.Pattern contains "flapping"
    //   - May also have onset category (recent/persistent)
}
```

**Test 3: Alert analysis with insufficient data**
```go
func TestGrafanaIntegration_AlertAnalysis_InsufficientData(t *testing.T) {
    // Setup: integration with mocked graph client
    // Mock returns transitions spanning only 12h (< 24h minimum)
    // Action: Call analysisService.AnalyzeAlert
    // Verify:
    //   - Returns ErrInsufficientData
    //   - Error message includes available and required durations
}
```

**Test 4: Alert analysis cache behavior**
```go
func TestGrafanaIntegration_AlertAnalysis_Cache(t *testing.T) {
    // Setup: integration with mocked graph client
    // Mock tracks how many times FetchStateTransitions is called
    // Action: Call AnalyzeAlert twice with same alertUID within 5 minutes
    // Verify:
    //   - First call queries graph (mock called once)
    //   - Second call uses cache (mock NOT called again)
    //   - Both calls return same ComputedAt timestamp
}
```

**Test 5: Lifecycle integration (service available after Start)**
```go
func TestGrafanaIntegration_Lifecycle_AnalysisService(t *testing.T) {
    // Setup: Create GrafanaIntegration
    // Action: Call Start
    // Verify:
    //   - GetAnalysisService() returns non-nil
    //   - Service has correct integrationName
    // Action: Call Stop
    // Verify:
    //   - GetAnalysisService() returns nil after stop
}
```

**Mock graph client updates:**
- Add handler for STATE_TRANSITION queries (detect via strings.Contains)
- Return different transition scenarios based on test case
- Use RFC3339 timestamps (Phase 21 pattern)
- Include expires_at in mock data (7 days from now)

**Follow existing test patterns:**
- Use mockGraphClientForStates pattern from alert_state_syncer_test.go
- Use testify/assert for assertions
- Use table-driven tests if multiple scenarios per test
  </action>
  <verify>
Run integration tests:
```bash
go test ./internal/integration/grafana/... -run TestGrafanaIntegration_AlertAnalysis -v
```

Verify all 5 test cases pass:
- FullHistory (stable chronic alert)
- Flapping (high flappiness score)
- InsufficientData (error returned)
- Cache (second call cached)
- Lifecycle (service created/cleared)

Check test output shows:
- Cache hit logged on second call
- ErrInsufficientData contains duration info
- Flappiness scores in expected ranges
  </verify>
  <done>
5 integration tests added to integration_lifecycle_test.go, tests cover full history analysis, flapping detection, insufficient data handling, cache behavior, and lifecycle integration, mock graph client returns realistic state transitions with RFC3339 timestamps, tests verify multi-label categorization output, cache hit reduces graph queries on second call.
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification and documentation</name>
  <files>None (verification only)</files>
  <action>
Perform final verification that Phase 22 is complete and ready for Phase 23 MCP tools.

**Verification steps:**

1. **Run all Phase 22 tests:**
```bash
go test ./internal/integration/grafana/... -run "Test(Flappiness|Baseline|Categorize|AlertAnalysisService|GrafanaIntegration_AlertAnalysis)" -v
```

2. **Check test coverage:**
```bash
go test ./internal/integration/grafana/... -coverprofile=coverage.out
go tool cover -func=coverage.out | grep -E "(flappiness|baseline|categorization|alert_analysis_service|transitions)"
```
Target: >80% coverage for new files

3. **Verify no lint errors:**
```bash
golangci-lint run internal/integration/grafana/flappiness.go \
                   internal/integration/grafana/baseline.go \
                   internal/integration/grafana/categorization.go \
                   internal/integration/grafana/alert_analysis_service.go \
                   internal/integration/grafana/transitions.go
```

4. **Check Phase 23 readiness:**
- Verify GetAnalysisService() method exists and is public
- Verify AnalyzeAlert returns all required fields (flappiness, deviation, baseline, categories)
- Verify cache reduces repeated queries (check test logs for cache hit messages)

5. **Manual spot check (if needed):**
Run service in debug mode and verify:
- State transitions fetched from graph with correct WHERE clauses
- Flappiness score computed in 0.0-1.0 range
- Categories include both onset and pattern labels
- Cache hits logged at DEBUG level

**What Phase 23 MCP tools need:**
```go
// In MCP tool implementation (Phase 23)
integration := getIntegration(integrationName)
analysisService := integration.GetAnalysisService()
if analysisService == nil {
    return nil, errors.New("analysis service not available")
}

result, err := analysisService.AnalyzeAlert(ctx, alertUID)
if err != nil {
    // Handle ErrInsufficientData vs other errors
    return nil, err
}

// Use result.FlappinessScore, result.Categories, result.DeviationScore
// in MCP tool response formatting
```

**Document in STATE.md:**
- Phase 22 complete: AlertAnalysisService available via GetAnalysisService()
- Flappiness detection: 6-hour window, 0.0-1.0 normalized score
- Baseline comparison: 7-day rolling baseline with Ïƒ deviation
- Multi-label categorization: onset + pattern dimensions
- Cache: 5-minute TTL, 1000 entry limit
- Minimum data: 24h required, graceful handling of 24h-7d partial data
  </action>
  <verify>
All tests pass:
```bash
go test ./internal/integration/grafana/... -v
```

Coverage >80% for new files:
```bash
go test ./internal/integration/grafana/... -coverprofile=coverage.out
go tool cover -func=coverage.out | grep -E "(flappiness|baseline|categorization|alert_analysis_service|transitions)" | awk '{print $3}' | sed 's/%//' | awk '{sum+=$1; count++} END {print sum/count"%"}'
```

No lint errors:
```bash
golangci-lint run internal/integration/grafana/ 2>&1 | grep -E "(flappiness|baseline|categorization|alert_analysis_service|transitions)" && echo "LINT ERRORS FOUND" || echo "LINT CLEAN"
```
  </verify>
  <done>
All Phase 22 tests pass, test coverage >80% for new files, no golangci-lint errors, GetAnalysisService() method verified, AnalyzeAlert returns complete AnalysisResult, cache behavior verified via tests, Phase 23 integration pattern documented, STATE.md updated with Phase 22 completion.
  </done>
</task>

</tasks>

<verification>
**Phase completion checks:**
- [ ] AlertAnalysisService integrated into GrafanaIntegration lifecycle
- [ ] GetAnalysisService() getter method exists for Phase 23 MCP tools
- [ ] Service shares graphClient with AlertSyncer and AlertStateSyncer
- [ ] 5 integration tests cover full history, flapping, insufficient data, cache, lifecycle
- [ ] All tests pass: `go test ./internal/integration/grafana/... -v`
- [ ] Test coverage >80% for new files
- [ ] No golangci-lint errors in new files
- [ ] Cache hit reduces graph queries (verified in cache test)
- [ ] ErrInsufficientData returned for <24h history with clear message
- [ ] Multi-label categorization produces onset + pattern categories
</verification>

<success_criteria>
**Measurable completion:**
- [ ] GrafanaIntegration.analysisService field exists
- [ ] NewAlertAnalysisService called in Start method after graphClient init
- [ ] GetAnalysisService() public getter method exists
- [ ] analysisService cleared in Stop method
- [ ] 5 integration tests exist in integration_lifecycle_test.go
- [ ] All tests pass: `go test ./internal/integration/grafana/... -v` exits 0
- [ ] Test coverage: `go tool cover -func=coverage.out` shows >80% for new files
- [ ] golangci-lint: `golangci-lint run internal/integration/grafana/` exits 0
- [ ] Cache test verifies second call doesn't query graph again
- [ ] Flapping test verifies flappinessScore > 0.7 produces "flapping" category
- [ ] Insufficient data test verifies ErrInsufficientData contains Available and Required fields
- [ ] STATE.md updated with Phase 22 completion notes
</success_criteria>

<output>
After completion, create `.planning/phases/22-historical-analysis/22-03-SUMMARY.md` documenting:
- Lifecycle integration approach (when service is created/cleared)
- Integration test scenarios (full history, flapping, insufficient data, cache)
- Phase 23 readiness checklist (what MCP tools need to know)
- Performance characteristics (cache hit rate, query reduction)
- Known limitations (minimum 24h data, 5-minute cache TTL)
</output>
