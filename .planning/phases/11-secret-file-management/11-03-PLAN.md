---
phase: 11-secret-file-management
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - internal/integration/victorialogs/victorialogs.go
  - internal/integration/victorialogs/client.go
autonomous: true

must_haves:
  truths:
    - "Integration creates SecretWatcher when Config.UsesSecretRef() is true"
    - "Client uses token from SecretWatcher for authentication"
    - "Integration reports degraded health when SecretWatcher has no token"
    - "MCP tools return error when integration is degraded due to missing token"
  artifacts:
    - path: "internal/integration/victorialogs/victorialogs.go"
      provides: "Integration wiring for SecretWatcher"
      contains: "secretWatcher"
    - path: "internal/integration/victorialogs/client.go"
      provides: "Client uses dynamic token from watcher"
      contains: "GetToken"
  key_links:
    - from: "victorialogs.go NewVictoriaLogsIntegration"
      to: "Config.UsesSecretRef()"
      via: "Conditionally create SecretWatcher"
      pattern: "UsesSecretRef.*SecretWatcher"
    - from: "victorialogs.go Start()"
      to: "secretWatcher.Start()"
      via: "Lifecycle management"
      pattern: "secretWatcher\\.Start"
    - from: "client.go"
      to: "secretWatcher.GetToken()"
      via: "Dynamic token fetch per request"
      pattern: "GetToken.*Bearer"
---

<objective>
Wire SecretWatcher into VictoriaLogsIntegration lifecycle and update HTTP client to use dynamic token authentication.

Purpose: Complete the secret management flow - integration fetches token from Kubernetes, client uses token for API authentication, degraded state propagates through health checks to MCP tools.

Output: Working integration that reads tokens from Kubernetes Secrets with hot-reload support and graceful degradation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-v1.2.md
@.planning/STATE.md
@.planning/phases/11-secret-file-management/11-CONTEXT.md
@.planning/phases/11-secret-file-management/11-RESEARCH.md

# Outputs from previous plans (dependency context)
@.planning/phases/11-secret-file-management/11-01-PLAN.md
@.planning/phases/11-secret-file-management/11-02-PLAN.md

# Existing integration code
@internal/integration/victorialogs/victorialogs.go
@internal/integration/victorialogs/client.go
@internal/integration/victorialogs/types.go
</context>

<tasks>

<task type="auto">
  <name>Integrate SecretWatcher into VictoriaLogsIntegration lifecycle</name>
  <files>
    internal/integration/victorialogs/victorialogs.go
  </files>
  <action>
Update VictoriaLogsIntegration to create and manage SecretWatcher:

**Update struct (add field):**
```go
type VictoriaLogsIntegration struct {
    name          string
    url           string
    config        Config  // Store full config (not just url string)
    client        *Client
    pipeline      *Pipeline
    metrics       *Metrics
    logger        *logging.Logger
    registry      integration.ToolRegistry
    templateStore *logprocessing.TemplateStore
    secretWatcher *SecretWatcher  // NEW: optional, only created if config uses SecretRef
}
```

**Update NewVictoriaLogsIntegration factory:**
- Parse config map into Config struct (not just extract URL string)
- Call config.Validate() - return error if validation fails
- Store config in integration struct (not just url)
- Initialize secretWatcher to nil (created in Start())

Example:
```go
func NewVictoriaLogsIntegration(name string, configMap map[string]interface{}) (integration.Integration, error) {
    // Parse config from map (use existing pattern or add helper)
    var config Config
    // ... parse configMap into config struct ...

    // Validate config
    if err := config.Validate(); err != nil {
        return nil, fmt.Errorf("invalid config: %w", err)
    }

    return &VictoriaLogsIntegration{
        name:          name,
        config:        config,
        client:        nil,
        pipeline:      nil,
        metrics:       nil,
        templateStore: nil,
        secretWatcher: nil,  // Created in Start()
        logger:        logging.GetLogger("integration.victorialogs." + name),
    }, nil
}
```

**Update Start() method:**

Add SecretWatcher initialization BEFORE creating client:

```go
func (v *VictoriaLogsIntegration) Start(ctx context.Context) error {
    v.logger.Info("Starting VictoriaLogs integration: %s (url: %s)", v.name, v.config.URL)

    // Create Prometheus metrics
    v.metrics = NewMetrics(prometheus.DefaultRegisterer, v.name)

    // Create SecretWatcher if config uses secret ref
    if v.config.UsesSecretRef() {
        v.logger.Info("Creating SecretWatcher for secret: %s, key: %s",
            v.config.APITokenRef.SecretName, v.config.APITokenRef.Key)

        // Create in-cluster Kubernetes client
        k8sConfig, err := rest.InClusterConfig()
        if err != nil {
            return fmt.Errorf("failed to get in-cluster config: %w", err)
        }
        clientset, err := kubernetes.NewForConfig(k8sConfig)
        if err != nil {
            return fmt.Errorf("failed to create Kubernetes clientset: %w", err)
        }

        // Get current namespace (read from ServiceAccount mount)
        namespace, err := getCurrentNamespace()
        if err != nil {
            return fmt.Errorf("failed to determine namespace: %w", err)
        }

        // Create and start SecretWatcher
        v.secretWatcher = NewSecretWatcher(
            clientset,
            namespace,
            v.config.APITokenRef.SecretName,
            v.config.APITokenRef.Key,
            v.logger,
        )

        if err := v.secretWatcher.Start(ctx); err != nil {
            return fmt.Errorf("failed to start secret watcher: %w", err)
        }

        v.logger.Info("SecretWatcher started successfully")
    }

    // Create HTTP client (pass secretWatcher if exists)
    v.client = NewClient(v.config.URL, 60*time.Second, v.secretWatcher)

    // ... rest of Start() unchanged (pipeline, template store, connectivity test) ...
}
```

**Add helper function:**
```go
// getCurrentNamespace reads the namespace from the ServiceAccount mount
func getCurrentNamespace() (string, error) {
    const namespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
    data, err := os.ReadFile(namespaceFile)
    if err != nil {
        return "", fmt.Errorf("failed to read namespace file: %w", err)
    }
    return strings.TrimSpace(string(data)), nil
}
```

**Update Stop() method:**
```go
func (v *VictoriaLogsIntegration) Stop(ctx context.Context) error {
    v.logger.Info("Stopping VictoriaLogs integration: %s", v.name)

    // Stop pipeline
    if v.pipeline != nil {
        if err := v.pipeline.Stop(ctx); err != nil {
            v.logger.Error("Error stopping pipeline: %v", err)
        }
    }

    // Stop secret watcher if exists
    if v.secretWatcher != nil {
        if err := v.secretWatcher.Stop(); err != nil {
            v.logger.Error("Error stopping secret watcher: %v", err)
        }
    }

    // Unregister metrics
    if v.metrics != nil {
        v.metrics.Unregister()
    }

    // Clear references
    v.client = nil
    v.pipeline = nil
    v.metrics = nil
    v.templateStore = nil
    v.secretWatcher = nil

    v.logger.Info("VictoriaLogs integration stopped")
    return nil
}
```

**Update Health() method:**
```go
func (v *VictoriaLogsIntegration) Health(ctx context.Context) integration.HealthStatus {
    if v.client == nil {
        return integration.Stopped
    }

    // If using secret ref, check if token is available
    if v.secretWatcher != nil && !v.secretWatcher.IsHealthy() {
        v.logger.Warn("Integration degraded: SecretWatcher has no valid token")
        return integration.Degraded
    }

    // Test connectivity
    if err := v.testConnection(ctx); err != nil {
        return integration.Degraded
    }

    return integration.Healthy
}
```

Add imports:
- k8s.io/client-go/rest
- k8s.io/client-go/kubernetes
- os (for namespace file read)
  </action>
  <verify>
go build ./internal/integration/victorialogs/
go test ./internal/integration/victorialogs/ -run TestVictoriaLogsIntegration
  </verify>
  <done>
- VictoriaLogsIntegration struct has secretWatcher field
- NewVictoriaLogsIntegration parses Config struct and validates
- Start() creates SecretWatcher when config.UsesSecretRef() is true
- Start() reads current namespace from ServiceAccount mount
- Start() passes secretWatcher to NewClient()
- Stop() stops secretWatcher if exists
- Health() returns Degraded when secretWatcher.IsHealthy() is false
- getCurrentNamespace() helper reads /var/run/secrets/.../namespace
- go build succeeds
  </done>
</task>

<task type="auto">
  <name>Update Client to use dynamic token from SecretWatcher</name>
  <files>
    internal/integration/victorialogs/client.go
  </files>
  <action>
Update HTTP Client to fetch token dynamically from SecretWatcher per request:

**Update Client struct:**
```go
type Client struct {
    baseURL       string
    httpClient    *http.Client
    secretWatcher *SecretWatcher  // NEW: optional, for dynamic token fetch
}
```

**Update NewClient constructor:**
```go
func NewClient(baseURL string, timeout time.Duration, secretWatcher *SecretWatcher) *Client {
    return &Client{
        baseURL: baseURL,
        httpClient: &http.Client{
            Timeout: timeout,
        },
        secretWatcher: secretWatcher,
    }
}
```

**Update request execution methods:**

Find the method that makes HTTP requests (likely `QueryLogs` or similar). Before executing request, fetch token if secretWatcher exists:

```go
func (c *Client) QueryLogs(ctx context.Context, params QueryParams) ([]LogEntry, error) {
    // Build request...
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    // Add authentication header if using secret watcher
    if c.secretWatcher != nil {
        token, err := c.secretWatcher.GetToken()
        if err != nil {
            return nil, fmt.Errorf("failed to get API token: %w", err)
        }
        // VictoriaLogs might use Basic Auth or custom header - adjust as needed
        req.Header.Set("Authorization", "Bearer " + token)
    }

    // Execute request...
    resp, err := c.httpClient.Do(req)
    // ... rest of method unchanged ...
}
```

**Important notes:**
- Token is fetched PER REQUEST (not cached in Client) - ensures hot-reload works
- If secretWatcher.GetToken() returns error, propagate error immediately (don't retry internally)
- VictoriaLogs authentication might differ from bearer token pattern - check existing client.go for auth method
- If VictoriaLogs doesn't use authentication currently, this becomes placeholder for Phase 10 (Logz.io)
- DO NOT log token value in error messages

**Defensive check in NewClient:**
If you discover VictoriaLogs doesn't support authentication yet:
- Accept secretWatcher parameter but log warning if non-nil
- Comment: "Token authentication not yet supported by VictoriaLogs client, prepared for Logz.io in Phase 10"
  </action>
  <verify>
go build ./internal/integration/victorialogs/
go test ./internal/integration/victorialogs/ -run TestClient
  </verify>
  <done>
- Client struct has secretWatcher field
- NewClient accepts secretWatcher parameter (may be nil)
- QueryLogs (or equivalent method) calls secretWatcher.GetToken() before request
- Authorization header set if token available
- go build succeeds
- If VictoriaLogs doesn't use auth: warning logged, code prepared for future use
  </done>
</task>

</tasks>

<verification>
- [ ] go build succeeds for internal/integration/victorialogs/
- [ ] VictoriaLogsIntegration creates SecretWatcher when config.UsesSecretRef() is true
- [ ] Start() reads namespace from /var/run/secrets/kubernetes.io/serviceaccount/namespace
- [ ] Client fetches token per request via secretWatcher.GetToken()
- [ ] Health() returns Degraded when secretWatcher reports unhealthy
- [ ] Stop() stops secretWatcher and prevents goroutine leaks
- [ ] NewVictoriaLogsIntegration validates config before creating integration
- [ ] No token values logged in error messages
</verification>

<success_criteria>
**Integration wiring complete:**
- VictoriaLogsIntegration creates SecretWatcher when config uses secret ref
- SecretWatcher lifecycle managed (Start/Stop)
- Client fetches token dynamically per request
- Health checks reflect token availability
- Degraded state when token missing
- getCurrentNamespace() reads namespace from ServiceAccount mount
- No hardcoded namespace values
- Tests verify integration behavior
</success_criteria>

<output>
After completion, create `.planning/phases/11-secret-file-management/11-03-SUMMARY.md`
</output>
