---
phase: 11-secret-file-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/victorialogs/secret_watcher.go
  - internal/integration/victorialogs/secret_watcher_test.go
autonomous: true

must_haves:
  truths:
    - "SecretWatcher fetches token from Kubernetes Secret at startup"
    - "SecretWatcher detects Secret updates within 2 seconds via Watch API"
    - "SecretWatcher handles missing/deleted secrets gracefully (degraded mode)"
    - "Token values never appear in logs (automatic redaction)"
  artifacts:
    - path: "internal/integration/victorialogs/secret_watcher.go"
      provides: "SecretWatcher with SharedInformerFactory"
      min_lines: 200
      exports: ["SecretWatcher", "NewSecretWatcher"]
    - path: "internal/integration/victorialogs/secret_watcher_test.go"
      provides: "Tests for token rotation and error handling"
      min_lines: 100
  key_links:
    - from: "secret_watcher.go"
      to: "k8s.io/client-go/informers.SharedInformerFactory"
      via: "NewSharedInformerFactoryWithOptions"
      pattern: "informers\\.NewSharedInformerFactoryWithOptions"
    - from: "secret_watcher.go"
      to: "sync.RWMutex"
      via: "Token storage protection"
      pattern: "RLock|Lock.*token"
    - from: "secret_watcher.go"
      to: "cache.ResourceEventHandlerFuncs"
      via: "AddFunc/UpdateFunc/DeleteFunc handlers"
      pattern: "AddEventHandler.*ResourceEventHandlerFuncs"
---

<objective>
Implement SecretWatcher using client-go's SharedInformerFactory to fetch and watch Kubernetes Secrets with hot-reload support.

Purpose: Enable zero-downtime credential rotation for Logz.io API tokens without pod restarts. Foundation for secret-based authentication.

Output: SecretWatcher component with thread-safe token storage, automatic secret rotation detection, and graceful degradation when secrets are missing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-v1.2.md
@.planning/STATE.md
@.planning/phases/11-secret-file-management/11-CONTEXT.md
@.planning/phases/11-secret-file-management/11-RESEARCH.md

# Existing integration patterns
@internal/integration/types.go
@internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Implement SecretWatcher with SharedInformerFactory</name>
  <files>
    internal/integration/victorialogs/secret_watcher.go
  </files>
  <action>
Create SecretWatcher component following the research patterns:

**Struct definition:**
```go
type SecretWatcher struct {
    mu          sync.RWMutex
    token       string
    healthy     bool

    namespace   string
    secretName  string
    key         string

    clientset   *kubernetes.Clientset
    factory     informers.SharedInformerFactory
    cancel      context.CancelFunc
    logger      *logging.Logger
}
```

**Constructor:** NewSecretWatcher(clientset, namespace, secretName, key, logger) - validates inputs, stores config.

**Start(ctx) method:**
- Create cancellable context for informer lifecycle
- Create SharedInformerFactory with 30s resync, scoped to namespace (informers.WithNamespace)
- Get secret informer: factory.Core().V1().Secrets().Informer()
- Add ResourceEventHandlerFuncs with AddFunc/UpdateFunc/DeleteFunc
- Filter events by secretName match (handlers receive all secrets in namespace)
- Start factory: factory.Start(ctx.Done())
- Wait for cache sync: cache.WaitForCacheSync(ctx.Done(), informer.HasSynced)
- Call initialFetch() to populate token from cache

**Stop() method:**
- Cancel context to stop informer goroutines
- Call factory.Shutdown() to wait for goroutines to exit (prevents leaks)

**Event handlers:**
- handleSecretUpdate(secret): Extract secret.Data[key], trim whitespace, validate non-empty, update token with lock, log rotation
- handleSecretDelete(secret): Log warning, call markDegraded()
- markDegraded(): Lock, set healthy=false, unlock

**initialFetch():**
- Use lister (factory.Core().V1().Secrets().Lister().Secrets(namespace).Get(secretName))
- If error: log warning "starting degraded", markDegraded(), return nil (don't fail startup)
- If success: call handleSecretUpdate(secret)

**GetToken() method:**
- RLock, defer RUnlock
- If !healthy or token=="": return "", fmt.Errorf("integration degraded: missing API token")
- Return token, nil

**IsHealthy() method:**
- RLock, defer RUnlock, return healthy

**In-cluster config creation:**
- Use rest.InClusterConfig() for ServiceAccount authentication
- kubernetes.NewForConfig(config) to create clientset

**Token redaction:**
- Logs must never include token values
- Use "Token rotated" not "Token rotated: %s"
- Error messages: "invalid token" not "invalid token: %s"

**Error handling:**
- Missing key in secret: log available keys for debugging, markDegraded
- Empty token after trim: log warning, markDegraded
- Secret not found at startup: log "starting degraded", don't fail

**Thread-safety:**
- All token reads use RLock (concurrent)
- All token writes use Lock (exclusive)
- Run go test with -race flag to verify

Use imports:
- k8s.io/client-go/kubernetes
- k8s.io/client-go/informers
- k8s.io/client-go/rest
- k8s.io/client-go/tools/cache
- k8s.io/api/core/v1 (as corev1)
- sync, context, fmt, strings, time
- github.com/moolen/spectre/internal/logging
  </action>
  <verify>
go build ./internal/integration/victorialogs/
go test -race ./internal/integration/victorialogs/ -run TestSecretWatcher
  </verify>
  <done>
- SecretWatcher struct with RWMutex, token, healthy fields exists
- NewSecretWatcher validates inputs and returns instance
- Start() creates informer factory scoped to namespace, adds event handlers, waits for cache sync
- Stop() cancels context and calls factory.Shutdown()
- GetToken() is thread-safe with RLock
- handleSecretUpdate extracts Data[key], trims whitespace, updates token
- initialFetch uses lister, starts degraded if secret missing
- No token values in log statements (verified by grep)
- go test -race passes (no data race warnings)
  </done>
</task>

<task type="auto">
  <name>Write unit tests for SecretWatcher</name>
  <files>
    internal/integration/victorialogs/secret_watcher_test.go
  </files>
  <action>
Create comprehensive tests covering:

**Test 1: TestSecretWatcher_InitialFetch**
- Create fake clientset with secret pre-populated
- Start SecretWatcher, verify token loaded, IsHealthy() returns true
- Verify GetToken() returns expected value

**Test 2: TestSecretWatcher_MissingSecretAtStartup**
- Create fake clientset without secret
- Start SecretWatcher, verify starts degraded (IsHealthy() false)
- Verify GetToken() returns error

**Test 3: TestSecretWatcher_SecretRotation**
- Create fake clientset with initial secret
- Start SecretWatcher, verify initial token loaded
- Update secret with new token value
- Wait for event (use time.Sleep(100ms) or retry loop)
- Verify GetToken() returns new token
- Verify logs contain "Token rotated"

**Test 4: TestSecretWatcher_MissingKey**
- Create secret with Data["wrong-key"]
- Start SecretWatcher expecting Data["api-token"]
- Verify starts degraded, logs contain "available keys"

**Test 5: TestSecretWatcher_EmptyToken**
- Create secret with Data["api-token"] = "   \n  " (whitespace only)
- Start SecretWatcher
- Verify starts degraded, GetToken() returns error

**Test 6: TestSecretWatcher_SecretDeleted**
- Create fake clientset with secret
- Start SecretWatcher, verify healthy
- Delete secret via fake clientset
- Wait for event
- Verify IsHealthy() returns false

**Test 7: TestSecretWatcher_ConcurrentReads**
- Start SecretWatcher with token
- Launch 100 goroutines calling GetToken() concurrently
- Rotate secret mid-way (trigger Update event)
- Verify no panics, no race conditions (run with -race)

**Test 8: TestSecretWatcher_StopCleansUpGoroutines**
- Use goleak.VerifyNone(t) (if available) or manual goroutine count
- Start SecretWatcher, then Stop()
- Verify no goroutine leaks

Use k8s.io/client-go/kubernetes/fake for fake clientset.
Use corev1.Secret for test fixtures.
  </action>
  <verify>
go test -v -race ./internal/integration/victorialogs/ -run TestSecretWatcher
  </verify>
  <done>
- 8 test cases covering initial fetch, missing secrets, rotation, key errors, empty tokens, deletion, concurrency, cleanup
- All tests pass with -race flag (no data races)
- Tests use fake clientset (no real Kubernetes cluster required)
- Test coverage >80% for secret_watcher.go (verify with: go test -cover)
  </done>
</task>

</tasks>

<verification>
- [ ] go build succeeds for internal/integration/victorialogs/
- [ ] go test -race passes with no data race warnings
- [ ] SecretWatcher.GetToken() is thread-safe (verified by concurrent test)
- [ ] Informer factory scoped to namespace (not cluster-wide)
- [ ] Token values never logged (grep "token.*%s" returns no matches in secret_watcher.go)
- [ ] Stop() prevents goroutine leaks (verified by goleak or manual count)
- [ ] initialFetch() starts degraded if secret missing (not fail startup)
- [ ] handleSecretUpdate trims whitespace (test with "token\n" fixture)
</verification>

<success_criteria>
**SecretWatcher operational:**
- Creates Kubernetes clientset with in-cluster config
- Watches secrets in specified namespace via SharedInformerFactory
- Fetches token at startup (or starts degraded if missing)
- Detects secret updates/deletions via Watch API
- GetToken() is thread-safe with RWMutex
- IsHealthy() reflects token availability
- Stop() cleans up goroutines
- Token values never appear in logs
- Tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/11-secret-file-management/11-01-SUMMARY.md`
</output>
