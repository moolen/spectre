---
phase: 11-secret-file-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/victorialogs/types.go
autonomous: true

must_haves:
  truths:
    - "Config struct has SecretRef field for secret name and key"
    - "Config validation rejects configs with both url-embedded token and SecretRef"
    - "Config can be instantiated with either static token or SecretRef (mutually exclusive)"
  artifacts:
    - path: "internal/integration/victorialogs/types.go"
      provides: "SecretRef struct and updated Config"
      contains: "type SecretRef struct"
  key_links:
    - from: "types.go"
      to: "NewVictoriaLogsIntegration factory"
      via: "Config parsing validates SecretRef"
      pattern: "SecretRef.*SecretName"
---

<objective>
Extend VictoriaLogs Config type to support Kubernetes Secret references for API token storage.

Purpose: Enable integration config to specify secret-based authentication instead of hardcoded tokens in config files.

Output: Updated Config struct with SecretRef field and validation logic for mutually exclusive authentication methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-v1.2.md
@.planning/STATE.md
@.planning/phases/11-secret-file-management/11-CONTEXT.md
@.planning/phases/11-secret-file-management/11-RESEARCH.md

# Existing config structure
@internal/integration/victorialogs/types.go
@internal/integration/victorialogs/victorialogs.go
</context>

<tasks>

<task type="auto">
  <name>Add SecretRef to Config types</name>
  <files>
    internal/integration/victorialogs/types.go
  </files>
  <action>
Add SecretRef struct and update Config to support secret-based authentication:

**Add SecretRef type (new struct):**
```go
// SecretRef references a Kubernetes Secret for sensitive values
type SecretRef struct {
    // SecretName is the name of the Kubernetes Secret in the same namespace as Spectre
    SecretName string `json:"secretName" yaml:"secretName"`

    // Key is the key within the Secret's Data map
    Key string `json:"key" yaml:"key"`
}
```

**Update existing Config struct:**
Find the existing Config struct (likely has URL field already) and add:
```go
// APITokenRef references a Kubernetes Secret containing the API token
// Mutually exclusive with embedding token in URL
APITokenRef *SecretRef `json:"apiTokenRef,omitempty" yaml:"apiTokenRef,omitempty"`
```

**Add validation method (new method):**
```go
// Validate checks config for common errors
func (c *Config) Validate() error {
    if c.URL == "" {
        return fmt.Errorf("url is required")
    }

    // Check for mutually exclusive auth methods
    urlHasToken := strings.Contains(c.URL, "@") // Basic auth pattern
    hasSecretRef := c.APITokenRef != nil && c.APITokenRef.SecretName != ""

    if urlHasToken && hasSecretRef {
        return fmt.Errorf("cannot specify both URL-embedded credentials and apiTokenRef")
    }

    // Validate SecretRef if present
    if hasSecretRef {
        if c.APITokenRef.Key == "" {
            return fmt.Errorf("apiTokenRef.key is required when apiTokenRef is specified")
        }
    }

    return nil
}
```

**Add helper method:**
```go
// UsesSecretRef returns true if config uses Kubernetes Secret for authentication
func (c *Config) UsesSecretRef() bool {
    return c.APITokenRef != nil && c.APITokenRef.SecretName != ""
}
```

**Important notes:**
- DO NOT add url-embedded token support in this phase (Logz.io uses bearer tokens, not basic auth)
- The urlHasToken check is defensive - VictoriaLogs might use basic auth via URL
- Keep SecretRef optional (pointer type) for backward compatibility
- Namespace is NOT in SecretRef - secret is always in same namespace as Spectre (from 11-CONTEXT.md decision)
- Use json and yaml struct tags for config file parsing

Add imports if needed:
- fmt, strings (for validation)
  </action>
  <verify>
go build ./internal/integration/victorialogs/
go test ./internal/integration/victorialogs/ -run TestConfig
  </verify>
  <done>
- SecretRef struct defined with SecretName and Key fields
- Config.APITokenRef field added (pointer type, optional)
- Validate() method checks mutual exclusivity and required fields
- UsesSecretRef() helper method exists
- go build succeeds
- Struct tags present for json/yaml parsing
  </done>
</task>

<task type="auto">
  <name>Write unit tests for Config validation</name>
  <files>
    internal/integration/victorialogs/types_test.go
  </files>
  <action>
Create or update types_test.go with validation tests:

**Test 1: TestConfig_ValidateURLOnly**
- Config with just URL (no APITokenRef)
- Validate() returns nil (valid)

**Test 2: TestConfig_ValidateSecretRefOnly**
- Config with URL and APITokenRef (secretName="my-secret", key="token")
- Validate() returns nil (valid)

**Test 3: TestConfig_ValidateMissingURL**
- Config with APITokenRef but no URL
- Validate() returns error "url is required"

**Test 4: TestConfig_ValidateMissingSecretKey**
- Config with APITokenRef.SecretName but empty Key
- Validate() returns error containing "key is required"

**Test 5: TestConfig_ValidateMutualExclusion**
- Config with both URL containing "@" and APITokenRef
- Validate() returns error containing "cannot specify both"

**Test 6: TestConfig_UsesSecretRef**
- Config without APITokenRef: UsesSecretRef() returns false
- Config with nil APITokenRef: UsesSecretRef() returns false
- Config with APITokenRef.SecretName="": UsesSecretRef() returns false
- Config with valid APITokenRef: UsesSecretRef() returns true

**Test structure:**
```go
func TestConfig_Validate(t *testing.T) {
    tests := []struct {
        name    string
        config  Config
        wantErr bool
        errContains string
    }{
        {
            name: "valid URL only",
            config: Config{URL: "http://victorialogs:9428"},
            wantErr: false,
        },
        {
            name: "valid secret ref",
            config: Config{
                URL: "http://victorialogs:9428",
                APITokenRef: &SecretRef{
                    SecretName: "my-secret",
                    Key: "token",
                },
            },
            wantErr: false,
        },
        // ... more test cases
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.config.Validate()
            if tt.wantErr && err == nil {
                t.Errorf("expected error but got nil")
            }
            if !tt.wantErr && err != nil {
                t.Errorf("unexpected error: %v", err)
            }
            if tt.errContains != "" && !strings.Contains(err.Error(), tt.errContains) {
                t.Errorf("error should contain %q, got: %v", tt.errContains, err)
            }
        })
    }
}
```
  </action>
  <verify>
go test -v ./internal/integration/victorialogs/ -run TestConfig
  </verify>
  <done>
- types_test.go exists with 6 test cases
- Tests cover valid configs, missing fields, mutual exclusion, UsesSecretRef()
- All tests pass
- Test coverage for types.go validation logic >90%
  </done>
</task>

</tasks>

<verification>
- [ ] SecretRef struct defined with SecretName and Key fields
- [ ] Config.APITokenRef field exists (pointer type)
- [ ] Validate() method exists and checks mutual exclusivity
- [ ] UsesSecretRef() helper method exists
- [ ] go build succeeds
- [ ] go test passes with all validation test cases
- [ ] Struct tags present for json/yaml parsing
</verification>

<success_criteria>
**Config types extended:**
- SecretRef struct defined with secretName and key fields
- Config has optional APITokenRef field
- Validate() enforces mutual exclusivity (URL-embedded vs SecretRef)
- UsesSecretRef() helper identifies secret-based configs
- Tests verify validation logic
- Backward compatible (existing configs with just URL still work)
</success_criteria>

<output>
After completion, create `.planning/phases/11-secret-file-management/11-02-SUMMARY.md`
</output>
