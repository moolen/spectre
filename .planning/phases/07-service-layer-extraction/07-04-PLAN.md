---
phase: 07-service-layer-extraction
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - internal/api/metadata_service.go
  - internal/api/handlers/metadata_handler.go
autonomous: true

must_haves:
  truths:
    - "MetadataService exists with metadata query and cache integration logic"
    - "REST metadata handler uses MetadataService for business logic"
    - "Metadata endpoint behavior unchanged"
    - "MetadataCache integration preserved"
  artifacts:
    - path: "internal/api/metadata_service.go"
      provides: "Metadata service for resource metadata operations"
      min_lines: 120
      exports: ["MetadataService", "NewMetadataService"]
    - path: "internal/api/handlers/metadata_handler.go"
      provides: "Refactored handler using MetadataService"
      min_lines: 70
  key_links:
    - from: "internal/api/handlers/metadata_handler.go"
      to: "internal/api/metadata_service.go"
      via: "constructor injection"
      pattern: "metadataService\\s+\\*api\\.MetadataService"
    - from: "internal/api/metadata_service.go"
      to: "internal/api/metadata_cache.go"
      via: "cache integration"
      pattern: "metadataCache\\s+\\*MetadataCache"
---

<objective>
Create MetadataService and refactor REST metadata handler to use shared service layer.

Purpose: Complete service layer extraction, establish pattern for metadata operations
Output: Working MetadataService used by REST metadata endpoint with cache integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-service-layer-extraction/07-CONTEXT.md
@.planning/phases/07-service-layer-extraction/07-RESEARCH.md

# Key files
@internal/api/handlers/metadata_handler.go
@internal/api/metadata_cache.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetadataService with query and cache integration</name>
  <files>internal/api/metadata_service.go</files>
  <action>
Create new internal/api/metadata_service.go with metadata operations:

1. Define MetadataService struct:
   - Fields: queryExecutor QueryExecutor (with MetadataQueryExecutor interface), metadataCache *MetadataCache, logger *logging.Logger, tracer trace.Tracer

2. Add NewMetadataService constructor:
   - Accept queryExecutor QueryExecutor, metadataCache *MetadataCache, logger, tracer
   - Return *MetadataService
   - MetadataCache is optional (can be nil for non-cached mode)

3. Add GetMetadata method:
   - Signature: GetMetadata(ctx context.Context, useCache bool) (*MetadataResponse, error)
   - If useCache && metadataCache != nil: return cached data via metadataCache.Get()
   - Otherwise: execute fresh metadata query
   - Add tracing span: s.tracer.Start(ctx, "metadata.get")
   - Return MetadataResponse (define struct with Namespaces, Kinds, TimeRange)

4. Add QueryDistinctMetadata method:
   - Signature: QueryDistinctMetadata(ctx context.Context, startTimeNs, endTimeNs int64) (*models.QueryResult, error)
   - Delegate to queryExecutor with optimized metadata query
   - Extract logic from metadata_handler.go (line 86 uses mh.queryExecutor.QueryDistinctMetadata)
   - Add tracing span
   - Return raw query result

5. Add BuildMetadataResponse method:
   - Signature: BuildMetadataResponse(result *models.QueryResult) (*MetadataResponse, error)
   - Extract logic from metadata_handler.go (lines 108-156)
   - Extract unique namespaces and kinds from result
   - Calculate time range (earliest/latest timestamps)
   - Return structured MetadataResponse

6. Add observability:
   - Span attributes: cache hit/miss, namespace count, kind count
   - Debug logging for metadata queries

Pattern: MetadataService encapsulates both direct queries and cache integration.

Note: MetadataCache already exists in internal/api/metadata_cache.go - integrate it, don't reimplement.
  </action>
  <verify>
go build -v ./internal/api/metadata_service.go
grep -q "GetMetadata" internal/api/metadata_service.go
grep -q "QueryDistinctMetadata" internal/api/metadata_service.go
grep -q "BuildMetadataResponse" internal/api/metadata_service.go
  </verify>
  <done>MetadataService exists with metadata query, cache integration, and response building methods</done>
</task>

<task type="auto">
  <name>Task 2: Refactor REST metadata handler to use MetadataService</name>
  <files>internal/api/handlers/metadata_handler.go</files>
  <action>
Refactor metadata_handler.go to delegate to MetadataService:

1. Update MetadataHandler struct:
   - Replace queryExecutor and metadataCache fields
   - Add single field: metadataService *api.MetadataService
   - Keep logger, tracer for HTTP-specific concerns

2. Update NewMetadataHandler constructor:
   - Accept metadataService *api.MetadataService instead of queryExecutor and cache
   - Store service reference

3. Refactor ServeHTTP method:
   - Parse useCache query parameter from request
   - Call metadataService.GetMetadata(ctx, useCache)
   - Write JSON response with http.ResponseWriter
   - Map service errors to HTTP status codes

4. Remove inline business logic:
   - Delete direct cache access (line 67: mh.metadataCache.Get())
   - Delete direct query executor usage (line 101: mh.queryExecutor.Execute)
   - Delete metadata extraction logic (lines 108-156 moved to service)

5. Update handler registration:
   - In internal/api/handlers/register.go, pass metadataService to NewMetadataHandler

Pattern: Handler becomes thin HTTP adapter over MetadataService.

Note: Preserve existing cache behavior - service should use cache when useCache=true.
  </action>
  <verify>
go build -v ./internal/api/handlers/metadata_handler.go
grep -v "mh.queryExecutor.Execute" internal/api/handlers/metadata_handler.go
grep -v "mh.metadataCache.Get" internal/api/handlers/metadata_handler.go
go build -v ./cmd/spectre
  </verify>
  <done>Metadata handler uses MetadataService for all business logic, cache integration preserved, handler focused on HTTP concerns only</done>
</task>

</tasks>

<verification>
# Overall phase checks
1. MetadataService compiles: `go build ./internal/api/metadata_service.go`
2. Metadata handler compiles: `go build ./internal/api/handlers/metadata_handler.go`
3. Server compiles: `go build ./cmd/spectre`
4. Handler uses metadataService field: `grep "metadataService" internal/api/handlers/metadata_handler.go`
</verification>

<success_criteria>
1. MetadataService exists with GetMetadata, QueryDistinctMetadata, BuildMetadataResponse methods
2. REST metadata handler delegates all business logic to MetadataService
3. Metadata cache integration preserved (useCache parameter respected)
4. Metadata endpoint behavior unchanged
5. Server compiles with MetadataService wiring
</success_criteria>

<output>
After completion, create `.planning/phases/07-service-layer-extraction/07-04-SUMMARY.md`
</output>
