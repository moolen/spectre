---
phase: 07-service-layer-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/api/timeline_service.go
  - internal/api/handlers/timeline_handler.go
  - internal/mcp/tools/resource_timeline.go
  - internal/mcp/tools/cluster_health.go
  - internal/mcp/server.go
autonomous: true

must_haves:
  truths:
    - "TimelineService has all query and response building logic extracted from handlers"
    - "REST timeline handler uses TimelineService for all business logic"
    - "MCP resource_timeline tool calls TimelineService directly (no HTTP)"
    - "MCP cluster_health tool calls TimelineService directly (no HTTP)"
    - "Existing timeline endpoint behavior unchanged"
  artifacts:
    - path: "internal/api/timeline_service.go"
      provides: "Complete timeline service with query building and response transformation"
      min_lines: 200
      exports: ["TimelineService", "NewTimelineService"]
    - path: "internal/api/handlers/timeline_handler.go"
      provides: "Refactored handler using TimelineService"
      min_lines: 100
    - path: "internal/mcp/tools/resource_timeline.go"
      provides: "MCP tool using TimelineService"
      min_lines: 120
    - path: "internal/mcp/tools/cluster_health.go"
      provides: "MCP tool using TimelineService"
      min_lines: 130
  key_links:
    - from: "internal/api/handlers/timeline_handler.go"
      to: "internal/api/timeline_service.go"
      via: "constructor injection"
      pattern: "timelineService\\s+\\*api\\.TimelineService"
    - from: "internal/mcp/tools/resource_timeline.go"
      to: "internal/api/timeline_service.go"
      via: "constructor injection"
      pattern: "timelineService\\s+\\*api\\.TimelineService"
    - from: "internal/mcp/tools/cluster_health.go"
      to: "internal/api/timeline_service.go"
      via: "constructor injection"
      pattern: "timelineService\\s+\\*api\\.TimelineService"
---

<objective>
Complete TimelineService extraction and wire both REST handlers and MCP tools to use shared service layer.

Purpose: Eliminate MCP tool HTTP self-calls for timeline operations, establish shared service pattern
Output: Working TimelineService used by REST and MCP, no localhost HTTP calls for timeline queries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-service-layer-extraction/07-CONTEXT.md
@.planning/phases/07-service-layer-extraction/07-RESEARCH.md

# Key files
@internal/api/timeline_service.go
@internal/api/handlers/timeline_handler.go
@internal/mcp/tools/resource_timeline.go
@internal/mcp/tools/cluster_health.go
@internal/mcp/client/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete TimelineService with all handler business logic</name>
  <files>internal/api/timeline_service.go</files>
  <action>
TimelineService already has ExecuteConcurrentQueries and BuildTimelineResponse methods. Add remaining business logic from timeline_handler.go:

1. Add ParseQueryParameters method:
   - Extract query parameter parsing from handler (lines 444-493 in timeline_handler.go)
   - Takes start/end time strings, filter maps
   - Returns *models.QueryRequest with validated timestamps and filters
   - Use existing api.ParseTimestamp for time parsing

2. Add ParsePagination method:
   - Extract pagination parsing from handler (lines 507-517)
   - Takes pageSize param, maxPageSize constant
   - Returns validated pageSize int

3. Ensure BuildTimelineResponse is public and comprehensive:
   - Should already exist (verified in research)
   - Transforms queryResult + eventResult into timeline format
   - Includes status segment inference logic

4. Add proper error handling:
   - Return domain error types (ValidationError, not HTTP errors)
   - Let callers map to transport-specific codes

5. Add observability:
   - OpenTelemetry spans for ParseQueryParameters, ExecuteConcurrentQueries
   - Use s.tracer.Start(ctx, "timeline.methodName")
   - Log query parameters at debug level

Keep all existing methods (NewTimelineService, NewTimelineServiceWithMode, GetActiveExecutor, ResourceToProto).

DO NOT import net/http or return http.Response types. Service operates on domain models only.
  </action>
  <verify>
go build -v ./internal/api/timeline_service.go
grep -q "ParseQueryParameters" internal/api/timeline_service.go
grep -q "ParsePagination" internal/api/timeline_service.go
  </verify>
  <done>TimelineService has all methods needed for REST handlers and MCP tools, compiles without HTTP dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Refactor REST timeline handler to use TimelineService</name>
  <files>internal/api/handlers/timeline_handler.go</files>
  <action>
Refactor timeline_handler.go to delegate all business logic to TimelineService:

1. Update TimelineHandler struct:
   - Replace storageExecutor, graphExecutor, querySource fields
   - Add single field: timelineService *api.TimelineService
   - Keep logger, tracer (for HTTP-specific tracing)

2. Update NewTimelineHandler constructor:
   - Accept timelineService *api.TimelineService instead of queryExecutor
   - Store service reference

3. Refactor ServeHTTP method:
   - Use timelineService.ParseQueryParameters(start, end, filters)
   - Use timelineService.ParsePagination(pageSizeParam)
   - Use timelineService.ExecuteConcurrentQueries(ctx, query)
   - Use timelineService.BuildTimelineResponse(queryResult, eventResult)
   - Keep HTTP-specific logic: request parsing, response writing, status codes
   - Map service domain errors to HTTP status (ValidationError -> 400)

4. Remove inline business logic:
   - Delete query building code (moved to service)
   - Delete pagination validation (moved to service)
   - Delete response transformation (moved to service)

5. Maintain existing tests:
   - Run timeline_handler_concurrent_test.go to verify behavior unchanged
   - Tests should still pass with service layer

Pattern: Handler becomes thin HTTP adapter over TimelineService.
  </action>
  <verify>
go test -v ./internal/api/handlers/timeline_handler_concurrent_test.go
go build -v ./internal/api/handlers/timeline_handler.go
  </verify>
  <done>Timeline handler uses TimelineService for all business logic, tests pass, handler focused only on HTTP concerns</done>
</task>

<task type="auto">
  <name>Task 3: Wire MCP tools to use TimelineService directly</name>
  <files>
internal/mcp/tools/resource_timeline.go
internal/mcp/tools/cluster_health.go
internal/mcp/server.go
  </files>
  <action>
Replace HTTP client calls with direct TimelineService usage in MCP tools:

**For resource_timeline.go:**
1. Update ResourceTimelineTool struct:
   - Remove client field (*client.Client)
   - Add timelineService field (*api.TimelineService)

2. Update NewResourceTimelineTool constructor:
   - Accept timelineService *api.TimelineService instead of client
   - Store service reference

3. Refactor Execute method (line 118 uses client.QueryTimeline):
   - Build *models.QueryRequest from input params
   - Call timelineService.ExecuteConcurrentQueries(ctx, query)
   - Call timelineService.BuildTimelineResponse(queryResult, eventResult)
   - Transform response to MCP tool output format
   - Remove HTTP client call

**For cluster_health.go:**
1. Update ClusterHealthTool struct:
   - Remove client field
   - Add timelineService field (*api.TimelineService)

2. Update NewClusterHealthTool constructor:
   - Accept timelineService instead of client

3. Refactor Execute method (line 122 uses client.QueryTimeline):
   - Build query for recent resources (last 5 minutes)
   - Call timelineService.ExecuteConcurrentQueries(ctx, query)
   - Process results to identify unhealthy resources
   - Remove HTTP client call

**Update internal/mcp/server.go:**
1. In InitializeTools method:
   - Pass timelineService to NewResourceTimelineTool
   - Pass timelineService to NewClusterHealthTool
   - TimelineService should already be available from server initialization (Phase 6)

DO NOT delete internal/mcp/client/client.go yet (other tools still use it - will be deleted in Plan 5).
  </action>
  <verify>
go build -v ./internal/mcp/tools/resource_timeline.go
go build -v ./internal/mcp/tools/cluster_health.go
go build -v ./internal/mcp/server.go
grep -v "client.QueryTimeline" internal/mcp/tools/resource_timeline.go
grep -v "client.QueryTimeline" internal/mcp/tools/cluster_health.go
  </verify>
  <done>MCP tools use TimelineService directly, no HTTP self-calls for timeline operations, tools compile and initialize correctly</done>
</task>

</tasks>

<verification>
# Overall phase checks
1. TimelineService compiles independently: `go build ./internal/api/timeline_service.go`
2. Timeline handler tests pass: `go test ./internal/api/handlers/timeline_handler_concurrent_test.go`
3. MCP tools compile: `go build ./internal/mcp/tools/...`
4. No HTTP client imports in timeline tools: `grep -r "internal/mcp/client" internal/mcp/tools/resource_timeline.go internal/mcp/tools/cluster_health.go` returns empty
5. Server compiles with new wiring: `go build ./cmd/spectre`
</verification>

<success_criteria>
1. TimelineService has ParseQueryParameters, ParsePagination, ExecuteConcurrentQueries, BuildTimelineResponse methods
2. Timeline REST handler delegates all business logic to TimelineService
3. MCP resource_timeline and cluster_health tools call TimelineService directly (no HTTP)
4. All timeline-related tests pass
5. Server compiles and initializes with new service wiring
</success_criteria>

<output>
After completion, create `.planning/phases/07-service-layer-extraction/07-01-SUMMARY.md`
</output>
