---
phase: 07-service-layer-extraction
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - internal/api/search_service.go
  - internal/api/handlers/search_handler.go
autonomous: true

must_haves:
  truths:
    - "SearchService exists with query parsing and result transformation logic"
    - "REST search handler uses SearchService for business logic"
    - "Search endpoint behavior unchanged"
  artifacts:
    - path: "internal/api/search_service.go"
      provides: "Search service for unified search operations"
      min_lines: 100
      exports: ["SearchService", "NewSearchService"]
    - path: "internal/api/handlers/search_handler.go"
      provides: "Refactored handler using SearchService"
      min_lines: 60
  key_links:
    - from: "internal/api/handlers/search_handler.go"
      to: "internal/api/search_service.go"
      via: "constructor injection"
      pattern: "searchService\\s+\\*api\\.SearchService"
---

<objective>
Create SearchService and refactor REST search handler to use shared service layer.

Purpose: Extract search business logic for future MCP tool reuse, complete service layer pattern
Output: Working SearchService used by REST search endpoint
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-service-layer-extraction/07-CONTEXT.md
@.planning/phases/07-service-layer-extraction/07-RESEARCH.md

# Key files
@internal/api/handlers/search_handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchService with query and result transformation</name>
  <files>internal/api/search_service.go</files>
  <action>
Create new internal/api/search_service.go with search operations:

1. Define SearchService struct:
   - Fields: queryExecutor QueryExecutor, logger *logging.Logger, tracer trace.Tracer, validator *Validator

2. Add NewSearchService constructor:
   - Accept queryExecutor QueryExecutor, logger, tracer
   - Initialize validator: NewValidator()
   - Return *SearchService

3. Add ParseSearchQuery method:
   - Signature: ParseSearchQuery(q string, start, end string, filters map[string]string) (*models.QueryRequest, error)
   - Extract logic from search_handler.go parseQuery method (lines 88-133)
   - Validate query string is not empty
   - Parse timestamps using api.ParseTimestamp
   - Build filters from query parameters
   - Return *models.QueryRequest or ValidationError

4. Add ExecuteSearch method:
   - Signature: ExecuteSearch(ctx context.Context, query *models.QueryRequest) (*models.QueryResult, error)
   - Add tracing span: s.tracer.Start(ctx, "search.execute")
   - Call s.queryExecutor.Execute(ctx, query)
   - Log query execution (query string, time range) at debug level
   - Return result or wrapped error

5. Add BuildSearchResponse method:
   - Signature: BuildSearchResponse(result *models.QueryResult) (*SearchResponse, error)
   - Extract logic from search_handler.go buildSearchResponse (lines 59-86)
   - Groups events by resource UID
   - Transform QueryResult into SearchResponse structure
   - Return SearchResponse (define as simple struct with Resources []ResourceWithEvents)

6. Add observability:
   - Span attributes: query string, result count
   - Error recording on failures
   - Debug logging for query parameters

Pattern: SearchService follows TimelineService pattern - parse, execute, transform.

Note: Research mentions TODO for "Reimplement ResourceBuilder functionality" but defer to future. Keep current simple grouping logic.
  </action>
  <verify>
go build -v ./internal/api/search_service.go
grep -q "ParseSearchQuery" internal/api/search_service.go
grep -q "ExecuteSearch" internal/api/search_service.go
grep -q "BuildSearchResponse" internal/api/search_service.go
  </verify>
  <done>SearchService exists with query parsing, execution, and response building methods</done>
</task>

<task type="auto">
  <name>Task 2: Refactor REST search handler to use SearchService</name>
  <files>internal/api/handlers/search_handler.go</files>
  <action>
Refactor search_handler.go to delegate to SearchService:

1. Update SearchHandler struct:
   - Replace queryExecutor field with searchService *api.SearchService
   - Keep logger, tracer for HTTP-specific concerns

2. Update NewSearchHandler constructor:
   - Accept searchService *api.SearchService instead of queryExecutor
   - Store service reference

3. Refactor ServeHTTP method:
   - Extract query params from request (q, start, end, filters)
   - Call searchService.ParseSearchQuery(q, start, end, filters)
   - Call searchService.ExecuteSearch(ctx, query)
   - Call searchService.BuildSearchResponse(result)
   - Write JSON response with http.ResponseWriter
   - Map service errors to HTTP status codes (ValidationError -> 400, others -> 500)

4. Remove inline business logic:
   - Delete parseQuery method (moved to service)
   - Delete buildSearchResponse method (moved to service)
   - Delete query execution logic (moved to service)

5. Update handler registration:
   - In internal/api/handlers/register.go, pass searchService to NewSearchHandler

Pattern: Handler becomes thin HTTP adapter over SearchService.
  </action>
  <verify>
go build -v ./internal/api/handlers/search_handler.go
grep -v "sh.queryExecutor.Execute" internal/api/handlers/search_handler.go
go build -v ./cmd/spectre
  </verify>
  <done>Search handler uses SearchService for all business logic, handler focused on HTTP concerns only</done>
</task>

</tasks>

<verification>
# Overall phase checks
1. SearchService compiles: `go build ./internal/api/search_service.go`
2. Search handler compiles: `go build ./internal/api/handlers/search_handler.go`
3. Server compiles: `go build ./cmd/spectre`
4. Search handler uses searchService field: `grep "searchService" internal/api/handlers/search_handler.go`
</verification>

<success_criteria>
1. SearchService exists with ParseSearchQuery, ExecuteSearch, BuildSearchResponse methods
2. REST search handler delegates all business logic to SearchService
3. Search endpoint behavior unchanged (same query syntax, response format)
4. Server compiles with SearchService wiring
</success_criteria>

<output>
After completion, create `.planning/phases/07-service-layer-extraction/07-03-SUMMARY.md`
</output>
