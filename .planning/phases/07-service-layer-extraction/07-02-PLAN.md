---
phase: 07-service-layer-extraction
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/api/graph_service.go
  - internal/api/handlers/causal_paths_handler.go
  - internal/api/handlers/anomaly_handler.go
  - internal/api/handlers/namespace_graph_handler.go
  - internal/mcp/tools/causal_paths.go
  - internal/mcp/tools/detect_anomalies.go
  - internal/mcp/server.go
autonomous: true

must_haves:
  truths:
    - "GraphService exists with methods for causal paths, anomaly detection, and namespace graph analysis"
    - "REST handlers for graph operations use GraphService for business logic"
    - "MCP causal_paths tool calls GraphService directly (no HTTP)"
    - "MCP detect_anomalies tool calls GraphService directly (no HTTP)"
    - "Graph analysis behavior unchanged"
  artifacts:
    - path: "internal/api/graph_service.go"
      provides: "Graph service encapsulating FalkorDB query operations"
      min_lines: 150
      exports: ["GraphService", "NewGraphService"]
    - path: "internal/api/handlers/causal_paths_handler.go"
      provides: "Refactored handler using GraphService"
      min_lines: 80
    - path: "internal/api/handlers/anomaly_handler.go"
      provides: "Refactored handler using GraphService"
      min_lines: 80
    - path: "internal/mcp/tools/causal_paths.go"
      provides: "MCP tool using GraphService"
      min_lines: 100
    - path: "internal/mcp/tools/detect_anomalies.go"
      provides: "MCP tool using GraphService"
      min_lines: 150
  key_links:
    - from: "internal/api/handlers/causal_paths_handler.go"
      to: "internal/api/graph_service.go"
      via: "constructor injection"
      pattern: "graphService\\s+\\*api\\.GraphService"
    - from: "internal/mcp/tools/causal_paths.go"
      to: "internal/api/graph_service.go"
      via: "constructor injection"
      pattern: "graphService\\s+\\*api\\.GraphService"
    - from: "internal/mcp/tools/detect_anomalies.go"
      to: "internal/api/graph_service.go"
      via: "constructor injection"
      pattern: "graphService\\s+\\*api\\.GraphService"
---

<objective>
Create GraphService and wire both REST handlers and MCP tools to use shared graph query operations.

Purpose: Eliminate MCP tool HTTP self-calls for graph operations, share graph analysis logic
Output: Working GraphService used by REST and MCP for causal paths, anomalies, namespace graphs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-service-layer-extraction/07-CONTEXT.md
@.planning/phases/07-service-layer-extraction/07-RESEARCH.md

# Key files
@internal/api/handlers/causal_paths_handler.go
@internal/api/handlers/anomaly_handler.go
@internal/api/handlers/namespace_graph_handler.go
@internal/mcp/tools/causal_paths.go
@internal/mcp/tools/detect_anomalies.go
@internal/analysis/causalpaths/discoverer.go
@internal/analysis/anomaly/detector.go
@internal/analysis/namespacegraph/analyzer.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphService wrapping graph analysis operations</name>
  <files>internal/api/graph_service.go</files>
  <action>
Create new internal/api/graph_service.go with shared graph analysis operations:

1. Define GraphService struct:
   - Fields: graphClient graph.Client, logger *logging.Logger, tracer trace.Tracer
   - Wraps existing analyzers: causalpaths.PathDiscoverer, anomaly.AnomalyDetector, namespacegraph.Analyzer

2. Add NewGraphService constructor:
   - Accept graphClient graph.Client, logger, tracer
   - Initialize internal analyzers (PathDiscoverer, AnomalyDetector, Analyzer)
   - Return *GraphService

3. Add DiscoverCausalPaths method:
   - Signature: DiscoverCausalPaths(ctx context.Context, input *causalpaths.Input) (*causalpaths.Output, error)
   - Delegate to pathDiscoverer.DiscoverCausalPaths(ctx, input)
   - Add tracing span: s.tracer.Start(ctx, "graph.discoverCausalPaths")
   - Return domain result (not HTTP response)

4. Add DetectAnomalies method:
   - Signature: DetectAnomalies(ctx context.Context, input *anomaly.Input) (*anomaly.Output, error)
   - Delegate to anomalyDetector.Detect(ctx, input)
   - Add tracing span: s.tracer.Start(ctx, "graph.detectAnomalies")
   - Return domain result

5. Add AnalyzeNamespaceGraph method:
   - Signature: AnalyzeNamespaceGraph(ctx context.Context, input *namespacegraph.Input) (*namespacegraph.Output, error)
   - Delegate to namespaceAnalyzer.Analyze(ctx, input)
   - Add tracing span: s.tracer.Start(ctx, "graph.analyzeNamespaceGraph")
   - Return domain result

6. Add error handling:
   - Wrap analyzer errors with context
   - Log errors at appropriate levels
   - Return domain errors (not HTTP status codes)

Pattern: GraphService is a facade over existing analysis modules (causalpaths, anomaly, namespacegraph), providing unified interface.

DO NOT reimplement graph logic - wrap existing analyzers that already work.
  </action>
  <verify>
go build -v ./internal/api/graph_service.go
grep -q "DiscoverCausalPaths" internal/api/graph_service.go
grep -q "DetectAnomalies" internal/api/graph_service.go
grep -q "AnalyzeNamespaceGraph" internal/api/graph_service.go
  </verify>
  <done>GraphService exists, wraps existing analyzers, provides unified interface for graph operations</done>
</task>

<task type="auto">
  <name>Task 2: Refactor REST graph handlers to use GraphService</name>
  <files>
internal/api/handlers/causal_paths_handler.go
internal/api/handlers/anomaly_handler.go
internal/api/handlers/namespace_graph_handler.go
  </files>
  <action>
Refactor three graph-related handlers to use GraphService:

**For causal_paths_handler.go:**
1. Update CausalPathsHandler struct:
   - Replace discoverer field with graphService *api.GraphService
2. Update NewCausalPathsHandler:
   - Accept graphService instead of graphClient
3. Refactor ServeHTTP:
   - Call graphService.DiscoverCausalPaths(ctx, input) instead of discoverer.DiscoverCausalPaths
   - Keep HTTP request parsing and response writing

**For anomaly_handler.go:**
1. Update AnomalyHandler struct:
   - Replace detector field with graphService *api.GraphService
2. Update NewAnomalyHandler:
   - Accept graphService instead of graphClient
3. Refactor ServeHTTP:
   - Call graphService.DetectAnomalies(ctx, input) instead of detector.Detect
   - Keep HTTP concerns in handler

**For namespace_graph_handler.go:**
1. Update NamespaceGraphHandler struct:
   - Replace analyzer field with graphService *api.GraphService
2. Update NewNamespaceGraphHandler:
   - Accept graphService instead of graphClient
3. Refactor ServeHTTP:
   - Call graphService.AnalyzeNamespaceGraph(ctx, input) instead of analyzer.Analyze
   - Keep HTTP concerns in handler

Update handler registration in internal/api/handlers/register.go to pass graphService to constructors.

Pattern: Handlers become thin HTTP adapters, GraphService owns business logic.
  </action>
  <verify>
go build -v ./internal/api/handlers/causal_paths_handler.go
go build -v ./internal/api/handlers/anomaly_handler.go
go build -v ./internal/api/handlers/namespace_graph_handler.go
go test -v ./internal/api/handlers/namespace_graph_handler_test.go
  </verify>
  <done>Graph handlers use GraphService, namespace graph tests pass, handlers focused on HTTP concerns only</done>
</task>

<task type="auto">
  <name>Task 3: Wire MCP tools to use GraphService directly</name>
  <files>
internal/mcp/tools/causal_paths.go
internal/mcp/tools/detect_anomalies.go
internal/mcp/server.go
  </files>
  <action>
Replace HTTP client calls with direct GraphService usage in MCP tools:

**For causal_paths.go:**
1. Update CausalPathsTool struct:
   - Remove client field
   - Add graphService field (*api.GraphService)

2. Update NewCausalPathsTool constructor:
   - Accept graphService instead of client

3. Refactor Execute method (line 77 uses client.QueryCausalPaths):
   - Build *causalpaths.Input from tool params
   - Call graphService.DiscoverCausalPaths(ctx, input)
   - Transform output to MCP response format
   - Remove HTTP client call

**For detect_anomalies.go:**
1. Update DetectAnomaliesTool struct:
   - Remove client field
   - Add graphService field (*api.GraphService)
   - Keep timelineService field (tool uses both services)

2. Update NewDetectAnomaliesTool constructor:
   - Accept graphService AND timelineService (tool uses both)

3. Refactor Execute method:
   - Line 127, 205 use client.DetectAnomalies - replace with graphService.DetectAnomalies
   - Line 152 uses client for timeline - should already use timelineService from Plan 07-01
   - Build *anomaly.Input from tool params
   - Call graphService.DetectAnomalies(ctx, input)
   - Transform output to MCP response

**Update internal/mcp/server.go:**
1. In InitializeTools:
   - Create graphService instance if not already available
   - Pass graphService to NewCausalPathsTool
   - Pass both graphService AND timelineService to NewDetectAnomaliesTool

DO NOT delete client.go yet (still used by other operations).
  </action>
  <verify>
go build -v ./internal/mcp/tools/causal_paths.go
go build -v ./internal/mcp/tools/detect_anomalies.go
go build -v ./internal/mcp/server.go
grep -v "client.QueryCausalPaths" internal/mcp/tools/causal_paths.go
grep -v "client.DetectAnomalies" internal/mcp/tools/detect_anomalies.go
  </verify>
  <done>MCP graph tools use GraphService directly, no HTTP self-calls for graph operations, tools compile correctly</done>
</task>

</tasks>

<verification>
# Overall phase checks
1. GraphService compiles: `go build ./internal/api/graph_service.go`
2. Graph handlers compile: `go build ./internal/api/handlers/{causal_paths,anomaly,namespace_graph}_handler.go`
3. Namespace graph tests pass: `go test ./internal/api/handlers/namespace_graph_handler_test.go`
4. MCP graph tools compile: `go build ./internal/mcp/tools/{causal_paths,detect_anomalies}.go`
5. Server compiles: `go build ./cmd/spectre`
</verification>

<success_criteria>
1. GraphService exists with DiscoverCausalPaths, DetectAnomalies, AnalyzeNamespaceGraph methods
2. REST graph handlers delegate to GraphService
3. MCP causal_paths and detect_anomalies tools call GraphService directly (no HTTP)
4. All graph-related tests pass
5. Server compiles with GraphService wiring
</success_criteria>

<output>
After completion, create `.planning/phases/07-service-layer-extraction/07-02-SUMMARY.md`
</output>
