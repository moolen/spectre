---
phase: 15-foundation
plan: 03
type: execute
wave: 2
depends_on: [15-01, 15-02]
files_modified:
  - ui/src/components/IntegrationConfigForm.tsx
  - internal/api/handlers/integration_config_handler.go
autonomous: true

must_haves:
  truths:
    - "User can select Grafana integration type in UI dropdown"
    - "Grafana form displays URL field and SecretRef fields (secret name + key)"
    - "Form validates connection on save with health check"
    - "Test connection validates both dashboard and datasource access"
    - "Health check errors display inline in form with detailed messages"
  artifacts:
    - path: "ui/src/components/IntegrationConfigForm.tsx"
      provides: "Grafana integration form fields"
      contains: "grafana.*url.*secretName.*key"
    - path: "internal/api/handlers/integration_config_handler.go"
      provides: "Grafana test connection handler"
      contains: "case.*grafana.*testConnection"
  key_links:
    - from: "ui/src/components/IntegrationConfigForm.tsx"
      to: "POST /api/integrations/test"
      via: "Test connection button triggers API call"
      pattern: "fetch.*integrations/test"
    - from: "internal/api/handlers/integration_config_handler.go"
      to: "internal/integration/grafana"
      via: "Factory creates Grafana instance for testing"
      pattern: "GetFactory.*grafana"
---

<objective>
Add Grafana configuration form to UI and wire test connection handler in backend, completing the integration configuration flow from UI to health check validation.

Purpose: Enable users to configure Grafana integrations via UI with immediate connection validation. Closes the loop on Phase 15 foundation work.

Output: Users can add Grafana integration via UI form, test connection validates both dashboard and datasource access, and helpful error messages guide troubleshooting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/15-foundation/15-CONTEXT.md
@.planning/phases/15-foundation/15-RESEARCH.md

# UI form pattern
@ui/src/components/IntegrationConfigForm.tsx

# Backend test handler pattern
@internal/api/handlers/integration_config_handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Grafana Form Fields to IntegrationConfigForm</name>
  <files>ui/src/components/IntegrationConfigForm.tsx</files>
  <action>
Add Grafana type support to IntegrationConfigForm following Logz.io pattern:

1. **Add "grafana" to type dropdown** options (alongside "victorialogs" and "logzio")

2. **Add Grafana-specific form section** (similar to Logz.io region selector):
   ```tsx
   {config.type === 'grafana' && (
     <>
       {/* Grafana URL Field */}
       <div style={{ marginBottom: '20px' }}>
         <label>Grafana URL</label>
         <input
           type="text"
           value={config.config.url || ''}
           onChange={handleGrafanaUrlChange}
           placeholder="https://myorg.grafana.net or https://grafana.internal:3000"
         />
         <small style={{ color: 'var(--color-text-secondary)' }}>
           Full base URL (Cloud or self-hosted)
         </small>
       </div>

       {/* Authentication Section (SecretRef) */}
       <div style={{
         marginBottom: '20px',
         padding: '16px',
         borderRadius: '8px',
         border: '1px solid var(--color-border-soft)',
         backgroundColor: 'var(--color-surface-muted)',
       }}>
         <h4>Authentication</h4>

         {/* Secret Name */}
         <label>Secret Name</label>
         <input
           value={config.config.apiTokenRef?.secretName || ''}
           onChange={handleSecretNameChange}
           placeholder="grafana-token"
         />

         {/* Secret Key */}
         <label>Secret Key</label>
         <input
           value={config.config.apiTokenRef?.key || ''}
           onChange={handleSecretKeyChange}
           placeholder="api-token"
         />
       </div>
     </>
   )}
   ```

3. **Add handler functions:**
   ```tsx
   const handleGrafanaUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     onChange({
       ...config,
       config: { ...config.config, url: e.target.value },
     });
   };

   const handleSecretNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     onChange({
       ...config,
       config: {
         ...config.config,
         apiTokenRef: {
           ...config.config.apiTokenRef,
           secretName: e.target.value,
         },
       },
     });
   };

   const handleSecretKeyChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     onChange({
       ...config,
       config: {
         ...config.config,
         apiTokenRef: {
           ...config.config.apiTokenRef,
           key: e.target.value,
         },
       },
     });
   };
   ```

**Follow research guidance:** Minimal form fields (name, URL, API token only - no description). Full base URL required (no Cloud shorthand).

**Visual grouping:** Authentication section has border and background like Logz.io pattern.

**Placeholder examples:** Show both Cloud and self-hosted URL patterns.
  </action>
  <verify>
grep -q "grafana" ui/src/components/IntegrationConfigForm.tsx
grep -q "Grafana URL" ui/src/components/IntegrationConfigForm.tsx
grep -q "apiTokenRef" ui/src/components/IntegrationConfigForm.tsx
  </verify>
  <done>Grafana form fields exist in UI with URL and SecretRef inputs, following Logz.io visual pattern</done>
</task>

<task type="auto">
  <name>Task 2: Add Grafana Test Connection Handler</name>
  <files>internal/api/handlers/integration_config_handler.go</files>
  <action>
Add Grafana case to testConnection method in IntegrationConfigHandler:

1. **Find testConnection method** - locate switch statement on integration type

2. **Add Grafana case** (follow VictoriaLogs/Logz.io pattern):
   ```go
   case "grafana":
       // Marshal config to Grafana Config struct
       var grafanaConfig grafana.Config
       configBytes, _ := json.Marshal(testReq.Config)
       if err := json.Unmarshal(configBytes, &grafanaConfig); err != nil {
           return false, fmt.Sprintf("Invalid Grafana config: %v", err)
       }

       // Get Grafana factory
       factory, err := integration.GetFactory("grafana")
       if err != nil {
           return false, fmt.Sprintf("Grafana integration not available: %v", err)
       }

       // Test connection using factory
       return h.testConnection(factory, testReq)
   ```

3. **Import Grafana package:** Add `"internal/integration/grafana"` to imports

4. **Verify testConnection helper** handles Grafana integration lifecycle:
   - Creates instance via factory
   - Calls Start() with timeout (5 seconds)
   - Checks Health() status
   - Calls Stop() to clean up
   - Returns success/failure with message

**Error messages:** Research shows detailed errors are important - HTTP status, Grafana error message, specific failure reason. The existing testConnection helper should surface these from Health() status.

**Health check strategy:** Grafana integration's testConnection() validates both dashboard read AND datasource access (warns if datasource fails, but allows save).
  </action>
  <verify>
grep -q "case.*grafana" internal/api/handlers/integration_config_handler.go
grep -q "grafana.Config" internal/api/handlers/integration_config_handler.go
  </verify>
  <done>Grafana test connection handler validates connection via factory pattern, returns detailed error messages on failure</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **UI compiles:** `cd ui && npm run build`
2. **Backend compiles:** `go build ./internal/api/handlers/...`
3. **Form renders:** Grafana type shows URL and SecretRef fields
4. **Test handler exists:** Switch case for "grafana" in testConnection method
5. **End-to-end flow:** User selects Grafana type → fills form → clicks test → backend validates connection → returns success/error
</verification>

<success_criteria>
- [ ] IntegrationConfigForm.tsx has Grafana type in dropdown
- [ ] Grafana form section displays URL field and Authentication section (secret name + key)
- [ ] Form handler functions update config.config.url and config.config.apiTokenRef
- [ ] Visual styling matches Logz.io pattern (Authentication section grouped with border)
- [ ] integration_config_handler.go has Grafana case in testConnection
- [ ] Test handler uses factory pattern to create instance, start, check health, stop
- [ ] Health check validates dashboard access (required) and datasource access (warns if fails)
- [ ] Error messages are detailed and actionable (HTTP status, specific failure reason)
</success_criteria>

<output>
After completion, create `.planning/phases/15-foundation/15-03-SUMMARY.md` documenting:
- UI form structure for Grafana configuration
- Test connection flow (UI → API → factory → health check)
- Error handling and user feedback strategy
- Files modified and integration points
- Phase 15 complete: users can configure Grafana integrations end-to-end
</output>
