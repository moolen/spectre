---
phase: 15-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/graph/schema.go
  - internal/graph/client.go
autonomous: true

must_haves:
  truths:
    - "FalkorDB schema supports Dashboard nodes with metadata fields"
    - "Dashboard nodes can be created/merged with uid as primary key"
    - "Indexes exist on Dashboard.uid for efficient lookup"
    - "Each Grafana integration instance gets its own isolated graph database"
    - "Graph creation uses naming convention spectre_grafana_{name}"
  artifacts:
    - path: "internal/graph/schema.go"
      provides: "Dashboard node schema definition and upsert queries"
      min_lines: 20
      contains: "Dashboard.*uid.*title.*version"
    - path: "internal/graph/client.go"
      provides: "Graph database creation and management"
      contains: "CreateGraph.*DeleteGraph"
  key_links:
    - from: "internal/graph/schema.go"
      to: "MERGE (d:Dashboard {uid: $uid})"
      via: "Cypher MERGE operation for idempotent dashboard creation"
      pattern: "MERGE.*Dashboard.*uid"
    - from: "internal/graph/client.go"
      to: "FalkorDB graph management"
      via: "Named graph database operations"
      pattern: "GraphName.*spectre_grafana"
---

<objective>
Define FalkorDB graph schema for Dashboard nodes with indexes, and ensure graph client supports multiple isolated graph databases (one per Grafana integration instance).

Purpose: Prepare graph storage layer for dashboard ingestion in Phase 16. Each Grafana integration instance gets its own graph database to avoid data collision and enable clean deletion.

Output: Graph schema supports Dashboard nodes with efficient uid-based lookup, graph client can create/delete named graphs following spectre_grafana_{name} convention.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/15-foundation/15-CONTEXT.md
@.planning/phases/15-foundation/15-RESEARCH.md

# Existing graph patterns
@internal/graph/schema.go
@internal/graph/client.go
@internal/graph/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Dashboard Node Schema to Graph Schema</name>
  <files>internal/graph/schema.go</files>
  <action>
Add Dashboard node support to existing schema.go:

1. **Find InitializeSchema() function** or equivalent schema initialization method

2. **Add Dashboard node index creation** (follow existing ResourceIdentity index pattern):
   ```cypher
   CREATE INDEX IF NOT EXISTS FOR (d:Dashboard) ON (d.uid)
   ```

3. **Add UpsertDashboardNode function** following existing node upsert patterns:
   ```go
   func UpsertDashboardNode(dashboard DashboardNode) string {
       // Returns Cypher query for MERGE operation
       // MERGE (d:Dashboard {uid: $uid})
       // ON CREATE SET d.title = $title, d.version = $version, d.tags = $tags, ...
       // ON MATCH SET d.title = $title, d.version = $version, d.tags = $tags, ...
   }
   ```

4. **Add DashboardNode struct** to models.go or schema.go:
   - UID string (primary key)
   - Title string
   - Version int
   - Tags []string (JSON-encoded in graph)
   - Folder string
   - URL string
   - FirstSeen int64 (Unix nano timestamp)
   - LastSeen int64 (Unix nano timestamp)

**Follow research pattern from RESEARCH.md code examples** - MERGE with ON CREATE SET and ON MATCH SET clauses.

**Index strategy:** Start with uid index only (research recommendation). Folder and tags indexes deferred to Phase 16 if needed.
  </action>
  <verify>
grep -q "Dashboard.*uid" internal/graph/schema.go
grep -q "CREATE INDEX.*Dashboard" internal/graph/schema.go
grep -q "UpsertDashboardNode\|DashboardNode" internal/graph/schema.go
  </verify>
  <done>Dashboard node schema exists with uid index, MERGE query function supports idempotent upserts</done>
</task>

<task type="auto">
  <name>Task 2: Add Named Graph Management to Graph Client</name>
  <files>internal/graph/client.go</files>
  <action>
Enhance graph client to support multiple named graph databases:

1. **Review existing Client struct** - check if GraphName is already configurable (research suggests it is via ClientConfig)

2. **If GraphName NOT in config:** Add GraphName field to ClientConfig struct

3. **Add CreateGraph(ctx context.Context, graphName string) error** method:
   - Execute FalkorDB command to create named graph
   - Implementation: `client.Do(ctx, "GRAPH.CREATE", graphName)`
   - Return error if creation fails

4. **Add DeleteGraph(ctx context.Context, graphName string) error** method:
   - Execute FalkorDB command to delete named graph
   - Implementation: `client.Do(ctx, "GRAPH.DELETE", graphName)`
   - Used when Grafana integration instance is deleted

5. **Add GraphExists(ctx context.Context, graphName string) (bool, error)** helper:
   - Check if named graph exists
   - Implementation: Query GRAPH.LIST and check if graphName in results

**Research guidance:** FalkorDB supports multiple graphs on same Redis instance. Graph naming convention: `spectre_grafana_{integration_name}`.

**Testing note:** Existing graph operations should continue working with default graph name. Named graph support is additive.
  </action>
  <verify>
grep -q "CreateGraph\|DeleteGraph" internal/graph/client.go
grep -q "GraphName" internal/graph/client.go
  </verify>
  <done>Graph client supports creating/deleting named graphs, enabling one graph database per Grafana integration instance</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema compiles:** `go build ./internal/graph/...`
2. **Dashboard index exists:** Query includes "CREATE INDEX" for Dashboard.uid
3. **Named graph support:** CreateGraph and DeleteGraph methods exist
4. **Upsert function:** UpsertDashboardNode returns valid Cypher MERGE query
</verification>

<success_criteria>
- [ ] Dashboard node schema defined with uid, title, version, tags, folder, URL, timestamps
- [ ] Index created on Dashboard.uid for efficient lookup
- [ ] UpsertDashboardNode function returns Cypher MERGE query with ON CREATE/MATCH SET
- [ ] Graph client supports CreateGraph(graphName) and DeleteGraph(graphName)
- [ ] Graph naming convention documented: spectre_grafana_{name}
- [ ] Existing graph operations unaffected (additive changes only)
</success_criteria>

<output>
After completion, create `.planning/phases/15-foundation/15-02-SUMMARY.md` documenting:
- Dashboard node schema structure
- Index strategy (uid only for Phase 15)
- Named graph database support
- Graph naming convention
- Files modified and key Cypher queries
</output>
