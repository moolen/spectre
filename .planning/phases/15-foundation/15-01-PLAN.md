---
phase: 15-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/types.go
  - internal/integration/grafana/client.go
  - internal/integration/grafana/grafana.go
  - internal/integration/grafana/secret_watcher.go
autonomous: true

must_haves:
  truths:
    - "GrafanaClient can authenticate to Grafana using Bearer token from SecretRef"
    - "GrafanaClient can list all dashboards via /api/search endpoint"
    - "GrafanaClient can retrieve full dashboard JSON by UID"
    - "Integration starts in degraded state when secret missing, auto-recovers when secret available"
    - "SecretWatcher provides hot-reload of API token without restart"
  artifacts:
    - path: "internal/integration/grafana/types.go"
      provides: "Config and SecretRef types with validation"
      min_lines: 50
      exports: ["Config", "SecretRef"]
    - path: "internal/integration/grafana/client.go"
      provides: "HTTP client with Grafana API methods"
      min_lines: 100
      exports: ["GrafanaClient"]
    - path: "internal/integration/grafana/grafana.go"
      provides: "Integration lifecycle implementation"
      min_lines: 150
      exports: ["GrafanaIntegration", "NewGrafanaIntegration"]
    - path: "internal/integration/grafana/secret_watcher.go"
      provides: "Reusable SecretWatcher for any integration"
      exports: ["SecretWatcher", "NewSecretWatcher"]
  key_links:
    - from: "internal/integration/grafana/grafana.go"
      to: "internal/integration/grafana/client.go"
      via: "GrafanaClient field and method calls"
      pattern: "g\\.client\\.(ListDashboards|GetDashboard)"
    - from: "internal/integration/grafana/grafana.go"
      to: "internal/integration/grafana/secret_watcher.go"
      via: "SecretWatcher field for token hot-reload"
      pattern: "g\\.secretWatcher\\.GetToken"
    - from: "internal/integration/grafana/client.go"
      to: "Authorization: Bearer"
      via: "HTTP request header with token"
      pattern: "req\\.Header\\.Set\\(\"Authorization\", \"Bearer\""
---

<objective>
Build Grafana integration backend: API client that authenticates to both Cloud and self-hosted instances, lists/retrieves dashboards, and integrates with SecretWatcher for token hot-reload.

Purpose: Foundation for Grafana metrics integration - establishes connectivity and authentication before ingestion pipeline.

Output: Working Grafana integration type that can be instantiated via factory registry, authenticate to Grafana API, and list dashboards via health check.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/15-foundation/15-CONTEXT.md
@.planning/phases/15-foundation/15-RESEARCH.md

# Existing integration patterns to follow
@internal/integration/types.go
@internal/integration/victorialogs/types.go
@internal/integration/victorialogs/victorialogs.go
@internal/integration/victorialogs/client.go
@internal/integration/victorialogs/secret_watcher.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Grafana Config Types with SecretRef and Validation</name>
  <files>internal/integration/grafana/types.go</files>
  <action>
Create types.go following VictoriaLogs pattern exactly:

1. **SecretRef struct** - Copy from victorialogs/types.go (identical K8s Secret reference)
   - Fields: SecretName string, Key string
   - JSON and YAML tags

2. **Config struct** with fields:
   - URL string (base Grafana URL - both Cloud and self-hosted)
   - APITokenRef *SecretRef (K8s Secret reference for API token)
   - JSON and YAML tags on all fields

3. **Validate() method** on Config:
   - Check URL is not empty
   - If APITokenRef present, validate Key is not empty
   - Return descriptive errors

4. **UsesSecretRef() bool method** on Config:
   - Returns true if APITokenRef != nil && APITokenRef.SecretName != ""

Follow research recommendation: No Cloud shorthand, full URL required. No description field (minimal form).

**Package declaration:** `package grafana`

**Imports:** fmt, strings (for validation)
  </action>
  <verify>
grep -q "type Config struct" internal/integration/grafana/types.go
grep -q "func (c \*Config) Validate()" internal/integration/grafana/types.go
grep -q "UsesSecretRef()" internal/integration/grafana/types.go
  </verify>
  <done>Config and SecretRef types exist with validation methods matching VictoriaLogs pattern</done>
</task>

<task type="auto">
  <name>Task 2: Implement Grafana HTTP Client with Bearer Auth</name>
  <files>internal/integration/grafana/client.go</files>
  <action>
Create client.go following victorialogs/client.go pattern:

1. **GrafanaClient struct** with fields:
   - config *Config
   - client *http.Client (with tuned Transport: MaxIdleConnsPerHost: 10)
   - secretWatcher *SecretWatcher (for token retrieval)
   - logger *logging.Logger

2. **NewGrafanaClient(config *Config, secretWatcher *SecretWatcher, logger *logging.Logger)** constructor

3. **ListDashboards(ctx context.Context) ([]DashboardMeta, error)** method:
   - Endpoint: GET {config.URL}/api/search?type=dash-db&limit=5000
   - Authorization: Bearer {token} header (get token from secretWatcher.GetToken())
   - Parse JSON response to []DashboardMeta
   - Handle pagination if needed (research notes: single request up to 5000 dashboards for Phase 15)

4. **GetDashboard(ctx context.Context, uid string) (map[string]interface{}, error)** method:
   - Endpoint: GET {config.URL}/api/dashboards/uid/{uid}
   - Authorization: Bearer {token} header
   - Return dashboard JSON as map (full structure for future parsing)

5. **DashboardMeta struct** for list response:
   - UID string `json:"uid"`
   - Title string `json:"title"`
   - Tags []string `json:"tags"`
   - FolderTitle string `json:"folderTitle"`
   - URL string `json:"url"`

**Error handling:** Return wrapped errors with context (e.g., "failed to list dashboards: %w")

**Timeout:** Use context for request cancellation (http.NewRequestWithContext)

**Package:** `package grafana`
**Imports:** context, encoding/json, fmt, net/http, time, internal/logging
  </action>
  <verify>
grep -q "type GrafanaClient struct" internal/integration/grafana/client.go
grep -q "func.*ListDashboards" internal/integration/grafana/client.go
grep -q "func.*GetDashboard" internal/integration/grafana/client.go
grep -q "Authorization.*Bearer" internal/integration/grafana/client.go
  </verify>
  <done>GrafanaClient can list dashboards and retrieve dashboard JSON by UID with Bearer token authentication</done>
</task>

<task type="auto">
  <name>Task 3: Implement Integration Lifecycle with Factory Registration</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
Create grafana.go following victorialogs/victorialogs.go pattern EXACTLY:

1. **init() function** for factory registration:
   ```go
   func init() {
       if err := integration.RegisterFactory("grafana", NewGrafanaIntegration); err != nil {
           logger := logging.GetLogger("integration.grafana")
           logger.Warn("Failed to register grafana factory: %v", err)
       }
   }
   ```

2. **GrafanaIntegration struct** with fields:
   - name string
   - config *Config
   - client *GrafanaClient
   - secretWatcher *SecretWatcher
   - logger *logging.Logger
   - ctx context.Context
   - cancel context.CancelFunc
   - healthStatus integration.HealthStatus (with mutex for thread safety)

3. **NewGrafanaIntegration(name string, cfg interface{}) (integration.Integration, error)** factory:
   - Type-assert cfg to Config
   - Validate config
   - Create logger with "integration.grafana.{name}" prefix
   - Return &GrafanaIntegration instance

4. **Metadata() integration.IntegrationMetadata** method:
   - Return Name: g.name, Type: "grafana", Version: "1.0.0", Description: "Grafana metrics integration"

5. **Start(ctx context.Context) error** method following EXACT victorialogs pattern:
   - Store context
   - If UsesSecretRef(): create in-cluster K8s client, get namespace, create SecretWatcher, start it
   - Create GrafanaClient with secretWatcher
   - Test connectivity with testConnection() - WARN on failure but continue (degraded state)
   - Set healthStatus to Healthy on success, Degraded on connection failure

6. **Stop(ctx context.Context) error** method:
   - Cancel context
   - Stop SecretWatcher if exists
   - Set healthStatus to Stopped

7. **Health(ctx context.Context) integration.HealthStatus** method:
   - Return current healthStatus (thread-safe read)

8. **RegisterTools(registry integration.ToolRegistry) error** method:
   - Placeholder: return nil (tools registered in Phase 18)

9. **testConnection(ctx context.Context) error** private method:
   - Test dashboard read: call client.ListDashboards with limit 1
   - Test datasource access: GET {config.URL}/api/datasources (WARN if fails, don't block)
   - Return error only if dashboard access fails

**Package:** `package grafana`
**Imports:** context, fmt, integration, logging, k8s.io/client-go/kubernetes, k8s.io/client-go/rest, sync
  </action>
  <verify>
grep -q "func init()" internal/integration/grafana/grafana.go
grep -q "RegisterFactory.*grafana" internal/integration/grafana/grafana.go
grep -q "func.*Start.*context.Context.*error" internal/integration/grafana/grafana.go
grep -q "testConnection" internal/integration/grafana/grafana.go
  </verify>
  <done>Grafana integration implements full lifecycle (Start/Stop/Health), registers with factory, integrates SecretWatcher, and validates connection on startup</done>
</task>

<task type="auto">
  <name>Task 4: Move SecretWatcher to Reusable Location</name>
  <files>internal/integration/grafana/secret_watcher.go</files>
  <action>
Copy victorialogs/secret_watcher.go to grafana/secret_watcher.go:

1. **Copy file verbatim** from internal/integration/victorialogs/secret_watcher.go
2. **Change package declaration** to `package grafana`
3. **Keep all logic identical** - this creates temporary duplication

Rationale: Research shows SecretWatcher is reusable across integrations. Phase 15 creates working Grafana integration; refactoring SecretWatcher to shared package deferred to future phase.

**Alternative approach (if you judge it cleaner):** Create internal/integration/common/secret_watcher.go and import from both victorialogs and grafana. This avoids duplication but adds cross-package dependency. Your discretion.
  </action>
  <verify>
test -f internal/integration/grafana/secret_watcher.go
grep -q "package grafana" internal/integration/grafana/secret_watcher.go
grep -q "type SecretWatcher struct" internal/integration/grafana/secret_watcher.go
  </verify>
  <done>SecretWatcher available in grafana package for token hot-reload (either via copy or shared package)</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Package compiles:** `go build ./internal/integration/grafana/...`
2. **Factory registered:** `grep -r "grafana.*NewGrafanaIntegration" internal/integration/grafana/grafana.go`
3. **Types validated:** Config.Validate() returns errors for missing required fields
4. **Client authenticates:** Authorization header includes "Bearer" token
5. **Integration lifecycle:** Start() creates SecretWatcher, testConnection() validates Grafana API access
</verification>

<success_criteria>
- [ ] internal/integration/grafana/types.go exists with Config, SecretRef, Validate(), UsesSecretRef()
- [ ] internal/integration/grafana/client.go exists with GrafanaClient, ListDashboards(), GetDashboard()
- [ ] internal/integration/grafana/grafana.go exists with factory registration, Start/Stop/Health lifecycle
- [ ] SecretWatcher available in grafana package (via copy or shared location)
- [ ] Factory registered as "grafana" type in init()
- [ ] Bearer token authentication in HTTP requests
- [ ] Health check validates both dashboard and datasource access (warns on datasource failure)
- [ ] Integration starts degraded if secret missing, auto-recovers when available
- [ ] All code follows victorialogs pattern exactly (consistency with existing integrations)
</success_criteria>

<output>
After completion, create `.planning/phases/15-foundation/15-01-SUMMARY.md` documenting:
- Grafana integration backend complete with API client and SecretWatcher integration
- Factory registration pattern followed
- Health check strategy (dashboard required, datasource optional)
- Files created and key patterns established
</output>
