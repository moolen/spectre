---
phase: 06-consolidated-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/spectre/commands/server.go
  - internal/apiserver/server.go
  - internal/apiserver/routes.go
autonomous: true

must_haves:
  truths:
    - "MCP server initializes with main server on single port 8080"
    - "Integration tools register via MCP endpoint before HTTP starts listening"
    - "Stdio transport runs alongside HTTP when --stdio flag present"
    - "HTTP endpoint /v1/mcp responds to MCP protocol requests"
    - "Server logs distinguish transport sources: [http-mcp], [stdio-mcp], [rest]"
  artifacts:
    - path: "cmd/spectre/commands/server.go"
      provides: "MCP server initialization with MCPToolRegistry wired to integration manager"
      contains: "mcp.NewSpectreServerWithOptions"
      min_lines: 600
    - path: "cmd/spectre/commands/server.go"
      provides: "Stdio transport flag and goroutine"
      contains: "stdioEnabled"
      exports: []
    - path: "internal/apiserver/server.go"
      provides: "MCP server field in Server struct"
      contains: "mcpServer"
      exports: []
    - path: "internal/apiserver/routes.go"
      provides: "MCP endpoint registration on router"
      contains: "StreamableHTTPServer"
      exports: []
  key_links:
    - from: "cmd/spectre/commands/server.go"
      to: "mcp.NewSpectreServerWithOptions"
      via: "MCP server creation before integration manager"
      pattern: "spectreServer.*NewSpectreServerWithOptions"
    - from: "integration.Manager"
      to: "mcp.MCPToolRegistry"
      via: "NewManagerWithMCPRegistry constructor"
      pattern: "NewManagerWithMCPRegistry.*mcpRegistry"
    - from: "internal/apiserver/routes.go"
      to: "/v1/mcp endpoint"
      via: "router.Handle registration"
      pattern: "router\\.Handle.*\\/v1\\/mcp"
---

<objective>
Integrate MCP server into main Spectre server for single-port deployment with StreamableHTTP transport and in-process integration manager.

Purpose: Eliminates MCP sidecar architecture, enables single-container deployment on port 8080, and allows integrations to register MCP tools in-process.

Output: Modified server.go and apiserver code that initializes MCP alongside REST, registers /v1/mcp endpoint, and optionally runs stdio transport.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-consolidated-server/06-CONTEXT.md
@.planning/phases/06-consolidated-server/06-RESEARCH.md

# Current implementation references
@cmd/spectre/commands/server.go
@cmd/spectre/commands/mcp.go
@internal/mcp/server.go
@internal/integration/manager.go
@internal/apiserver/server.go
@internal/lifecycle/manager.go
</context>

<tasks>

<task type="auto">
  <name>Initialize MCP Server in Main Server Command</name>
  <files>cmd/spectre/commands/server.go</files>
  <action>
Add MCP server initialization to the server startup flow in cmd/spectre/commands/server.go.

**Location:** After integration manager initialization (around line 204), before lifecycle manager starts.

**Implementation:**
1. Add --stdio flag to serverCmd.Flags() in init():
   - `serverCmd.Flags().BoolVar(&stdioEnabled, "stdio", false, "Enable stdio MCP transport alongside HTTP (default: false)")`
   - Declare var `stdioEnabled bool` at package level

2. After integration manager creation (line 204), create MCP server:
   ```go
   // Create MCP server for in-process tool execution
   logger.Info("Initializing MCP server")
   spectreServer, err := mcp.NewSpectreServerWithOptions(mcp.ServerOptions{
       SpectreURL: fmt.Sprintf("http://localhost:%d", cfg.APIPort),
       Version:    Version,
       Logger:     logger,
   })
   if err != nil {
       logger.Error("Failed to create MCP server: %v", err)
       HandleError(err, "MCP server initialization error")
   }
   mcpServer := spectreServer.GetMCPServer()
   logger.Info("MCP server created")
   ```

3. Modify integration manager creation to use MCPToolRegistry:
   ```go
   // Create MCPToolRegistry adapter
   mcpRegistry := mcp.NewMCPToolRegistry(mcpServer)

   // Create integration manager with MCP registry (change existing NewManager call)
   integrationMgr, err = integration.NewManagerWithMCPRegistry(integration.ManagerConfig{
       ConfigPath:            integrationsConfigPath,
       MinIntegrationVersion: minIntegrationVersion,
   }, mcpRegistry)
   ```

4. Pass MCP server to apiserver initialization (modify existing NewWithStorageGraphAndPipeline call):
   - Add mcpServer as additional parameter to apiComponent creation
   - Will modify apiserver.Server struct in next task

5. Add stdio transport goroutine after lifecycle manager starts (around line 550, after manager.Start):
   ```go
   // Start stdio MCP transport if requested
   if stdioEnabled {
       logger.Info("Starting stdio MCP transport alongside HTTP")
       go func() {
           if err := server.ServeStdio(mcpServer); err != nil {
               logger.Error("Stdio transport error: %v", err)
           }
       }()
   }
   ```

**What NOT to do:**
- Do NOT create separate lifecycle component for MCP server - it's part of HTTP server
- Do NOT make --stdio mutually exclusive with HTTP - both run together
- Do NOT register MCP tools in this task - that happens via integration manager startup

**Why this approach:**
- MCP server must exist before integration manager starts (tools need registry)
- Integration manager calls RegisterTools during Start(), so manager.Start() handles tool registration
- Stdio runs in goroutine, stops automatically when context cancels
- Self-reference to localhost:8080 allows reusing existing MCP tool implementations (Phase 7 will eliminate HTTP calls)
  </action>
  <verify>
Build succeeds: `go build -o spectre ./cmd/spectre`
No compilation errors related to MCP server initialization
Check that imports added: `github.com/mark3labs/mcp-go/server`
  </verify>
  <done>
cmd/spectre/commands/server.go contains MCP server initialization before integration manager, MCPToolRegistry wired to integration manager, and stdio flag/goroutine. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Add MCP Server to APIServer and Register /v1/mcp Endpoint</name>
  <files>internal/apiserver/server.go, internal/apiserver/routes.go</files>
  <action>
Modify apiserver package to accept MCP server and register /v1/mcp endpoint on the HTTP router.

**In internal/apiserver/server.go:**

1. Add mcpServer field to Server struct (around line 54):
   ```go
   type Server struct {
       port             int
       server           *http.Server
       logger           *logging.Logger
       queryExecutor    api.QueryExecutor
       // ... existing fields ...
       integrationManager *integration.Manager
       mcpServer          *server.MCPServer  // Add this field
   }
   ```

2. Add import at top of file:
   ```go
   "github.com/mark3labs/mcp-go/server"
   ```

3. Modify NewWithStorageGraphAndPipeline constructor signature to accept mcpServer parameter (around line 64):
   - Add parameter: `mcpServer *server.MCPServer` after integrationManager parameter
   - Assign to struct: `mcpServer: mcpServer,` in Server initialization

**In internal/apiserver/routes.go (or create if doesn't exist):**

1. If routes.go exists, add MCP registration method. If not, add method to server.go after configureHTTPServer:
   ```go
   // registerMCPHandler adds MCP endpoint to the router
   func (s *Server) registerMCPHandler() {
       if s.mcpServer == nil {
           s.logger.Debug("MCP server not configured, skipping /v1/mcp endpoint")
           return
       }

       endpointPath := "/v1/mcp"
       s.logger.Info("Registering MCP endpoint at %s", endpointPath)

       // Create StreamableHTTP server with stateless mode
       streamableServer := server.NewStreamableHTTPServer(
           s.mcpServer,
           server.WithEndpointPath(endpointPath),
           server.WithStateLess(true), // Stateless mode per requirements
       )

       // Register on router (must be BEFORE static UI catch-all)
       s.router.Handle(endpointPath, streamableServer)
       s.logger.Info("MCP endpoint registered at %s", endpointPath)
   }
   ```

2. Call registerMCPHandler in configureHTTPServer (or wherever routes are registered):
   - Add call BEFORE static file handler registration (route order matters - /v1/mcp must be registered before catch-all `/`)
   - Location: Find where router.HandleFunc("/", ...) or similar static handler is registered, add s.registerMCPHandler() BEFORE it

**Route registration order (CRITICAL):**
1. Specific API routes (/api/v1/*, /health, /metrics)
2. MCP endpoint (/v1/mcp) <- Add here
3. Static UI catch-all (/) <- Must be LAST

**What NOT to do:**
- Do NOT create separate http.Server for MCP - use existing router
- Do NOT add CORS manually - existing corsMiddleware already handles all routes
- Do NOT add heartbeat configuration - StreamableHTTPServer handles it
- Do NOT add /health endpoint - already exists for entire server

**Why this approach:**
- Single http.Server simplifies deployment and CORS handling
- StreamableHTTPServer is current MCP standard (replaces deprecated SSE)
- Stateless mode ensures compatibility with clients that don't manage sessions
- Route order prevents static UI from intercepting MCP requests
  </action>
  <verify>
Build succeeds: `go build -o spectre ./cmd/spectre`
Grep for route registration order: `grep -A 5 "registerMCPHandler" internal/apiserver/server.go internal/apiserver/routes.go`
Check MCP endpoint registered before catch-all
  </verify>
  <done>
internal/apiserver/server.go has mcpServer field and accepts it in constructor. MCP endpoint /v1/mcp registered on router with StreamableHTTPServer before static UI handler. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Update Server Command to Pass MCP Server to APIServer</name>
  <files>cmd/spectre/commands/server.go</files>
  <action>
Update the apiserver initialization in server.go to pass the MCP server instance.

**Location:** Find the NewWithStorageGraphAndPipeline call (around line 450-500 based on research).

**Implementation:**
1. Locate existing apiserver creation:
   ```go
   apiComponent := apiserver.NewWithStorageGraphAndPipeline(
       cfg.APIPort,
       // ... existing parameters ...
       integrationMgr,  // This should be the last parameter currently
   )
   ```

2. Add mcpServer parameter:
   ```go
   apiComponent := apiserver.NewWithStorageGraphAndPipeline(
       cfg.APIPort,
       // ... existing parameters ...
       integrationMgr,
       mcpServer,  // Add this parameter
   )
   ```

**What NOT to do:**
- Do NOT change order of existing parameters
- Do NOT add conditional logic - pass mcpServer directly (it's guaranteed to exist from Task 1)
- Do NOT wrap in lifecycle component - apiComponent already handles HTTP server lifecycle

**Why this approach:**
- Keeps MCP server lifecycle tied to HTTP server lifecycle
- APIServer.Start() will start HTTP listener which serves both REST and MCP
- APIServer.Stop() gracefully shuts down HTTP server which stops both transports
  </action>
  <verify>
Build succeeds: `go build -o spectre ./cmd/spectre`
Check apiserver initialization includes mcpServer parameter
  </verify>
  <done>
cmd/spectre/commands/server.go passes mcpServer to apiserver.NewWithStorageGraphAndPipeline. Build succeeds with all three tasks integrated.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   go build -o spectre ./cmd/spectre
   echo $?  # Should be 0
   ```

2. Code structure verification:
   ```bash
   # MCP initialization exists and is in correct order
   grep -A 10 "mcp.NewSpectreServerWithOptions" cmd/spectre/commands/server.go

   # Integration manager uses MCP registry
   grep "NewManagerWithMCPRegistry" cmd/spectre/commands/server.go

   # MCP endpoint registered
   grep "/v1/mcp" internal/apiserver/server.go internal/apiserver/routes.go

   # Stdio flag exists
   grep "stdioEnabled" cmd/spectre/commands/server.go
   ```

3. Requirements coverage:
   - SRVR-01: Single server on 8080 - apiserver serves on one port
   - SRVR-02: MCP at /v1/mcp - endpoint registered
   - SRVR-03: Stdio transport available - --stdio flag implemented
   - INTG-01: Integration manager with MCP server - MCPToolRegistry wired
   - INTG-02: Dynamic tool registration - via MCPToolRegistry.RegisterTool

All requirements can be validated without runtime testing (structure verification only). Runtime testing happens in Plan 02 checkpoint.
</verification>

<success_criteria>
- [ ] Build completes successfully with no errors
- [ ] cmd/spectre/commands/server.go initializes MCP server before integration manager starts
- [ ] Integration manager created with NewManagerWithMCPRegistry and MCPToolRegistry
- [ ] internal/apiserver/server.go has mcpServer field and registerMCPHandler method
- [ ] MCP endpoint /v1/mcp registered on router before static UI catch-all
- [ ] --stdio flag added and stdio goroutine starts when flag present
- [ ] No separate lifecycle component created for MCP (handled by HTTP server)
- [ ] Route registration order preserved (specific -> MCP -> static catch-all)
</success_criteria>

<output>
After completion, create `.planning/phases/06-consolidated-server/06-01-SUMMARY.md`
</output>
