---
phase: 20-alert-api-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/graph/models.go
  - internal/integration/grafana/client.go
autonomous: true

must_haves:
  truths:
    - "Alert nodes can be stored in FalkorDB with metadata fields"
    - "GrafanaClient can fetch alert rules from Grafana Alerting API"
    - "Alert rules response includes PromQL queries for metric extraction"
  artifacts:
    - path: "internal/graph/models.go"
      provides: "Alert node type and MONITORS edge type"
      contains: "NodeTypeAlert"
    - path: "internal/integration/grafana/client.go"
      provides: "Alert rules API methods"
      exports: ["ListAlertRules", "GetAlertRule"]
  key_links:
    - from: "internal/integration/grafana/client.go"
      to: "/api/v1/provisioning/alert-rules"
      via: "HTTP GET with Bearer token"
      pattern: "/api/v1/provisioning/alert-rules"
---

<objective>
Establish foundation for alert rule synchronization by extending graph schema with Alert nodes and adding Grafana Alerting API methods to GrafanaClient.

Purpose: Enable alert rule ingestion from Grafana with proper graph storage types and API client support.
Output: Alert node types in graph schema, ListAlertRules/GetAlertRule methods in GrafanaClient with test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-alert-api-client/20-RESEARCH.md
@.planning/phases/16-ingestion-pipeline/16-02-SUMMARY.md
@internal/graph/models.go
@internal/integration/grafana/client.go
@internal/integration/grafana/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Alert node type and MONITORS edge to graph schema</name>
  <files>internal/graph/models.go</files>
  <action>
    Extend graph schema with alert rule support:

    1. Add NodeTypeAlert constant to NodeType enumeration (after NodeTypeVariable)
    2. Add EdgeTypeMonitors constant to EdgeType enumeration (after EdgeTypeHasVariable)
    3. Create AlertNode struct with fields:
       - UID string (alert rule UID, primary key)
       - Title string (alert rule title)
       - FolderTitle string (folder containing the rule)
       - RuleGroup string (alert rule group name)
       - Condition string (PromQL expression - stored for display, parsed separately)
       - Labels map[string]string (alert labels)
       - Annotations map[string]string (alert annotations including severity)
       - Updated string (ISO8601 timestamp for incremental sync)
       - Integration string (integration name, e.g., "grafana_prod")

    Follow existing pattern: struct after K8sEvent, before DashboardNode.
    Use json tags matching field names (lowercase first letter).

    Do NOT add state-related fields (firing/pending/normal) - those belong in Phase 21 AlertStateChange nodes.
  </action>
  <verify>
    Run: go build ./internal/graph/...
    Check: No compilation errors
    Check: AlertNode struct has 9 fields (UID, Title, FolderTitle, RuleGroup, Condition, Labels, Annotations, Updated, Integration)
  </verify>
  <done>
    NodeTypeAlert and EdgeTypeMonitors constants exist in graph schema.
    AlertNode struct stores alert rule definition metadata.
    Code compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add alert rules API methods to GrafanaClient</name>
  <files>internal/integration/grafana/client.go</files>
  <action>
    Extend GrafanaClient with Grafana Alerting API support:

    1. Add AlertRule struct before GrafanaClient struct:
       - UID string (alert rule UID)
       - Title string (alert rule title)
       - FolderUID string (folder UID)
       - RuleGroup string (rule group name)
       - Data []AlertQuery (alert queries - PromQL expressions)
       - Labels map[string]string (alert labels)
       - Annotations map[string]string (annotations including severity)
       - Updated time.Time (last update timestamp)

    2. Add AlertQuery struct:
       - RefID string (query reference ID)
       - Model json.RawMessage (query model - contains PromQL)
       - DatasourceUID string (datasource UID)
       - QueryType string (query type, typically "prometheus")

    3. Add ListAlertRules method after GetDashboard:
       - Signature: ListAlertRules(ctx context.Context) ([]AlertRule, error)
       - Endpoint: GET /api/v1/provisioning/alert-rules
       - Authentication: Bearer token (same pattern as ListDashboards)
       - Error handling: Same pattern as ListDashboards (check status, log on error)
       - Return: Array of AlertRule structs

    4. Add GetAlertRule method:
       - Signature: GetAlertRule(ctx context.Context, uid string) (*AlertRule, error)
       - Endpoint: GET /api/v1/provisioning/alert-rules/{uid}
       - Authentication: Bearer token
       - Error handling: Same pattern as GetDashboard
       - Return: Single AlertRule pointer

    Follow existing patterns: Bearer token auth with secretWatcher, io.ReadAll for connection reuse, error wrapping with fmt.Errorf.

    Do NOT implement alert state fetching (firing/pending) - that's Phase 21 (/api/prometheus/grafana/api/v1/alerts endpoint).
  </action>
  <verify>
    Run: go build ./internal/integration/grafana/...
    Run: go test -run TestGrafanaClient ./internal/integration/grafana/ (existing tests should still pass)
    Check: AlertRule and AlertQuery types defined
    Check: ListAlertRules and GetAlertRule methods exist on GrafanaClient
    Check: Methods use /api/v1/provisioning/alert-rules endpoint
  </verify>
  <done>
    GrafanaClient has ListAlertRules() and GetAlertRule() methods.
    Methods authenticate with Bearer token and handle errors gracefully.
    AlertRule struct contains Data field with PromQL queries for metric extraction.
    Existing client tests still pass.
  </done>
</task>

</tasks>

<verification>
Run: go build ./internal/graph/... ./internal/integration/grafana/...
Check: No compilation errors across both packages
Check: AlertNode type exists with 9 metadata fields
Check: GrafanaClient has alert rules API methods
Check: AlertRule.Data field contains AlertQuery array for PromQL extraction
</verification>

<success_criteria>
Foundation for alert rule synchronization is complete when:
- Alert node types (NodeTypeAlert, EdgeTypeMonitors, AlertNode struct) exist in graph schema
- GrafanaClient can fetch alert rules via Grafana Alerting Provisioning API
- AlertRule struct contains PromQL queries in Data field for metric extraction in next plan
- All code compiles without errors
- Existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/20-alert-api-client/20-01-SUMMARY.md`
</output>
