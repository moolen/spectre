---
phase: 20-alert-api-client
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - internal/integration/grafana/alert_syncer.go
  - internal/integration/grafana/alert_syncer_test.go
  - internal/integration/grafana/graph_builder.go
  - internal/integration/grafana/grafana.go
autonomous: true

must_haves:
  truths:
    - "Alert rules are synced incrementally based on updated timestamp"
    - "Alert nodes are created in FalkorDB with metadata from Grafana"
    - "Alert→Metric relationships exist via PromQL extraction"
    - "Alert→Service relationships are queryable transitively through Metrics"
    - "Periodic sync updates alert rules hourly"
  artifacts:
    - path: "internal/integration/grafana/alert_syncer.go"
      provides: "AlertSyncer with incremental sync logic"
      exports: ["AlertSyncer", "NewAlertSyncer"]
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "Graph builder methods for Alert nodes"
      exports: ["BuildAlertGraph"]
    - path: "internal/integration/grafana/alert_syncer_test.go"
      provides: "Test coverage for AlertSyncer"
      min_lines: 100
  key_links:
    - from: "internal/integration/grafana/alert_syncer.go"
      to: "internal/integration/grafana/client.go"
      via: "ListAlertRules API call"
      pattern: "ListAlertRules.*context"
    - from: "internal/integration/grafana/alert_syncer.go"
      to: "internal/integration/grafana/graph_builder.go"
      via: "BuildAlertGraph for graph node creation"
      pattern: "BuildAlertGraph"
    - from: "internal/integration/grafana/graph_builder.go"
      to: "internal/integration/grafana/promql_parser.go"
      via: "ExtractFromPromQL for metric names"
      pattern: "parser\\.Parse"
</objective>

<objective>
Implement alert rule synchronization with incremental sync, PromQL-based metric extraction, and graph relationships to existing Metrics and Services.

Purpose: Enable continuous alert rule ingestion from Grafana with graph linking to metrics and services for incident response reasoning.
Output: AlertSyncer with version-based sync, graph builder methods for Alert nodes, comprehensive test coverage, integration lifecycle wiring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-alert-api-client/20-RESEARCH.md
@.planning/phases/16-ingestion-pipeline/16-02-SUMMARY.md
@internal/integration/grafana/dashboard_syncer.go
@internal/integration/grafana/graph_builder.go
@internal/integration/grafana/promql_parser.go
@internal/integration/grafana/grafana.go
@internal/graph/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AlertSyncer with incremental sync</name>
  <files>
    internal/integration/grafana/alert_syncer.go
    internal/integration/grafana/alert_syncer_test.go
  </files>
  <action>
    Create AlertSyncer following DashboardSyncer pattern from Phase 16:

    **AlertSyncer struct (alert_syncer.go):**
    1. Create GrafanaClientInterface addition:
       - Add ListAlertRules(ctx) ([]AlertRule, error) to interface

    2. Create AlertSyncer struct with fields:
       - client GrafanaClientInterface
       - graph GraphClient
       - builder *GraphBuilder
       - integrationName string
       - logger *logging.Logger
       - ctx context.Context
       - cancel context.CancelFunc
       - syncInterval time.Duration (default 1 hour)

    3. Create NewAlertSyncer constructor:
       - Parameters: client, graph, builder, integrationName, logger
       - Initialize syncInterval to 1 hour
       - Return *AlertSyncer

    4. Implement Start() method:
       - Create cancellable context
       - Start background goroutine with ticker loop
       - Call syncAlerts() immediately, then every syncInterval
       - Log sync start/completion/errors

    5. Implement Stop() method:
       - Cancel context
       - Wait for goroutine to exit

    6. Implement syncAlerts() error method:
       - Call client.ListAlertRules(ctx)
       - For each alert rule:
         a. Query graph for existing Alert node by UID
         b. Compare Updated timestamp (ISO8601 string comparison)
         c. Skip if unchanged (same Updated value)
         d. Call builder.BuildAlertGraph(alertRule) for new/changed rules
       - Return error if API call or graph operations fail
       - Log summary: X alerts synced, Y unchanged, Z errors

    **Test coverage (alert_syncer_test.go):**
    1. Create mockGrafanaClient with ListAlertRules method
    2. Create mockGraphClient for graph queries
    3. Test cases:
       - New alert rule (not in graph) -> BuildAlertGraph called
       - Updated alert rule (newer timestamp) -> BuildAlertGraph called
       - Unchanged alert rule (same timestamp) -> BuildAlertGraph NOT called
       - API error handling -> error propagated, sync stops
       - Periodic sync lifecycle (Start/Stop)

    Follow DashboardSyncer patterns: interface-based design, version comparison, graceful degradation, ticker-based periodic sync.
  </action>
  <verify>
    Run: go test -run TestAlertSyncer ./internal/integration/grafana/
    Check: All AlertSyncer tests pass
    Check: AlertSyncer struct has Start/Stop/syncAlerts methods
    Check: Tests cover new/updated/unchanged alert rule scenarios
  </verify>
  <done>
    AlertSyncer implements incremental sync based on Updated timestamp.
    Background goroutine syncs alert rules every hour.
    Test coverage validates sync logic and lifecycle management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend GraphBuilder with alert graph methods</name>
  <files>internal/integration/grafana/graph_builder.go</files>
  <action>
    Extend GraphBuilder with alert rule graph construction methods:

    1. Add BuildAlertGraph method after BuildDashboardGraph:
       - Signature: BuildAlertGraph(alertRule AlertRule) error
       - Implementation:
         a. Create Alert node using MERGE (upsert by UID)
         b. Extract PromQL expressions from alertRule.Data (iterate AlertQuery array)
         c. For each query with queryType=="prometheus":
            - Parse query.Model JSON to extract "expr" field (PromQL string)
            - Call parser.Parse(promql) to extract metrics
            - For each metric name:
              * Create Metric node using MERGE (upsert by name)
              * Create MONITORS edge: (Alert)-[:MONITORS]->(Metric)
         d. Handle parse errors gracefully (log error, continue with other queries)
       - Return error only for graph operation failures

    2. Alert node properties (map for Cypher):
       - uid: alertRule.UID
       - title: alertRule.Title
       - folderTitle: alertRule.FolderUID (use folder UID as string)
       - ruleGroup: alertRule.RuleGroup
       - condition: First PromQL expression (for display)
       - labels: JSON-encoded alertRule.Labels
       - annotations: JSON-encoded alertRule.Annotations
       - updated: alertRule.Updated.Format(time.RFC3339)
       - integration: integrationName

    3. Cypher query pattern:
       ```
       MERGE (a:Alert {uid: $uid, integration: $integration})
       SET a.title = $title, a.folderTitle = $folderTitle, ...
       WITH a
       MATCH (m:Metric {name: $metricName})
       MERGE (a)-[:MONITORS]->(m)
       ```

    Follow existing patterns: MERGE-based upsert, graceful PromQL parse error handling, JSON encoding for complex fields, interface-based parser injection for testability.

    Do NOT create Alert→Service edges directly - services are reachable transitively via (Alert)-[:MONITORS]->(Metric)-[:TRACKS]->(Service) path.
  </action>
  <verify>
    Run: go test -run TestGraphBuilder ./internal/integration/grafana/
    Check: BuildAlertGraph method exists on GraphBuilder
    Check: Method creates Alert node with all metadata fields
    Check: Method creates MONITORS edges to Metric nodes
    Check: Existing dashboard graph tests still pass
  </verify>
  <done>
    GraphBuilder can transform alert rules into Alert nodes with MONITORS relationships.
    PromQL parser extracts metrics from alert query expressions.
    Alert→Service relationships are queryable transitively through Metric nodes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire AlertSyncer into Grafana integration lifecycle</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
    Integrate AlertSyncer into GrafanaIntegration lifecycle:

    1. Add alertSyncer field to GrafanaIntegration struct (after syncer field)

    2. Modify SetGraphClient method:
       - Create AlertSyncer after DashboardSyncer creation
       - Pass same graph client and builder instance
       - Store in g.alertSyncer field

    3. Modify Start method:
       - After syncer.Start(), check if alertSyncer != nil
       - If alertSyncer exists, call g.alertSyncer.Start()
       - Log: "Starting alert syncer for integration %s"

    4. Modify Stop method:
       - Before syncer.Stop(), check if alertSyncer != nil
       - If alertSyncer exists, call g.alertSyncer.Stop()
       - Log: "Stopping alert syncer for integration %s"

    Follow existing patterns: Optional alertSyncer (nil check before use), same lifecycle as DashboardSyncer, shared GraphBuilder instance for consistency.

    Alert syncing is automatic once graph client is set via SetGraphClient - no UI changes needed in this phase.
  </action>
  <verify>
    Run: go build ./internal/integration/grafana/...
    Check: GrafanaIntegration struct has alertSyncer field
    Check: SetGraphClient creates AlertSyncer instance
    Check: Start/Stop methods manage alertSyncer lifecycle
    Check: No compilation errors
  </verify>
  <done>
    AlertSyncer is wired into Grafana integration lifecycle.
    Alert rules sync automatically when graph client is configured.
    Start/Stop methods manage both dashboard and alert syncing.
  </done>
</task>

</tasks>

<verification>
Run full integration test suite:
```bash
go test ./internal/integration/grafana/... -v
```

Check AlertSyncer functionality:
- New alert rules trigger graph node creation
- Updated alert rules (newer timestamp) trigger updates
- Unchanged alert rules are skipped (incremental sync)
- PromQL expressions are parsed to extract metric names
- MONITORS edges connect Alert nodes to Metric nodes
- Alert→Service relationships are queryable transitively

Check integration lifecycle:
- SetGraphClient creates both dashboard and alert syncers
- Start method starts both syncers
- Stop method stops both syncers cleanly
</verification>

<success_criteria>
Alert rule synchronization is complete when:
- AlertSyncer implements incremental sync based on Updated timestamp
- Alert nodes are created in FalkorDB with metadata (name, severity, labels, PromQL condition)
- PromQL parser extracts metrics from alert rule queries
- Graph contains Alert→Metric relationships (MONITORS edges)
- Alert→Service relationships are queryable transitively: (Alert)-[:MONITORS]->(Metric)-[:TRACKS]->(Service)
- Periodic sync updates alert rules every hour
- AlertSyncer is wired into Grafana integration lifecycle (Start/Stop)
- Comprehensive test coverage validates all sync scenarios
- All tests pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-alert-api-client/20-02-SUMMARY.md`
</output>
