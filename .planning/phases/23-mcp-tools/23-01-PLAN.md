---
phase: 23-mcp-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/tools_alerts_overview.go
  - internal/integration/grafana/grafana.go
autonomous: true

must_haves:
  truths:
    - "AI can query firing/pending alert counts by severity without knowing specific alert names"
    - "Overview tool returns flappiness counts per severity bucket"
    - "Overview tool accepts optional filters (severity, cluster, service, namespace)"
    - "Tool returns minimal data (names + durations) to enable triage without extra calls"
  artifacts:
    - path: "internal/integration/grafana/tools_alerts_overview.go"
      provides: "Overview tool implementation with filtering and aggregation"
      min_lines: 150
      exports: ["OverviewTool", "Execute"]
    - path: "internal/integration/grafana/grafana.go"
      provides: "Tool registration in RegisterTools method"
      contains: "grafana_%s_alerts_overview"
  key_links:
    - from: "OverviewTool.Execute"
      to: "AlertAnalysisService.AnalyzeAlert"
      via: "GetAnalysisService() then loop over alerts"
      pattern: "GetAnalysisService.*AnalyzeAlert"
    - from: "grafana.go RegisterTools"
      to: "NewOverviewTool constructor"
      via: "tool instantiation"
      pattern: "NewOverviewTool.*graphClient"
---

<objective>
Create MCP tool `grafana_{name}_alerts_overview` that provides AI with high-level alert counts grouped by severity, cluster, service, and namespace with flappiness indicators.

Purpose: Enable AI to quickly triage alert landscape without loading detailed state timelines, following progressive disclosure pattern from Phase 18 metrics tools.

Output: Single tool file with filtering, aggregation, flappiness detection, and tool registration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-mcp-tools/23-CONTEXT.md
@.planning/phases/23-mcp-tools/23-RESEARCH.md
@.planning/phases/22-historical-analysis/22-02-SUMMARY.md
@.planning/phases/22-historical-analysis/22-03-SUMMARY.md
@.planning/phases/18-query-execution-mcp-tools/18-02-SUMMARY.md

# Reference existing patterns
@internal/integration/grafana/tools_metrics_overview.go
@internal/integration/grafana/alert_analysis_service.go
@internal/integration/grafana/grafana.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Overview Tool with Filtering and Aggregation</name>
  <files>internal/integration/grafana/tools_alerts_overview.go</files>
  <action>
Create tools_alerts_overview.go following Phase 18 OverviewTool pattern but for alerts:

**Type definitions:**
- OverviewParams struct: severity (optional enum: Critical, Warning, Info), cluster, service, namespace (all optional filters)
- OverviewResponse struct: alerts_by_severity (map[string]SeverityBucket), filters_applied, timestamp
- SeverityBucket struct: count, flapping_count, alerts (array of AlertSummary)
- AlertSummary struct: name, firing_duration (string like "2h"), cluster, service, namespace

**Tool struct:**
- OverviewTool with graphClient, integrationName, logger fields
- NewOverviewTool constructor accepting graph.Client, integrationName string, logger

**Execute method logic:**
1. Parse and validate OverviewParams (all filters optional)
2. Query graph for Alert nodes matching integration + filters:
   - Base query: `MATCH (a:Alert {integration: $integration}) WHERE a.state IN ['firing', 'pending']`
   - Add WHERE clauses for each non-empty filter (severity via labels.severity, cluster via labels.cluster, etc.)
3. Group results by severity (extract from labels.severity)
4. For each alert, compute firing_duration from state timestamp to now
5. Get AlertAnalysisService via integration.GetAnalysisService():
   - If service nil (graph disabled), skip enrichment, return basic counts
   - If service available, call AnalyzeAlert(ctx, alert.UID) for each alert
   - Handle ErrInsufficientData gracefully (new alerts without 24h history) - include in counts but mark as "new (insufficient history)"
   - Count alerts with FlappinessScore > 0.7 as flapping
6. Build response with three severity buckets (Critical, Warning, Info) containing:
   - count: total alerts in bucket
   - flapping_count: alerts with flappiness > 0.7
   - alerts: array of AlertSummary (name + firing_duration + cluster + service + namespace)
7. Return compact JSON response

**Key patterns from RESEARCH.md:**
- All filter parameters optional (no required fields except integration name implicit)
- Use GetAnalysisService() which returns nil if graph disabled
- Flapping threshold 0.7 (from Phase 22-02 categorization logic)
- Handle ErrInsufficientData with errors.As check - continue with other alerts
- Severity case normalization: strings.Title(strings.ToLower(severity)) for input matching
- Tool name includes integration name: grafana_{name}_alerts_overview
  </action>
  <verify>
go build internal/integration/grafana/tools_alerts_overview.go
File compiles without errors, exports OverviewTool type and NewOverviewTool constructor
  </verify>
  <done>
tools_alerts_overview.go exists with ~150+ lines, implements Execute(ctx, args) returning filtered alert counts by severity with flappiness indicators, handles nil analysis service gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Overview Tool in Integration</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
Update RegisterTools method to register alerts overview tool after metrics tools (around line 415):

**Add after metrics_details tool registration:**
```go
// Register Alerts Overview tool: grafana_{name}_alerts_overview
alertsOverviewTool := NewOverviewTool(g.graphClient, g.name, g.logger)
alertsOverviewName := fmt.Sprintf("grafana_%s_alerts_overview", g.name)
alertsOverviewSchema := map[string]interface{}{
    "type": "object",
    "properties": map[string]interface{}{
        "severity": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by severity (Critical, Warning, Info)",
            "enum":        []string{"Critical", "Warning", "Info"},
        },
        "cluster": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by cluster name",
        },
        "service": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by service name",
        },
        "namespace": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by namespace",
        },
    },
    "required": []string{}, // All filters optional
}
if err := registry.RegisterTool(
    alertsOverviewName,
    "Get firing/pending alert counts by severity, cluster, and service. Shows flappiness indicators. Use this for high-level alert triage across the cluster.",
    alertsOverviewTool.Execute,
    alertsOverviewSchema,
); err != nil {
    return fmt.Errorf("failed to register alerts overview tool: %w", err)
}
g.logger.Info("Registered tool: %s", alertsOverviewName)
```

**Update success log from "Successfully registered 3 Grafana MCP tools" to "Successfully registered 4 Grafana MCP tools"**

**Pattern notes:**
- Tool naming follows grafana_{name}_alerts_overview convention (RESEARCH.md pitfall 4)
- Description guides AI on when to use tool (progressive disclosure - start here for triage)
- All parameters optional to maximize flexibility (RESEARCH.md pattern 3)
- Tool requires graphClient (passed to NewOverviewTool constructor)
  </action>
  <verify>
go build ./internal/integration/grafana/...
Package compiles successfully with new tool registration
grep "grafana_%s_alerts_overview" internal/integration/grafana/grafana.go
Registration code exists in RegisterTools method
  </verify>
  <done>
RegisterTools method includes alerts_overview tool registration with proper schema, tool name includes integration name, success log updated to "4 Grafana MCP tools"
  </done>
</task>

</tasks>

<verification>
Manual verification steps:
1. Build grafana package: `go build ./internal/integration/grafana/...`
2. Check tool exports: grep "type OverviewTool" internal/integration/grafana/tools_alerts_overview.go
3. Verify registration: grep "alerts_overview" internal/integration/grafana/grafana.go
4. Check nil service handling: grep "GetAnalysisService.*nil" internal/integration/grafana/tools_alerts_overview.go
</verification>

<success_criteria>
- tools_alerts_overview.go exists and compiles
- OverviewTool implements Execute method with all filter parameters optional
- Tool registered in RegisterTools with grafana_{name}_alerts_overview naming
- Flappiness detection uses 0.7 threshold from Phase 22
- Gracefully handles nil AlertAnalysisService (graph disabled)
- Response format minimizes tokens (compact AlertSummary with name + duration only)
</success_criteria>

<output>
After completion, create `.planning/phases/23-mcp-tools/23-01-SUMMARY.md`
</output>
