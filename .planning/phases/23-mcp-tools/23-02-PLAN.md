---
phase: 23-mcp-tools
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/tools_alerts_aggregated.go
  - internal/integration/grafana/tools_alerts_details.go
  - internal/integration/grafana/grafana.go
autonomous: true

must_haves:
  truths:
    - "AI can view specific alerts with 1h state progression timeline after identifying issues in overview"
    - "Aggregated tool shows state transitions as compact bucket notation [F F N N]"
    - "Aggregated tool includes analysis category (CHRONIC, NEW_ONSET, etc) inline"
    - "Details tool returns full state timeline with timestamps for deep debugging"
    - "Details tool includes alert rule definition and all labels"
  artifacts:
    - path: "internal/integration/grafana/tools_alerts_aggregated.go"
      provides: "Aggregated tool with state timeline buckets"
      min_lines: 180
      exports: ["AggregatedTool", "Execute"]
    - path: "internal/integration/grafana/tools_alerts_details.go"
      provides: "Details tool with full state history"
      min_lines: 150
      exports: ["DetailsTool", "Execute"]
    - path: "internal/integration/grafana/grafana.go"
      provides: "Registration for both aggregated and details tools"
      contains: ["grafana_%s_alerts_aggregated", "grafana_%s_alerts_details"]
  key_links:
    - from: "AggregatedTool.Execute"
      to: "buildStateTimeline helper"
      via: "state bucketization for compact display"
      pattern: "buildStateTimeline.*transitions"
    - from: "AggregatedTool.Execute"
      to: "AlertAnalysisService.AnalyzeAlert"
      via: "enrichment with categories and flappiness"
      pattern: "AnalyzeAlert.*Categories"
    - from: "DetailsTool.Execute"
      to: "graph STATE_TRANSITION query"
      via: "fetch full 7-day state history"
      pattern: "STATE_TRANSITION.*timestamp"
---

<objective>
Create two MCP tools that provide progressive drill-down from overview: `grafana_{name}_alerts_aggregated` shows specific alerts with compact 1h state timelines and analysis categories, `grafana_{name}_alerts_details` returns full state history and rule definitions for deep debugging.

Purpose: Enable AI to investigate specific alerts identified in overview tool without loading unnecessary detail upfront, following progressive disclosure pattern.

Output: Two tool files with state timeline formatting, analysis enrichment, and tool registration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-mcp-tools/23-CONTEXT.md
@.planning/phases/23-mcp-tools/23-RESEARCH.md
@.planning/phases/22-historical-analysis/22-01-SUMMARY.md
@.planning/phases/22-historical-analysis/22-02-SUMMARY.md
@.planning/phases/21-alert-sync-pipeline/21-01-SUMMARY.md

# Reference existing patterns
@internal/integration/grafana/tools_metrics_aggregated.go
@internal/integration/grafana/tools_metrics_details.go
@internal/integration/grafana/alert_analysis_service.go
@internal/integration/grafana/categorization.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Aggregated Tool with State Timeline Buckets</name>
  <files>internal/integration/grafana/tools_alerts_aggregated.go</files>
  <action>
Create tools_alerts_aggregated.go for focused alert investigation with compact state timelines:

**Type definitions:**
- AggregatedParams struct: lookback (duration string, default "1h"), severity, cluster, service, namespace (all optional filters)
- AggregatedResponse struct: alerts (array of AggregatedAlert), lookback, filters_applied, timestamp
- AggregatedAlert struct:
  - name, state (current), firing_duration
  - timeline (string: "[F F N N F F]" format)
  - category (string: "CHRONIC + flapping" from AlertCategories)
  - flappiness_score (float64)
  - transition_count (int: number of state changes in lookback window)
  - cluster, service, namespace

**Tool struct:**
- AggregatedTool with graphClient, integrationName, logger
- NewAggregatedTool constructor

**Execute method logic:**
1. Parse AggregatedParams (all filters optional, lookback defaults to "1h")
2. Parse lookback duration using time.ParseDuration (validate: 15m to 7d range)
3. Query graph for Alert nodes matching filters (same as overview tool)
4. For each alert, query STATE_TRANSITION edges in lookback window:
   - `MATCH (a:Alert {uid: $uid})-[t:STATE_TRANSITION]->() WHERE t.timestamp >= $startTime RETURN t ORDER BY t.timestamp`
5. Build compact state timeline using buildStateTimeline helper (see below)
6. Get AlertAnalysisService and enrich:
   - Call AnalyzeAlert(ctx, alert.UID)
   - Extract FlappinessScore and Categories
   - Format categories using formatCategory helper: "CHRONIC + flapping" or "RECENT + trending-worse"
   - Handle ErrInsufficientData: set category to "new (insufficient history)"
7. Count transitions in lookback window
8. Return AggregatedResponse with enriched alerts

**Helper function buildStateTimeline(transitions []StateTransition, lookback time.Duration) string:**
```go
// Compact state timeline using 10-minute buckets
func buildStateTimeline(transitions []StateTransition, lookback time.Duration) string {
    bucketDuration := 10 * time.Minute
    numBuckets := int(lookback / bucketDuration)
    if numBuckets > 60 {
        numBuckets = 60 // Cap at 10 hours for sanity
    }

    buckets := make([]string, numBuckets)
    endTime := time.Now()

    for i := 0; i < numBuckets; i++ {
        bucketEnd := endTime.Add(-time.Duration(numBuckets-i-1) * bucketDuration)

        // Find state at bucket end using LOCF (Last Observation Carried Forward)
        state := "N" // Default: normal
        for _, t := range transitions {
            if t.Timestamp.After(bucketEnd) {
                break // Past this bucket
            }
            state = stateToSymbol(t.ToState)
        }
        buckets[i] = state
    }

    return fmt.Sprintf("[%s]", strings.Join(buckets, " "))
}

func stateToSymbol(state string) string {
    switch strings.ToLower(state) {
    case "firing", "alerting":
        return "F"
    case "pending":
        return "P"
    case "normal", "resolved":
        return "N"
    default:
        return "?"
    }
}
```

**Helper function formatCategory(categories AlertCategories) string:**
```go
// Format multi-label categories for AI readability
func formatCategory(categories AlertCategories) string {
    parts := []string{}

    // Onset takes priority (more specific)
    if len(categories.Onset) > 0 {
        parts = append(parts, strings.ToUpper(categories.Onset[0]))
    }

    // Add pattern if different from onset
    if len(categories.Pattern) > 0 {
        pattern := categories.Pattern[0]
        if pattern != "stable-normal" || len(categories.Onset) == 0 {
            parts = append(parts, pattern)
        }
    }

    if len(parts) == 0 {
        return "unknown"
    }
    return strings.Join(parts, " + ")
}
```

**Key patterns:**
- 10-minute buckets: 6 per hour for 1h default lookback (CONTEXT.md decision)
- LOCF interpolation from Phase 22-01 (RESEARCH.md pattern 4)
- Left-to-right timeline (oldest→newest) for natural reading
- Category inline with timeline: "HighErrorRate: CHRONIC [F F F F F F]"
  </action>
  <verify>
go build internal/integration/grafana/tools_alerts_aggregated.go
File compiles, exports AggregatedTool type
grep "buildStateTimeline" internal/integration/grafana/tools_alerts_aggregated.go
Helper function exists for timeline bucketization
  </verify>
  <done>
tools_alerts_aggregated.go exists with ~180+ lines, implements state timeline bucketization with 10-minute buckets, enriches alerts with analysis categories, handles insufficient data gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Details Tool with Full State History</name>
  <files>internal/integration/grafana/tools_alerts_details.go</files>
  <action>
Create tools_alerts_details.go for deep debugging with full state history:

**Type definitions:**
- DetailsParams struct: alert_uid (string, optional), severity, cluster, service, namespace (optional filters for multi-alert mode)
- DetailsResponse struct: alerts (array of DetailAlert), timestamp
- DetailAlert struct:
  - name, state (current), uid
  - labels (map[string]string: all alert labels)
  - annotations (map[string]string: all annotations)
  - rule_definition (string: PromQL expression from condition field)
  - state_timeline (array of StatePoint)
  - analysis (optional AnalysisDetail)
- StatePoint struct: timestamp (ISO8601), from_state, to_state, duration_in_state (string like "2h")
- AnalysisDetail struct: flappiness_score, category, deviation_score, baseline (StateDistribution)

**Tool struct:**
- DetailsTool with graphClient, integrationName, logger
- NewDetailsTool constructor

**Execute method logic:**
1. Parse DetailsParams (alert_uid OR filters required - at least one)
2. Query graph for Alert nodes:
   - If alert_uid provided: `MATCH (a:Alert {uid: $uid, integration: $integration})`
   - Otherwise: use filters like aggregated tool
3. For each alert:
   a. Fetch full 7-day state transition history:
      - `MATCH (a:Alert {uid: $uid})-[t:STATE_TRANSITION]->() WHERE t.timestamp >= $sevenDaysAgo RETURN t ORDER BY t.timestamp`
   b. Build StatePoint array with duration calculation:
      - For each transition, compute duration_in_state from previous transition
      - Format as "2h 15m" or "45m" using time.Duration.String()
   c. Get AlertAnalysisService and fetch full analysis:
      - Call AnalyzeAlert(ctx, alert.UID)
      - Include all fields: FlappinessScore, DeviationScore, Categories, Baseline
      - Handle ErrInsufficientData: omit analysis section entirely
   d. Extract rule definition from alert.condition field (first PromQL expression)
   e. Include all labels and annotations (full alert metadata)
4. Return DetailResponse with complete alert details

**Warning in tool description:**
"Use this for deep investigation of specific alerts. Returns full state history and rule definitions. For multiple alerts, response may be large - prefer aggregated tool for multi-alert summaries."

**Key patterns:**
- Full 7-day history (matches Phase 22 AnalyzeAlert lookback)
- StatePoint array with explicit timestamps (not buckets) for precise debugging
- Duration calculation between transitions using LOCF
- Alert rule definition from condition field (Phase 20-02 stores first PromQL expression)
- Optional analysis section (only included if sufficient data available)
  </action>
  <verify>
go build internal/integration/grafana/tools_alerts_details.go
File compiles, exports DetailsTool type
grep "STATE_TRANSITION" internal/integration/grafana/tools_alerts_details.go
Graph query for full state history exists
  </verify>
  <done>
tools_alerts_details.go exists with ~150+ lines, fetches 7-day state history, includes rule definition and all metadata, provides optional analysis enrichment
  </done>
</task>

<task type="auto">
  <name>Task 3: Register Aggregated and Details Tools</name>
  <files>internal/integration/grafana/grafana.go</files>
  <action>
Update RegisterTools method to register aggregated and details tools after overview tool (continuing from Plan 01):

**Add after alerts_overview tool registration:**
```go
// Register Alerts Aggregated tool: grafana_{name}_alerts_aggregated
alertsAggregatedTool := NewAggregatedTool(g.graphClient, g.name, g.logger)
alertsAggregatedName := fmt.Sprintf("grafana_%s_alerts_aggregated", g.name)
alertsAggregatedSchema := map[string]interface{}{
    "type": "object",
    "properties": map[string]interface{}{
        "lookback": map[string]interface{}{
            "type":        "string",
            "description": "Lookback duration (e.g., '1h', '6h', '24h'). Default: '1h'",
            "default":     "1h",
        },
        "severity": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by severity (Critical, Warning, Info)",
            "enum":        []string{"Critical", "Warning", "Info"},
        },
        "cluster": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by cluster name",
        },
        "service": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by service name",
        },
        "namespace": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by namespace",
        },
    },
    "required": []string{}, // All parameters optional
}
if err := registry.RegisterTool(
    alertsAggregatedName,
    "Get specific alerts with compact state timeline ([F F N N] format) and analysis categories. Shows 1h state progression by default (configurable). Use after identifying issues in overview to investigate specific alerts.",
    alertsAggregatedTool.Execute,
    alertsAggregatedSchema,
); err != nil {
    return fmt.Errorf("failed to register alerts aggregated tool: %w", err)
}
g.logger.Info("Registered tool: %s", alertsAggregatedName)

// Register Alerts Details tool: grafana_{name}_alerts_details
alertsDetailsTool := NewDetailsTool(g.graphClient, g.name, g.logger)
alertsDetailsName := fmt.Sprintf("grafana_%s_alerts_details", g.name)
alertsDetailsSchema := map[string]interface{}{
    "type": "object",
    "properties": map[string]interface{}{
        "alert_uid": map[string]interface{}{
            "type":        "string",
            "description": "Optional: specific alert UID to investigate",
        },
        "severity": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by severity (Critical, Warning, Info)",
            "enum":        []string{"Critical", "Warning", "Info"},
        },
        "cluster": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by cluster name",
        },
        "service": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by service name",
        },
        "namespace": map[string]interface{}{
            "type":        "string",
            "description": "Optional: filter by namespace",
        },
    },
    "required": []string{}, // All parameters optional
}
if err := registry.RegisterTool(
    alertsDetailsName,
    "Get full state timeline (7 days) with timestamps, alert rule definition, and complete metadata. Use for deep debugging of specific alerts. Warning: multiple alerts may produce large responses.",
    alertsDetailsTool.Execute,
    alertsDetailsSchema,
); err != nil {
    return fmt.Errorf("failed to register alerts details tool: %w", err)
}
g.logger.Info("Registered tool: %s", alertsDetailsName)
```

**Update success log from "Successfully registered 4 Grafana MCP tools" (from Plan 01) to "Successfully registered 6 Grafana MCP tools"**

**Pattern notes:**
- Tool descriptions guide progressive disclosure: overview → aggregated → details
- All parameters optional (alert_uid OR filters)
- Lookback parameter with default value in aggregated tool
- Warning about large responses in details tool description
  </action>
  <verify>
go build ./internal/integration/grafana/...
Package compiles with all three alert tools registered
grep "alerts_aggregated\|alerts_details" internal/integration/grafana/grafana.go
Both tools registered in RegisterTools method
  </verify>
  <done>
RegisterTools includes alerts_aggregated and alerts_details tool registration, success log updated to "6 Grafana MCP tools", tool descriptions guide progressive disclosure usage
  </done>
</task>

</tasks>

<verification>
Manual verification steps:
1. Build grafana package: `go build ./internal/integration/grafana/...`
2. Check exports: grep "type AggregatedTool\|type DetailsTool" internal/integration/grafana/tools_alerts_*.go
3. Verify state timeline: grep "buildStateTimeline" internal/integration/grafana/tools_alerts_aggregated.go
4. Check registration: grep -c "alerts_" internal/integration/grafana/grafana.go (should show 3 occurrences)
5. Verify tool count log: grep "6 Grafana MCP tools" internal/integration/grafana/grafana.go
</verification>

<success_criteria>
- tools_alerts_aggregated.go and tools_alerts_details.go exist and compile
- Aggregated tool implements 10-minute bucket timeline with LOCF interpolation
- Aggregated tool enriches with analysis categories formatted as "CHRONIC + flapping"
- Details tool fetches 7-day state history with explicit timestamps
- Details tool includes rule definition and full metadata
- Both tools registered with grafana_{name}_alerts_* naming pattern
- All filter parameters optional for maximum flexibility
- Tool descriptions guide AI on progressive disclosure workflow
</success_criteria>

<output>
After completion, create `.planning/phases/23-mcp-tools/23-02-SUMMARY.md`
</output>
