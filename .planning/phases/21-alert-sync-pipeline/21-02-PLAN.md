---
phase: 21-alert-sync-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - internal/integration/grafana/alert_state_syncer.go
  - internal/integration/grafana/alert_state_syncer_test.go
  - internal/integration/grafana/integration.go
autonomous: true

must_haves:
  truths:
    - "AlertStateSyncer runs on independent 5-minute timer"
    - "State transitions are deduplicated (only actual changes stored)"
    - "Per-alert last_synced_at timestamp tracks staleness"
    - "Sync continues with stale data on Grafana API errors"
    - "AlertStateSyncer starts/stops with Grafana integration lifecycle"
  artifacts:
    - path: "internal/integration/grafana/alert_state_syncer.go"
      provides: "Periodic alert state sync with deduplication"
      contains: "type AlertStateSyncer struct"
      min_lines: 150
    - path: "internal/integration/grafana/alert_state_syncer_test.go"
      provides: "AlertStateSyncer unit tests"
      contains: "TestAlertStateSyncer"
    - path: "internal/integration/grafana/integration.go"
      provides: "AlertStateSyncer lifecycle wiring"
      contains: "stateSyncer"
  key_links:
    - from: "AlertStateSyncer.syncStates"
      to: "GrafanaClient.GetAlertStates"
      via: "method call"
      pattern: "client\\.GetAlertStates"
    - from: "AlertStateSyncer.syncStates"
      to: "GraphBuilder.CreateStateTransitionEdge"
      via: "method call on state change"
      pattern: "builder\\.CreateStateTransitionEdge"
    - from: "Integration.Start"
      to: "AlertStateSyncer.Start"
      via: "goroutine launch"
      pattern: "stateSyncer\\.Start"
---

<objective>
Create AlertStateSyncer that periodically fetches alert states, deduplicates transitions, and tracks per-alert staleness. Wire into Grafana integration lifecycle for automatic state monitoring.

Purpose: Enable continuous alert state timeline tracking with graceful error handling and efficient storage.
Output: AlertStateSyncer with 5-minute sync interval, deduplication logic, staleness tracking, unit tests, and integration lifecycle wiring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-alert-sync-pipeline/21-CONTEXT.md
@.planning/phases/21-alert-sync-pipeline/21-RESEARCH.md
@internal/integration/grafana/alert_syncer.go
@internal/integration/grafana/dashboard_syncer.go
@internal/integration/grafana/integration.go
</context>

<tasks>

<task type="auto">
  <name>Create AlertStateSyncer with deduplication</name>
  <files>internal/integration/grafana/alert_state_syncer.go</files>
  <action>
Create AlertStateSyncer following existing AlertSyncer patterns (Phase 20) with state-specific logic.

**File structure:**
```go
package grafana

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/moolen/spectre/internal/graph"
    "github.com/moolen/spectre/internal/logging"
)

// AlertStateSyncer orchestrates periodic alert state synchronization
type AlertStateSyncer struct {
    client          GrafanaClientInterface
    graphClient     graph.Client
    builder         *GraphBuilder
    integrationName string
    logger          *logging.Logger

    syncInterval time.Duration  // 5 minutes per CONTEXT.md
    ctx          context.Context
    cancel       context.CancelFunc
    stopped      chan struct{}

    // Thread-safe sync status
    mu              sync.RWMutex
    lastSyncTime    time.Time
    transitionCount int
    lastError       error
    inProgress      bool
}
```

**Constructor:** NewAlertStateSyncer with 5*time.Minute default interval.

**Start method:** Same pattern as AlertSyncer - initial sync + background loop.

**Stop method:** Cancel context, wait for stopped channel with 5s timeout.

**syncStates method (core logic):**
1. Call client.GetAlertStates(ctx)
2. For each AlertState, aggregate instance states to worst case:
   - If any instance is "firing" -> alert state is "firing"
   - Else if any instance is "pending" -> alert state is "pending"
   - Else -> alert state is "normal"
3. For each alert:
   - Call builder.getLastKnownState(ctx, alertUID)
   - Compare current vs last state
   - If different: call builder.CreateStateTransitionEdge(ctx, alertUID, lastState, currentState, time.Now())
   - Update alert node: `SET a.last_synced_at = $now` (per RESEARCH.md Pattern 4)
4. Track metrics: transitionCount (only actual transitions, not skipped)
5. Log summary: "%d transitions stored, %d skipped (no change)"

**Error handling per CONTEXT.md:**
- On API error: log warning, set lastError, DON'T update lastSyncTime
- On graph error: log warning, continue with other alerts
- Partial failures OK - sync what succeeded

**Deduplication:**
- getLastKnownState returns "unknown" on first sync -> creates initial transition
- Subsequent syncs: only create edge if currentState != lastState
- Handles consecutive same-state syncs per RESEARCH.md Pattern 3

**Staleness tracking:**
- Update last_synced_at ONLY on successful state fetch AND edge creation
- Per-alert granularity (not global timestamp per RESEARCH.md Pattern 4)
- No explicit stale flag - AI interprets timestamp age

**Logging verbosity:**
- Info: sync start/complete with summary stats
- Debug: per-alert state changes ("Alert %s: %s -> %s")
- Warn: API errors, graph errors for individual alerts
- Error: Only for total sync failure (all alerts failed)
  </action>
  <verify>
Build passes: `go build ./internal/integration/grafana`
AlertStateSyncer struct matches pattern from AlertSyncer.
syncStates method implements deduplication logic.
Default sync interval is 5 minutes.
last_synced_at updated only on success.
  </verify>
  <done>
AlertStateSyncer type exists with fields matching AlertSyncer pattern.
syncStates method aggregates instance states and deduplicates transitions.
Per-alert last_synced_at timestamp updated on successful sync.
Errors logged but don't stop sync for other alerts.
  </done>
</task>

<task type="auto">
  <name>Add AlertStateSyncer tests</name>
  <files>internal/integration/grafana/alert_state_syncer_test.go</files>
  <action>
Create unit tests for AlertStateSyncer following alert_syncer_test.go patterns.

**Test cases:**

**TestAlertStateSyncer_SyncStates_Initial:**
- Mock GetAlertStates returns 2 alerts in different states
- Mock getLastKnownState returns "unknown" (first sync)
- Verify CreateStateTransitionEdge called 2 times (both create initial transitions)
- Verify last_synced_at updated for both alerts

**TestAlertStateSyncer_SyncStates_Deduplication:**
- Mock getLastKnownState returns "firing"
- Mock GetAlertStates returns alert still in "firing" state
- Verify CreateStateTransitionEdge NOT called (no state change)
- Verify last_synced_at still updated (successful sync even if no change)

**TestAlertStateSyncer_SyncStates_StateChange:**
- Mock getLastKnownState returns "normal"
- Mock GetAlertStates returns alert in "firing" state
- Verify CreateStateTransitionEdge called with from="normal", to="firing"
- Verify last_synced_at updated

**TestAlertStateSyncer_SyncStates_APIError:**
- Mock GetAlertStates returns error
- Verify lastError set
- Verify lastSyncTime NOT updated (staleness detection)
- Verify sync doesn't panic

**TestAlertStateSyncer_AggregateInstanceStates:**
- Test helper or inline test for aggregation logic:
  - 3 instances: [firing, normal, normal] -> "firing"
  - 3 instances: [pending, normal, normal] -> "pending"
  - 3 instances: [normal, normal, normal] -> "normal"
  - Empty instances array -> "normal"

**Mock setup:**
- Use mockGrafanaClient (or create interface mock if needed)
- Mock GraphClient.ExecuteQuery for getLastKnownState queries
- Mock GraphBuilder methods (may need to extract interface)
- Follow existing test patterns from alert_syncer_test.go

**Test utilities:**
- testLogger from existing tests
- Context with timeout (5s per test)
- Verify error messages match expected patterns
  </action>
  <verify>
Tests compile: `go test -c ./internal/integration/grafana`
All test cases pass: `go test ./internal/integration/grafana -run TestAlertStateSyncer`
Coverage includes deduplication, state aggregation, error handling.
Tests follow existing naming conventions.
  </verify>
  <done>
alert_state_syncer_test.go exists with 5+ test cases.
Tests verify deduplication logic (no edge created when state unchanged).
Tests verify state aggregation (worst-case instance state).
Tests verify staleness tracking (last_synced_at only on success).
All tests pass.
  </done>
</task>

<task type="auto">
  <name>Wire AlertStateSyncer into integration lifecycle</name>
  <files>internal/integration/grafana/integration.go</files>
  <action>
Add AlertStateSyncer to Grafana integration Start/Stop methods following existing AlertSyncer pattern.

**Changes to Integration struct:**
Add field: `stateSyncer *AlertStateSyncer`

**Changes to Start method:**
After existing `alertSyncer.Start(ctx)` call, add:
```go
// Start alert state syncer (5-minute interval for state tracking)
i.stateSyncer = NewAlertStateSyncer(
    i.client,
    i.graphClient,
    i.builder,
    i.config.Name,
    logger,
)
if err := i.stateSyncer.Start(ctx); err != nil {
    i.logger.Warn("Failed to start alert state syncer: %v", err)
    // Non-fatal - alert rules still work, just no state timeline
}
```

**Changes to Stop method:**
After existing cleanup, add:
```go
// Stop alert state syncer
if i.stateSyncer != nil {
    i.stateSyncer.Stop()
}
```

**Implementation notes:**
- State syncer failure is non-fatal (alert rules still synced)
- Both syncers share same GraphBuilder instance (already passed in)
- Independent timers: AlertSyncer (1 hour), AlertStateSyncer (5 minutes)
- No coordination needed between syncers (race condition handled by MERGE in graph methods)

**Comment update:**
Add comment above stateSyncer.Start:
`// Alert state syncer runs independently from rule syncer (5-min vs 1-hour interval)`
  </action>
  <verify>
Build passes: `go build ./internal/integration/grafana`
Integration struct has stateSyncer field.
Start method creates and starts AlertStateSyncer.
Stop method stops AlertStateSyncer if not nil.
State syncer failure doesn't prevent integration from starting.
  </verify>
  <done>
integration.go modified with stateSyncer field and lifecycle wiring.
AlertStateSyncer started after AlertSyncer in Start method.
AlertStateSyncer stopped in Stop method.
Both syncers use shared GraphBuilder instance.
  </done>
</task>

</tasks>

<verification>
- [ ] Build succeeds: `go build ./internal/integration/grafana`
- [ ] Tests pass: `go test ./internal/integration/grafana -run TestAlertStateSyncer`
- [ ] AlertStateSyncer implements periodic sync with 5-minute interval
- [ ] Deduplication prevents storing consecutive same-state syncs
- [ ] Per-alert last_synced_at timestamp tracks staleness
- [ ] API errors don't crash sync, continue with other alerts
- [ ] Integration Start/Stop methods wire AlertStateSyncer lifecycle
- [ ] Both AlertSyncer and AlertStateSyncer run independently
</verification>

<success_criteria>
AlertStateSyncer runs on 5-minute timer independent of AlertSyncer (1-hour).
State transitions are deduplicated - only store when state changes.
Per-alert last_synced_at timestamp updated only on successful sync.
Grafana API unavailability logs warning but leaves existing data intact.
AlertStateSyncer starts with Grafana integration and stops on shutdown.
Unit tests verify deduplication, state aggregation, and error handling.
</success_criteria>

<output>
After completion, create `.planning/phases/21-alert-sync-pipeline/21-02-SUMMARY.md`
</output>
