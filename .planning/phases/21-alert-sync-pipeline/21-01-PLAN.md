---
phase: 21-alert-sync-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/client.go
  - internal/integration/grafana/graph_builder.go
autonomous: true

must_haves:
  truths:
    - "GrafanaClient can fetch current alert states from Grafana API"
    - "Alert state transitions are stored as edges in FalkorDB"
    - "State deduplication prevents storing consecutive same-state syncs"
    - "State transitions have TTL for 7-day retention"
  artifacts:
    - path: "internal/integration/grafana/client.go"
      provides: "GetAlertStates method and AlertState types"
      contains: "func (c *GrafanaClient) GetAlertStates"
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "State transition edge creation and deduplication"
      contains: "CreateStateTransitionEdge"
  key_links:
    - from: "GetAlertStates"
      to: "/api/prometheus/grafana/api/v1/rules"
      via: "HTTP GET request"
      pattern: "/api/prometheus/grafana/api/v1/rules"
    - from: "CreateStateTransitionEdge"
      to: "FalkorDB"
      via: "GraphClient.ExecuteQuery"
      pattern: "STATE_TRANSITION.*timestamp"
---

<objective>
Extend Grafana client and graph builder with alert state tracking capabilities - API fetching and graph storage with deduplication.

Purpose: Enable continuous alert state monitoring by adding the foundational data layer for state transitions.
Output: Client method to fetch alert states from Grafana, graph builder methods to store state transitions with TTL and deduplication logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-alert-sync-pipeline/21-CONTEXT.md
@.planning/phases/21-alert-sync-pipeline/21-RESEARCH.md
@internal/integration/grafana/client.go
@internal/integration/grafana/graph_builder.go
@internal/integration/grafana/alert_syncer.go
</context>

<tasks>

<task type="auto">
  <name>Add GetAlertStates API client method</name>
  <files>internal/integration/grafana/client.go</files>
  <action>
Add alert state types and GetAlertStates method to GrafanaClient following Phase 20 patterns.

**Types to add (near AlertRule types):**
```go
// AlertState represents an alert rule with its current state and instances
type AlertState struct {
    UID       string          `json:"-"`        // Extracted from rule
    Title     string          `json:"-"`        // Extracted from rule
    State     string          `json:"state"`    // Alert rule evaluation state
    Instances []AlertInstance `json:"alerts"`   // Active alert instances
}

// AlertInstance represents a single alert instance (specific label combination)
type AlertInstance struct {
    Labels      map[string]string `json:"labels"`      // Alert instance labels
    State       string            `json:"state"`       // firing, pending, normal
    ActiveAt    *time.Time        `json:"activeAt"`    // When instance became active (nil if normal)
    Value       string            `json:"value"`       // Current metric value
}
```

**GetAlertStates method (add after GetAlertRule):**
Use `/api/prometheus/grafana/api/v1/rules` endpoint (Prometheus-compatible format from RESEARCH.md).
Parse response JSON to extract alert rules with instances.
Map state values: "alerting" -> "firing", normalize to lowercase.
Return AlertState slice with UID, Title extracted from rule group data.
Handle empty instances array (alert in normal state has no instances).

Follow existing patterns:
- Use http.NewRequestWithContext for cancellation
- Bearer token from secretWatcher.GetToken() (same as ListAlertRules)
- 30s client timeout already configured
- Return descriptive errors: `fmt.Errorf("failed to fetch alert states: %w", err)`

**Test consideration:** Method will be tested via AlertStateSyncer integration tests (no unit test needed here).
  </action>
  <verify>
Build passes: `go build ./internal/integration/grafana`
Types compile correctly with JSON tags.
Method signature matches GrafanaClientInterface (if interface exists, update it).
  </verify>
  <done>
GetAlertStates method exists in client.go.
AlertState and AlertInstance types defined with correct JSON mapping.
Method uses /api/prometheus/grafana/api/v1/rules endpoint.
  </done>
</task>

<task type="auto">
  <name>Add state transition graph methods with deduplication</name>
  <files>internal/integration/grafana/graph_builder.go</files>
  <action>
Extend GraphBuilder with two methods for alert state tracking following Phase 19 baseline cache TTL pattern.

**Method 1: CreateStateTransitionEdge**
```go
// CreateStateTransitionEdge stores an alert state transition with TTL
// Creates self-edge (Alert)-[STATE_TRANSITION]->(Alert) with properties:
// - from_state, to_state, timestamp, expires_at (7-day TTL)
func (gb *GraphBuilder) CreateStateTransitionEdge(
    ctx context.Context,
    alertUID string,
    fromState string,
    toState string,
    timestamp time.Time,
) error
```

Implementation:
- Calculate expires_at = timestamp + 7*24*time.Hour (matches 7-day retention from CONTEXT.md)
- Use MERGE pattern to ensure Alert node exists (handles race with rule sync)
- Create edge with properties: from_state, to_state, timestamp (RFC3339 string), expires_at (RFC3339 string)
- Edge direction: (a)-[t:STATE_TRANSITION]->(a) (self-edge per RESEARCH.md Pattern 2)
- Include integration field in Alert MATCH (ensures multi-Grafana support)

**Method 2: getLastKnownState**
```go
// getLastKnownState retrieves the most recent state for an alert
// Returns: state string, error
// Returns ("unknown", nil) if no previous state exists (not an error)
func (gb *GraphBuilder) getLastKnownState(
    ctx context.Context,
    alertUID string,
) (string, error)
```

Implementation:
- Query: `MATCH (a:Alert {uid: $uid, integration: $integration})-[t:STATE_TRANSITION]->(a) WHERE t.expires_at > $now RETURN t.to_state ORDER BY t.timestamp DESC LIMIT 1`
- Filter expired edges: `WHERE t.expires_at > $now` (TTL filtering per RESEARCH.md)
- Order by timestamp DESC, LIMIT 1 (most recent)
- Return result.Rows[0][0] as string
- Empty result -> return ("unknown", nil) NOT error (handles first sync gracefully per RESEARCH.md Pitfall 3)

**Error handling:**
- Graph query errors return error (API failures)
- Empty results are NOT errors (initial state is valid)
- Log debug messages for state transitions: "Alert %s: %s -> %s"

**Deduplication logic:** Caller compares getLastKnownState result to current state. Only create edge if different.
  </action>
  <verify>
Build passes: `go build ./internal/integration/grafana`
Methods follow GraphBuilder conventions (receiver gb, integration field usage).
TTL calculation correct: 7 days = 168 hours.
Query syntax valid Cypher (self-edge pattern, WHERE filter, ORDER BY DESC).
  </verify>
  <done>
CreateStateTransitionEdge method exists with correct signature and TTL logic.
getLastKnownState method exists with "unknown" default for missing state.
Methods use integration field for multi-Grafana support.
State transition edges expire after 7 days via expires_at property.
  </done>
</task>

</tasks>

<verification>
- [ ] Build succeeds: `go build ./internal/integration/grafana`
- [ ] GetAlertStates method added to client.go
- [ ] AlertState and AlertInstance types defined
- [ ] CreateStateTransitionEdge method added to graph_builder.go
- [ ] getLastKnownState method added to graph_builder.go
- [ ] All methods follow existing code patterns (error handling, logging style)
- [ ] 7-day TTL configured via expires_at timestamp
</verification>

<success_criteria>
GrafanaClient can fetch alert states from /api/prometheus/grafana/api/v1/rules endpoint.
GraphBuilder can create state transition edges with from_state, to_state, timestamp, expires_at properties.
GraphBuilder can query last known state with TTL filtering and handle missing state gracefully.
Code builds without errors and follows established patterns from Phase 20.
</success_criteria>

<output>
After completion, create `.planning/phases/21-alert-sync-pipeline/21-01-SUMMARY.md`
</output>
