---
phase: 18-query-execution-mcp-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/query_service.go
  - internal/integration/grafana/response_formatter.go
  - internal/integration/grafana/client.go
autonomous: true

must_haves:
  truths:
    - "GrafanaQueryService can execute dashboard queries via Grafana /api/ds/query"
    - "Query service handles time range parameters (from, to) in ISO8601 format"
    - "Query service formats Grafana response as time series with labels and values"
    - "Query service returns partial results when some panels fail"
  artifacts:
    - path: "internal/integration/grafana/query_service.go"
      provides: "Dashboard query execution with variable substitution"
      exports: ["GrafanaQueryService", "ExecuteDashboard"]
      min_lines: 150
    - path: "internal/integration/grafana/response_formatter.go"
      provides: "Time series response formatting for AI consumption"
      exports: ["DashboardQueryResult", "PanelResult", "MetricSeries"]
      min_lines: 80
    - path: "internal/integration/grafana/client.go"
      provides: "QueryDataSource method added"
      exports: ["QueryDataSource"]
      contains: "func.*QueryDataSource"
  key_links:
    - from: "internal/integration/grafana/query_service.go"
      to: "client.go QueryDataSource"
      via: "HTTP POST to /api/ds/query"
      pattern: "QueryDataSource.*scopedVars"
    - from: "internal/integration/grafana/query_service.go"
      to: "response_formatter.go"
      via: "Format Grafana response"
      pattern: "formatTimeSeriesResponse"
    - from: "internal/integration/grafana/query_service.go"
      to: "graph"
      via: "Fetch dashboard JSON from graph"
      pattern: "MATCH.*Dashboard.*uid"
---

<objective>
Build query execution service that executes Grafana dashboard queries via /api/ds/query endpoint with variable substitution and time series response formatting.

Purpose: Enable MCP tools to execute PromQL queries through Grafana API with proper authentication, variable handling, and AI-friendly response formatting.

Output: GrafanaQueryService with ExecuteDashboard method, QueryDataSource added to GrafanaClient, response formatter for time series data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-execution-mcp-tools/18-CONTEXT.md
@.planning/phases/18-query-execution-mcp-tools/18-RESEARCH.md

# Existing Grafana integration
@internal/integration/grafana/client.go
@internal/integration/grafana/graph_builder.go
@internal/integration/grafana/grafana.go
</context>

<tasks>

<task type="auto">
  <name>Add QueryDataSource method to GrafanaClient</name>
  <files>
    internal/integration/grafana/client.go
  </files>
  <action>
Add QueryDataSource method to GrafanaClient that POSTs to /api/ds/query endpoint with:
- Datasource UID in query request
- PromQL expression in query.expr field
- Time range (from, to) as epoch milliseconds
- scopedVars map for server-side variable substitution
- Proper HTTP connection pooling (MaxIdleConnsPerHost=20, MaxConnsPerHost=20) - critical for concurrent queries

Request format per RESEARCH.md Pattern 3:
```go
type QueryRequest struct {
    Queries []Query `json:"queries"`
    From    string  `json:"from"` // epoch milliseconds
    To      string  `json:"to"`
}

type Query struct {
    RefID         string                 `json:"refId"`
    Datasource    Datasource             `json:"datasource"`
    Expr          string                 `json:"expr"`
    Format        string                 `json:"format"` // "time_series"
    MaxDataPoints int                    `json:"maxDataPoints"` // 100
    IntervalMs    int                    `json:"intervalMs"` // 1000
    ScopedVars    map[string]ScopedVar   `json:"scopedVars,omitempty"`
}

type ScopedVar struct {
    Text  string `json:"text"`
    Value string `json:"value"`
}
```

Response format: Grafana returns results[refId].frames[] with schema.fields and data.values arrays.

CRITICAL: Always read response body to completion (io.ReadAll) before processing for HTTP connection reuse per Pitfall 2 in RESEARCH.md.

Tune HTTP transport if not already done:
```go
transport := &http.Transport{
    MaxIdleConns:        100,
    MaxConnsPerHost:     20,
    MaxIdleConnsPerHost: 20, // CRITICAL: default 2 causes churn
    IdleConnTimeout:     90 * time.Second,
}
```
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "func.*QueryDataSource" internal/integration/grafana/client.go shows new method
  </verify>
  <done>
GrafanaClient.QueryDataSource method exists, accepts datasource UID + query + time range + scopedVars, returns parsed QueryResponse, tunes HTTP transport for concurrent queries.
  </done>
</task>

<task type="auto">
  <name>Create response formatter for time series data</name>
  <files>
    internal/integration/grafana/response_formatter.go
  </files>
  <action>
Create response_formatter.go with types and formatting logic:

Types per RESEARCH.md Pattern 4:
```go
type DashboardQueryResult struct {
    DashboardUID   string         `json:"dashboard_uid"`
    DashboardTitle string         `json:"dashboard_title"`
    Panels         []PanelResult  `json:"panels"`          // Successful panels only
    Errors         []PanelError   `json:"errors,omitempty"` // Failed panels
    TimeRange      string         `json:"time_range"`
}

type PanelResult struct {
    PanelID    int            `json:"panel_id"`
    PanelTitle string         `json:"panel_title"`
    Query      string         `json:"query,omitempty"` // PromQL, only on empty results
    Metrics    []MetricSeries `json:"metrics"`
}

type PanelError struct {
    PanelID    int    `json:"panel_id"`
    PanelTitle string `json:"panel_title"`
    Query      string `json:"query"`
    Error      string `json:"error"`
}

type MetricSeries struct {
    Labels    map[string]string `json:"labels"`
    Unit      string            `json:"unit,omitempty"`
    Values    []DataPoint       `json:"values"`
}

type DataPoint struct {
    Timestamp string  `json:"timestamp"` // ISO8601
    Value     float64 `json:"value"`
}
```

Formatting logic:
- formatTimeSeriesResponse: Parse Grafana frames[] into MetricSeries
- Extract labels from frame.schema.fields[0].labels
- Extract unit from frame.schema.fields[1].config.unit if present
- Convert timestamps from epoch milliseconds to ISO8601 (time.Unix(ms/1000, 0).Format(time.RFC3339))
- Omit panels with no data (empty frames or no values)
- Include query text only when results are empty (per RESEARCH.md Pitfall 5)
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "type DashboardQueryResult" internal/integration/grafana/response_formatter.go shows struct
  </verify>
  <done>
response_formatter.go exists with DashboardQueryResult, PanelResult, MetricSeries types, formatTimeSeriesResponse function converts Grafana frames to AI-friendly format.
  </done>
</task>

<task type="auto">
  <name>Create GrafanaQueryService</name>
  <files>
    internal/integration/grafana/query_service.go
  </files>
  <action>
Create query_service.go with GrafanaQueryService following Pattern 1 from RESEARCH.md:

```go
type GrafanaQueryService struct {
    grafanaClient *GrafanaClient
    graphClient   graph.Client
    logger        *logging.Logger
}

func NewGrafanaQueryService(client *GrafanaClient, graphClient graph.Client, logger *logging.Logger) *GrafanaQueryService {
    return &GrafanaQueryService{...}
}

func (s *GrafanaQueryService) ExecuteDashboard(
    ctx context.Context,
    dashboardUID string,
    timeRange TimeRange,
    scopedVars map[string]string,
    maxPanels int, // 0 = all panels, >0 = limit for overview
) (*DashboardQueryResult, error) {
    // 1. Fetch dashboard JSON from graph
    query := `MATCH (d:Dashboard {uid: $uid}) RETURN d.json`

    // 2. Parse dashboard JSON, extract panels

    // 3. Filter panels if maxPanels > 0 (for overview tool)
    if maxPanels > 0 && len(panels) > maxPanels {
        panels = panels[:maxPanels]
    }

    // 4. Execute queries via client.QueryDataSource
    result := &DashboardQueryResult{
        DashboardUID: dashboardUID,
        Panels: make([]PanelResult, 0),
        Errors: make([]PanelError, 0),
    }

    for _, panel := range panels {
        panelResult, err := s.executePanel(ctx, panel, timeRange, scopedVars)
        if err != nil {
            // Partial results pattern (Pitfall 4) - don't fail entire request
            result.Errors = append(result.Errors, PanelError{...})
            continue
        }

        // Omit panels with no data (per CONTEXT.md decision)
        if len(panelResult.Metrics) == 0 {
            continue
        }

        result.Panels = append(result.Panels, panelResult)
    }

    return result, nil
}

func (s *GrafanaQueryService) executePanel(...) (*PanelResult, error) {
    // Convert timeRange.From/To to epoch milliseconds
    from, to := timeRange.ToGrafanaRequest()

    // Build scopedVars in Grafana format
    scopedVarsGrafana := make(map[string]ScopedVar)
    for k, v := range scopedVars {
        scopedVarsGrafana[k] = ScopedVar{Text: v, Value: v}
    }

    // Execute via client.QueryDataSource
    resp, err := s.grafanaClient.QueryDataSource(ctx, datasourceUID, query, from, to, scopedVarsGrafana)
    if err != nil {
        return nil, err
    }

    // Format response
    return formatTimeSeriesResponse(panel, resp)
}
```

TimeRange type per Pattern 5:
```go
type TimeRange struct {
    From string `json:"from"` // ISO8601
    To   string `json:"to"`
}

func (tr TimeRange) Validate() error {
    // Parse and validate ISO8601 timestamps
    // Ensure to > from
    // Max 7 days range
}

func (tr TimeRange) ToGrafanaRequest() (string, string) {
    // Parse ISO8601, convert to epoch milliseconds
}
```

Handle errors gracefully: log panel errors but continue with other panels (partial results pattern).
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "type GrafanaQueryService" internal/integration/grafana/query_service.go shows struct
grep -r "func.*ExecuteDashboard" internal/integration/grafana/query_service.go shows method
  </verify>
  <done>
GrafanaQueryService exists with ExecuteDashboard method, TimeRange type with validation, partial results pattern implemented, queries executed via client.QueryDataSource.
  </done>
</task>

</tasks>

<verification>
1. go build ./internal/integration/grafana/... completes without errors
2. GrafanaClient has QueryDataSource method with tuned HTTP transport
3. response_formatter.go defines DashboardQueryResult and formatting logic
4. GrafanaQueryService exists with ExecuteDashboard method
5. TimeRange validation ensures ISO8601 format and reasonable ranges
6. Partial results pattern: errors collected, not propagated
</verification>

<success_criteria>
- GrafanaClient.QueryDataSource method POSTs to /api/ds/query with proper request format
- HTTP transport tuned for concurrent queries (MaxIdleConnsPerHost=20)
- Response formatter converts Grafana frames to MetricSeries with ISO8601 timestamps
- GrafanaQueryService.ExecuteDashboard fetches dashboard from graph, executes panels, returns partial results
- TimeRange type validates ISO8601 timestamps and converts to epoch milliseconds
- Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-execution-mcp-tools/18-01-SUMMARY.md`
</output>
