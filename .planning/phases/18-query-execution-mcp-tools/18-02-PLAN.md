---
phase: 18-query-execution-mcp-tools
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - internal/integration/grafana/tools_metrics_overview.go
  - internal/integration/grafana/tools_metrics_aggregated.go
  - internal/integration/grafana/tools_metrics_details.go
autonomous: true

must_haves:
  truths:
    - "Overview tool executes only overview-level dashboards with 5 panels max"
    - "Aggregated tool executes drill-down dashboards filtered by service or namespace"
    - "Details tool executes detail-level dashboards with all panels"
    - "All tools accept scoping variables (cluster, region) as required parameters"
    - "Tools find dashboards by hierarchy level from graph"
  artifacts:
    - path: "internal/integration/grafana/tools_metrics_overview.go"
      provides: "Overview tool implementation"
      exports: ["OverviewTool", "Execute"]
      min_lines: 100
    - path: "internal/integration/grafana/tools_metrics_aggregated.go"
      provides: "Aggregated tool implementation"
      exports: ["AggregatedTool", "Execute"]
      min_lines: 120
    - path: "internal/integration/grafana/tools_metrics_details.go"
      provides: "Details tool implementation"
      exports: ["DetailsTool", "Execute"]
      min_lines: 100
  key_links:
    - from: "tools_metrics_overview.go"
      to: "query_service.go ExecuteDashboard"
      via: "Execute dashboards with maxPanels=5"
      pattern: "ExecuteDashboard.*maxPanels.*5"
    - from: "tools_metrics_aggregated.go"
      to: "graph"
      via: "Find drill-down dashboards by hierarchy"
      pattern: "hierarchy_level.*drilldown"
    - from: "tools_metrics_details.go"
      to: "query_service.go ExecuteDashboard"
      via: "Execute dashboards with maxPanels=0 (all)"
      pattern: "ExecuteDashboard.*maxPanels.*0"
---

<objective>
Implement three MCP tools (overview, aggregated, details) that execute Grafana queries with progressive disclosure based on dashboard hierarchy levels.

Purpose: Enable AI to explore metrics progressively from high-level overview to detailed drill-down, following dashboard hierarchy established in Phase 17.

Output: Three MCP tool implementations that query dashboards by hierarchy level and execute panels via GrafanaQueryService.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-execution-mcp-tools/18-CONTEXT.md
@.planning/phases/18-query-execution-mcp-tools/18-RESEARCH.md
@.planning/phases/18-query-execution-mcp-tools/18-01-SUMMARY.md

# Existing patterns
@internal/integration/victorialogs/tools_overview.go
@internal/integration/logzio/tools_overview.go
@internal/integration/grafana/query_service.go
@internal/integration/grafana/graph_builder.go
</context>

<tasks>

<task type="auto">
  <name>Create Overview tool</name>
  <files>
    internal/integration/grafana/tools_metrics_overview.go
  </files>
  <action>
Create tools_metrics_overview.go following Pattern 2 from RESEARCH.md and existing VictoriaLogs/Logz.io tool patterns:

```go
type OverviewTool struct {
    queryService *GrafanaQueryService
    graphClient  graph.Client
    logger       *logging.Logger
}

func NewOverviewTool(qs *GrafanaQueryService, gc graph.Client, logger *logging.Logger) *OverviewTool {
    return &OverviewTool{...}
}

type OverviewParams struct {
    From    string `json:"from"`    // ISO8601: "2026-01-23T10:00:00Z"
    To      string `json:"to"`      // ISO8601: "2026-01-23T11:00:00Z"
    Cluster string `json:"cluster"` // Required
    Region  string `json:"region"`  // Required
}

func (t *OverviewTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    var params OverviewParams
    json.Unmarshal(args, &params)

    // Validate time range
    timeRange := TimeRange{From: params.From, To: params.To}
    if err := timeRange.Validate(); err != nil {
        return nil, fmt.Errorf("invalid time range: %w", err)
    }

    // Build scoping variables (required per CONTEXT.md decision)
    scopedVars := map[string]string{
        "cluster": params.Cluster,
        "region":  params.Region,
    }

    // Find overview-level dashboards from graph
    dashboards, err := t.findDashboardsByHierarchy(ctx, "overview")
    if err != nil {
        return nil, fmt.Errorf("find overview dashboards: %w", err)
    }

    // Empty success when no dashboards match (per CONTEXT.md decision)
    if len(dashboards) == 0 {
        return map[string]interface{}{
            "dashboards": []interface{}{},
            "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
        }, nil
    }

    // Execute dashboards with maxPanels=5 (overview limit)
    results := make([]DashboardQueryResult, 0)
    for _, dash := range dashboards {
        result, err := t.queryService.ExecuteDashboard(
            ctx, dash.UID, timeRange, scopedVars, 5,
        )
        if err != nil {
            t.logger.Warn("Dashboard %s query failed: %v", dash.UID, err)
            continue
        }
        results = append(results, *result)
    }

    return map[string]interface{}{
        "dashboards": results,
        "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
    }, nil
}

func (t *OverviewTool) findDashboardsByHierarchy(ctx context.Context, level string) ([]Dashboard, error) {
    // Query graph for dashboards with hierarchy_level property
    query := `
        MATCH (d:Dashboard {hierarchy_level: $level})
        RETURN d.uid, d.title
        ORDER BY d.title
    `

    result, err := t.graphClient.ExecuteQuery(ctx, graph.GraphQuery{
        Query: query,
        Params: map[string]interface{}{"level": level},
    })
    // Parse results...
}
```

Follow existing tool patterns for error handling and response structure.
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "type OverviewTool" internal/integration/grafana/tools_metrics_overview.go shows struct
grep -r "ExecuteDashboard.*5" internal/integration/grafana/tools_metrics_overview.go shows maxPanels limit
  </verify>
  <done>
OverviewTool exists with Execute method, finds overview dashboards from graph, executes with maxPanels=5, requires cluster+region scoping variables, returns empty success when no dashboards match.
  </done>
</task>

<task type="auto">
  <name>Create Aggregated tool</name>
  <files>
    internal/integration/grafana/tools_metrics_aggregated.go
  </files>
  <action>
Create tools_metrics_aggregated.go following Pattern 2 from RESEARCH.md:

```go
type AggregatedTool struct {
    queryService *GrafanaQueryService
    graphClient  graph.Client
    logger       *logging.Logger
}

type AggregatedParams struct {
    From      string `json:"from"`
    To        string `json:"to"`
    Cluster   string `json:"cluster"`
    Region    string `json:"region"`
    Service   string `json:"service,omitempty"`   // Optional, one of service/namespace required
    Namespace string `json:"namespace,omitempty"` // Optional, one of service/namespace required
}

func (t *AggregatedTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    var params AggregatedParams
    json.Unmarshal(args, &params)

    // Validate time range
    timeRange := TimeRange{From: params.From, To: params.To}
    if err := timeRange.Validate(); err != nil {
        return nil, fmt.Errorf("invalid time range: %w", err)
    }

    // Require service OR namespace (per CONTEXT.md decision)
    if params.Service == "" && params.Namespace == "" {
        return nil, fmt.Errorf("either service or namespace must be specified")
    }

    // Build scoping variables (include service/namespace)
    scopedVars := map[string]string{
        "cluster": params.Cluster,
        "region":  params.Region,
    }
    if params.Service != "" {
        scopedVars["service"] = params.Service
    }
    if params.Namespace != "" {
        scopedVars["namespace"] = params.Namespace
    }

    // Find drill-down dashboards from graph
    dashboards, err := t.findDashboardsByHierarchy(ctx, "drilldown")
    if err != nil {
        return nil, fmt.Errorf("find drill-down dashboards: %w", err)
    }

    if len(dashboards) == 0 {
        return map[string]interface{}{
            "dashboards": []interface{}{},
            "service":    params.Service,
            "namespace":  params.Namespace,
            "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
        }, nil
    }

    // Execute all panels in drill-down dashboards (maxPanels=0)
    results := make([]DashboardQueryResult, 0)
    for _, dash := range dashboards {
        result, err := t.queryService.ExecuteDashboard(
            ctx, dash.UID, timeRange, scopedVars, 0,
        )
        if err != nil {
            t.logger.Warn("Dashboard %s query failed: %v", dash.UID, err)
            continue
        }
        results = append(results, *result)
    }

    return map[string]interface{}{
        "dashboards": results,
        "service":    params.Service,
        "namespace":  params.Namespace,
        "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
    }, nil
}
```

Use same findDashboardsByHierarchy pattern as overview tool but with level="drilldown".
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "type AggregatedTool" internal/integration/grafana/tools_metrics_aggregated.go shows struct
grep -r "service.*namespace" internal/integration/grafana/tools_metrics_aggregated.go shows parameter handling
  </verify>
  <done>
AggregatedTool exists with Execute method, finds drill-down dashboards, executes with maxPanels=0 (all panels), accepts service OR namespace parameters, includes them in scopedVars.
  </done>
</task>

<task type="auto">
  <name>Create Details tool</name>
  <files>
    internal/integration/grafana/tools_metrics_details.go
  </files>
  <action>
Create tools_metrics_details.go following Pattern 2 from RESEARCH.md:

```go
type DetailsTool struct {
    queryService *GrafanaQueryService
    graphClient  graph.Client
    logger       *logging.Logger
}

type DetailsParams struct {
    From    string `json:"from"`
    To      string `json:"to"`
    Cluster string `json:"cluster"`
    Region  string `json:"region"`
}

func (t *DetailsTool) Execute(ctx context.Context, args []byte) (interface{}, error) {
    var params DetailsParams
    json.Unmarshal(args, &params)

    // Validate time range
    timeRange := TimeRange{From: params.From, To: params.To}
    if err := timeRange.Validate(); err != nil {
        return nil, fmt.Errorf("invalid time range: %w", err)
    }

    // Build scoping variables
    scopedVars := map[string]string{
        "cluster": params.Cluster,
        "region":  params.Region,
    }

    // Find detail-level dashboards from graph
    dashboards, err := t.findDashboardsByHierarchy(ctx, "detail")
    if err != nil {
        return nil, fmt.Errorf("find detail dashboards: %w", err)
    }

    if len(dashboards) == 0 {
        return map[string]interface{}{
            "dashboards": []interface{}{},
            "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
        }, nil
    }

    // Execute all panels in detail dashboards (maxPanels=0)
    results := make([]DashboardQueryResult, 0)
    for _, dash := range dashboards {
        result, err := t.queryService.ExecuteDashboard(
            ctx, dash.UID, timeRange, scopedVars, 0,
        )
        if err != nil {
            t.logger.Warn("Dashboard %s query failed: %v", dash.UID, err)
            continue
        }
        results = append(results, *result)
    }

    return map[string]interface{}{
        "dashboards": results,
        "time_range": fmt.Sprintf("%s to %s", params.From, params.To),
    }, nil
}
```

Same structure as overview but with level="detail" and maxPanels=0.
  </action>
  <verify>
go build ./internal/integration/grafana/... succeeds
grep -r "type DetailsTool" internal/integration/grafana/tools_metrics_details.go shows struct
grep -r "findDashboardsByHierarchy.*detail" internal/integration/grafana/tools_metrics_details.go shows hierarchy level
  </verify>
  <done>
DetailsTool exists with Execute method, finds detail-level dashboards, executes with maxPanels=0 (all panels), requires cluster+region scoping variables.
  </done>
</task>

</tasks>

<verification>
1. go build ./internal/integration/grafana/... completes without errors
2. OverviewTool finds overview dashboards and executes with maxPanels=5
3. AggregatedTool finds drill-down dashboards and requires service OR namespace
4. DetailsTool finds detail dashboards and executes all panels
5. All tools validate time range and require cluster+region parameters
6. All tools return empty success when no dashboards match
</verification>

<success_criteria>
- Three tool files exist with Execute methods
- Tools query graph for dashboards by hierarchy_level property
- Overview limits to 5 panels, aggregated and details execute all panels
- Scoping variables (cluster, region) required in all tools
- Aggregated tool accepts service OR namespace parameters
- Tools return partial results when some dashboards fail
- Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-execution-mcp-tools/18-02-SUMMARY.md`
</output>
