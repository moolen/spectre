---
phase: 12-mcp-tools-overview-logs
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - internal/integration/logzio/tools_overview.go
  - internal/integration/logzio/tools_logs.go
  - internal/integration/logzio/logzio.go
autonomous: true

must_haves:
  truths:
    - "logzio_{name}_overview returns namespace severity breakdown (errors, warnings, other)"
    - "logzio_{name}_logs returns filtered raw logs with namespace required"
    - "Tools enforce result limits (overview: 1000 namespaces max, logs: 100 max)"
    - "Tools normalize response to common schema matching VictoriaLogs format"
    - "AI assistant can query Logz.io using same pattern as VictoriaLogs tools"
    - "Tools validate internal regex patterns and reject leading wildcards with helpful error message"
  artifacts:
    - path: "internal/integration/logzio/tools_overview.go"
      provides: "Overview tool with parallel aggregations"
      exports: ["OverviewTool"]
      min_lines: 150
    - path: "internal/integration/logzio/tools_logs.go"
      provides: "Logs tool with filtering"
      exports: ["LogsTool"]
      min_lines: 80
    - path: "internal/integration/logzio/logzio.go"
      provides: "RegisterTools implementation"
      contains: "func.*RegisterTools.*ToolRegistry"
  key_links:
    - from: "internal/integration/logzio/tools_overview.go"
      to: "client.QueryAggregation"
      via: "parallel goroutines for total/error/warning counts"
      pattern: "go func.*QueryAggregation"
    - from: "internal/integration/logzio/tools_logs.go"
      to: "client.QueryLogs"
      via: "Execute() method calling client"
      pattern: "t\\.ctx\\.Client\\.QueryLogs"
    - from: "internal/integration/logzio/logzio.go"
      to: "registry.RegisterTool"
      via: "tool name, description, schema registration"
      pattern: "registry\\.RegisterTool.*overview"

user_setup: []
---

<objective>
Implement MCP tools for Logz.io progressive disclosure (overview â†’ logs).

Purpose: Expose Logz.io data through MCP interface with same UX as VictoriaLogs tools, enabling AI assistants to explore logs consistently across backends.

Output: Two registered MCP tools (overview, logs) callable via MCP client.

**Scope note:** This phase implements overview and logs tools with log limits (max 100). Template limits (max 50) are out of scope for Phase 12 - they will be addressed in Phase 13 (patterns tool) when pattern mining is implemented.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-v1.2.md
@.planning/phases/12-mcp-tools-overview-logs/12-CONTEXT.md
@.planning/phases/12-mcp-tools-overview-logs/12-RESEARCH.md
@.planning/phases/12-mcp-tools-overview-logs/12-01-SUMMARY.md

# Reference implementation - VictoriaLogs tool patterns
@internal/integration/victorialogs/tools_overview.go
@internal/integration/victorialogs/tools_logs.go
@internal/integration/victorialogs/victorialogs.go

# Plan 01 outputs
@internal/integration/logzio/logzio.go
@internal/integration/logzio/client.go
@internal/integration/logzio/query.go
@internal/integration/logzio/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement overview tool with parallel severity aggregations</name>
  <files>
    internal/integration/logzio/tools_overview.go
  </files>
  <action>
Mirror VictoriaLogs OverviewTool structure exactly, adapted for Logz.io client.

**File: internal/integration/logzio/tools_overview.go**
- ToolContext struct{Client *Client, Logger *logging.Logger, Instance string} for dependency injection
- OverviewTool struct{ctx ToolContext}
- OverviewParams struct{TimeRangeParams (embedded), Namespace string optional}
  - TimeRangeParams: StartTime int64, EndTime int64 json tags
- OverviewResponse struct{TimeRange string, Namespaces []NamespaceSeverity, TotalLogs int}
- NamespaceSeverity struct{Namespace string, Errors int, Warnings int, Other int, Total int}

**Execute(ctx context.Context, args []byte) (interface{}, error):**
1. Unmarshal args to OverviewParams
2. Parse time range with defaults (parseTimeRange helper from VictoriaLogs pattern):
   - If StartTime == 0 and EndTime == 0: default to last 1 hour
   - Parse Unix seconds or milliseconds (detect by magnitude)
   - Return TimeRange{Start, End}
3. Build base QueryParams{TimeRange: timeRange, Namespace: params.Namespace}
4. Execute 3 parallel aggregation queries (channel pattern from VictoriaLogs):
   - Query 1: Total logs per namespace - Client.QueryAggregation(ctx, baseQuery, []string{"namespace"})
   - Query 2: Error logs - baseQuery with RegexMatch = GetErrorPattern()
   - Query 3: Warning logs - baseQuery with RegexMatch = GetWarningPattern()
   - **VALIDATION:** ValidateQueryParams is called internally by these queries to validate severity regex patterns (prevents leading wildcard performance issues)
   - Use resultCh := make(chan queryResult, 3) and collect results
   - queryResult struct{name string, result *AggregationResponse, err error}
5. Aggregate results into namespaceMap[string]*NamespaceSeverity
6. Calculate Other = Total - Errors - Warnings (clamped to 0 if negative)
7. Sort namespaces by Total descending
8. Return OverviewResponse with formatted time range

**Helper: parseTimeRange(params TimeRangeParams) TimeRange**
- Handle zero values: default to [now-1h, now]
- Detect Unix milliseconds (value > 10000000000) vs seconds
- Return TimeRange struct

Per CONTEXT.md: Include top 5 namespaces/pods with highest error counts - actually, looking at VictoriaLogs implementation, it returns ALL namespaces sorted by total. Context says "top 5 error sources" but VictoriaLogs returns all. Use VictoriaLogs pattern (return all, client can filter). Response already sorted by total descending, which shows error concentration.
  </action>
  <verify>
go build ./internal/integration/logzio/...
grep "QueryAggregation.*error" internal/integration/logzio/tools_overview.go (verify parallel queries)
go test ./internal/integration/logzio/... (compile check - integration tests not in scope)
  </verify>
  <done>
- OverviewTool struct implements Execute method
- Parallel aggregation queries for total/error/warning counts
- Results aggregated by namespace with severity breakdown
- parseTimeRange helper handles defaults and Unix timestamp formats
- Code compiles and matches VictoriaLogs pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement logs tool with filtering and limits</name>
  <files>
    internal/integration/logzio/tools_logs.go
  </files>
  <action>
Mirror VictoriaLogs LogsTool structure exactly.

**File: internal/integration/logzio/tools_logs.go**
- LogsTool struct{ctx ToolContext}
- LogsParams struct{TimeRangeParams (embedded), Namespace string required, Limit int optional, Level, Pod, Container string optional}
- LogsResponse struct{TimeRange string, Namespace string, Logs []LogEntry, Count int, Truncated bool}

**Execute(ctx context.Context, args []byte) (interface{}, error):**
1. Unmarshal args to LogsParams
2. Validate namespace required: return error if empty
3. Enforce limits per CONTEXT.md (max 100, not 500):
   - const MaxLimit = 100
   - const DefaultLimit = 100
   - If params.Limit == 0: set to DefaultLimit
   - If params.Limit > MaxLimit: clamp to MaxLimit
4. Parse time range with parseTimeRange helper (same as overview tool)
5. Build QueryParams{TimeRange, Namespace, Level, Pod, Container, Limit: params.Limit + 1} (fetch one extra for truncation detection)
6. **NO VALIDATION NEEDED:** Logs tool does NOT expose regex parameter to users - only namespace, pod, container, level filters are exposed. ValidateQueryParams (which checks for leading wildcards) is only relevant for overview tool's internal severity regex patterns.
7. Execute Client.QueryLogs(ctx, queryParams)
8. Check truncation: len(result.Logs) > params.Limit
9. Trim to requested limit if truncated
10. Return LogsResponse with formatted time range, logs array, count, truncated flag

**Why no wildcard validation here:** The logs tool exposes only structured filters (namespace, pod, container, level) to users, NOT raw regex queries. Leading wildcard validation in Plan 01's ValidateQueryParams protects the overview tool's internal severity detection regex (GetErrorPattern, GetWarningPattern), not user-provided parameters.

Difference from VictoriaLogs: Use MaxLimit = 100 (CONTEXT.md decision), not 500 from VictoriaLogs.
  </action>
  <verify>
go build ./internal/integration/logzio/...
grep "MaxLimit = 100" internal/integration/logzio/tools_logs.go (verify limit)
grep "namespace is required" internal/integration/logzio/tools_logs.go (verify validation)
  </verify>
  <done>
- LogsTool struct implements Execute method
- Namespace validation enforced (required parameter)
- Limits enforced: default 100, max 100 per CONTEXT.md
- Truncation detection via Limit+1 fetch pattern
- Code compiles and mirrors VictoriaLogs pattern
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire tools into RegisterTools and update Health check</name>
  <files>
    internal/integration/logzio/logzio.go
  </files>
  <action>
Complete integration lifecycle by implementing RegisterTools.

**Update logzio.go RegisterTools method:**
- Create ToolContext{Client: l.client, Logger: l.logger, Instance: l.name}
- Instantiate OverviewTool{ctx: toolCtx}
- Instantiate LogsTool{ctx: toolCtx}
- Define overview tool schema (mirror VictoriaLogs schema structure):
  - Tool name: fmt.Sprintf("logzio_%s_overview", l.name)
  - Description: "Get overview of log volume and severity by namespace for Logz.io {instance}. Returns namespace-level error, warning, and total log counts. Use this first to identify namespaces with high error rates before drilling into specific logs."
  - Schema: map[string]interface{} with properties:
    - start_time: integer, "Start timestamp (Unix seconds or milliseconds). Default: 1 hour ago"
    - end_time: integer, "End timestamp (Unix seconds or milliseconds). Default: now"
    - namespace: string, "Optional: filter to specific namespace"
  - Register via registry.RegisterTool(name, description, overviewTool.Execute, schema)
- Define logs tool schema:
  - Tool name: fmt.Sprintf("logzio_%s_logs", l.name)
  - Description: "Retrieve raw logs from Logz.io {instance} with filters. Namespace is required. Returns up to 100 log entries. Use after overview to investigate specific namespaces or errors."
  - Schema: map[string]interface{} with properties:
    - namespace: string, required: true, "Kubernetes namespace to query (required)"
    - start_time: integer, "Start timestamp (Unix seconds or milliseconds). Default: 1 hour ago"
    - end_time: integer, "End timestamp (Unix seconds or milliseconds). Default: now"
    - limit: integer, "Maximum logs to return (default: 100, max: 100)"
    - level: string, "Filter by log level (e.g., error, warn, info)"
    - pod: string, "Filter by pod name"
    - container: string, "Filter by container name"
  - **NOTE:** Schema does NOT expose regex/pattern parameter - only structured filters. Users cannot provide raw regex queries, so no leading wildcard exposure risk.
  - Register via registry.RegisterTool(name, description, logsTool.Execute, schema)

**Update Health() method:**
- If secretWatcher exists: call secretWatcher.IsHealthy()
  - If unhealthy: return IntegrationHealth{Healthy: false, Message: "API token not available"}
- If client exists: perform minimal health check (optional - can defer to tool execution)
  - Simple approach: Check if secretWatcher healthy (token available)
  - No actual API call needed in health check (expensive, rate limits)
- Return IntegrationHealth{Healthy: true, Message: "Logzio integration operational"}

Match VictoriaLogs tool naming pattern: {backend}_{instance}_{tool} for consistency.
  </action>
  <verify>
go build ./internal/integration/logzio/...
grep "logzio_.*_overview" internal/integration/logzio/logzio.go (verify tool naming)
grep "RegisterTool.*overview.*logs" internal/integration/logzio/logzio.go (verify both tools registered)
  </verify>
  <done>
- RegisterTools implementation complete with 2 tool registrations
- Tool schemas match VictoriaLogs parameter structure
- Tool names follow {backend}_{instance}_{tool} pattern
- Health() checks SecretWatcher status
- Both tools callable via MCP protocol
- Logs tool schema exposes only structured filters (no regex parameter)
  </done>
</task>

</tasks>

<verification>
After completion:

1. **Tool registration:** Verify 2 tools registered per integration instance
2. **Tool naming:** Confirm pattern logzio_{name}_overview and logzio_{name}_logs
3. **Overview response:** Check NamespaceSeverity includes Errors, Warnings, Other, Total
4. **Logs validation:** Verify namespace required, returns error if missing
5. **Limits enforced:** Verify logs tool max 100 entries (check constant)
6. **Parallel queries:** Verify overview tool uses 3 goroutines with channel collection
7. **Health check:** Verify degraded when secretWatcher unhealthy
8. **Schema security:** Confirm logs tool schema does NOT expose regex parameter (only structured filters)
9. **Validation scope:** Confirm ValidateQueryParams protects internal severity regex, not user parameters
</verification>

<success_criteria>
- Two MCP tools registered: logzio_{name}_overview and logzio_{name}_logs
- Overview tool returns namespace severity breakdown matching VictoriaLogs format
- Logs tool enforces namespace required, returns up to 100 logs with truncation flag
- Tool schemas expose time range, namespace, and filter parameters (NO regex exposure to users)
- Parallel aggregation pattern reduces overview latency (3 concurrent queries)
- Health check reflects SecretWatcher status
- Code compiles without errors
- Internal regex validation protects overview tool severity detection from leading wildcard performance issues
</success_criteria>

<output>
After completion, create `.planning/phases/12-mcp-tools-overview-logs/12-02-SUMMARY.md`

Include:
- Tool registration confirmation (tool names, schemas)
- Overview tool aggregation approach (parallel queries, namespace sorting)
- Logs tool limit enforcement (100 max per CONTEXT.md)
- Response format consistency with VictoriaLogs
- Health check behavior
- Validation scope clarification (internal regex only, no user-exposed regex in logs tool)
- Template limits deferred to Phase 13 (patterns tool)
- Any deviations from plan (if any)
</output>
