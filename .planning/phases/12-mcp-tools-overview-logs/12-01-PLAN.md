---
phase: 12-mcp-tools-overview-logs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/logzio/logzio.go
  - internal/integration/logzio/types.go
  - internal/integration/logzio/client.go
  - internal/integration/logzio/query.go
  - internal/integration/logzio/query_test.go
  - internal/integration/logzio/severity.go
autonomous: true

must_haves:
  truths:
    - "Logzio integration registers with factory system (logzio type available)"
    - "Client authenticates with Logz.io API using X-API-TOKEN header"
    - "Query builder generates valid Elasticsearch DSL from structured parameters"
    - "Integration uses SecretWatcher for dynamic token management"
    - "Query builder handles time ranges, namespace filters, and severity regexes"
  artifacts:
    - path: "internal/integration/logzio/logzio.go"
      provides: "Integration lifecycle (Start/Stop/Health) and factory registration"
      min_lines: 150
    - path: "internal/integration/logzio/client.go"
      provides: "HTTP client with X-API-TOKEN authentication and error handling"
      exports: ["Client", "NewClient"]
    - path: "internal/integration/logzio/query.go"
      provides: "Elasticsearch DSL query construction"
      exports: ["BuildLogsQuery", "BuildAggregationQuery"]
    - path: "internal/integration/logzio/types.go"
      provides: "Config, QueryParams, LogEntry response types"
      contains: "type Config struct"
    - path: "internal/integration/logzio/query_test.go"
      provides: "Query builder unit tests"
      min_lines: 100
  key_links:
    - from: "internal/integration/logzio/logzio.go"
      to: "integration.RegisterFactory"
      via: "init() function registration"
      pattern: "RegisterFactory\\(\"logzio\""
    - from: "internal/integration/logzio/client.go"
      to: "SecretWatcher"
      via: "GetToken() for X-API-TOKEN header"
      pattern: "secretWatcher\\.GetToken"
    - from: "internal/integration/logzio/query.go"
      to: "types.QueryParams"
      via: "parameter consumption in DSL builder"
      pattern: "func.*QueryParams"
---

<objective>
Bootstrap Logz.io integration with authentication, query builder, and factory registration.

Purpose: Establish foundation for MCP tools by implementing Elasticsearch DSL query construction, HTTP client with SecretWatcher integration, and factory registration pattern proven in VictoriaLogs.

Output: Complete Logz.io integration skeleton ready for tool registration (Plan 02).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP-v1.2.md
@.planning/STATE.md
@.planning/phases/12-mcp-tools-overview-logs/12-CONTEXT.md
@.planning/phases/12-mcp-tools-overview-logs/12-RESEARCH.md
@.planning/phases/11-secret-file-management/11-01-SUMMARY.md

# Reference implementation - VictoriaLogs patterns
@internal/integration/victorialogs/victorialogs.go
@internal/integration/victorialogs/types.go
@internal/integration/victorialogs/client.go
@internal/integration/victorialogs/query.go
@internal/integration/victorialogs/severity.go
@internal/integration/victorialogs/secret_watcher.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Logzio integration skeleton with factory registration</name>
  <files>
    internal/integration/logzio/logzio.go
    internal/integration/logzio/types.go
    internal/integration/logzio/severity.go
  </files>
  <action>
Mirror VictoriaLogs integration structure exactly.

**File: internal/integration/logzio/logzio.go**
- Package logzio with init() function registering "logzio" factory
- LogzioIntegration struct with fields: name, config, client, logger, registry, secretWatcher
- NewLogzioIntegration(name, configMap) factory function
  - Parse configMap to Config struct via JSON marshal/unmarshal
  - Validate config with config.Validate()
  - Return initialized integration (client nil until Start())
- Metadata() returns IntegrationMetadata{Name, Version: "0.1.0", Type: "logzio"}
- Start(ctx) lifecycle method:
  - Initialize SecretWatcher if config.UsesSecretRef() (create in-cluster client, get namespace from env)
  - Start SecretWatcher with watcher.Start(ctx)
  - Create HTTP client (net/http with 30s timeout)
  - Create Client wrapper with baseURL from config, httpClient, secretWatcher, logger
  - Set v.client = client
  - Return nil (no health check in bootstrap plan)
- Stop(ctx) lifecycle method: Stop SecretWatcher if exists
- Health(ctx) returns integration.IntegrationHealth{Healthy: true} (placeholder for Plan 02)
- RegisterTools(registry) stub returns nil (implemented in Plan 02)

**File: internal/integration/logzio/types.go**
- SecretRef struct{SecretName, Key string} with json/yaml tags
- Config struct{Region string, APITokenRef *SecretRef} with json/yaml tags
  - Region: one of "us", "eu", "uk", "au", "ca"
- Config.Validate() checks:
  - Region required and must be valid value
  - APITokenRef.Key required if APITokenRef specified
- Config.UsesSecretRef() bool helper
- Config.GetBaseURL() string returns Logz.io regional endpoint:
  - us: https://api.logz.io
  - eu: https://api-eu.logz.io
  - uk: https://api-uk.logz.io
  - au: https://api-au.logz.io
  - ca: https://api-ca.logz.io
- QueryParams struct{Namespace, Pod, Container, Level, RegexMatch string, TimeRange TimeRange, Limit int}
- TimeRange struct{Start, End time.Time} with IsZero() method
- LogEntry struct{Message string, Time time.Time, Namespace, Pod, Container, Level string} for response normalization
- AggregationGroup struct{Value string, Count int} for aggregation responses
- AggregationResponse struct{Groups []AggregationGroup}

**File: internal/integration/logzio/severity.go**
- Copy GetErrorPattern() from victorialogs/severity.go (reuse same regex patterns)
- Copy GetWarningPattern() from victorialogs/severity.go
- These patterns proven across 1000s of logs, no modification needed
  </action>
  <verify>
go build ./internal/integration/logzio/...
grep -r "RegisterFactory.*logzio" internal/integration/logzio/
go test ./internal/integration/logzio/... (no tests yet, should compile)
  </verify>
  <done>
- logzio.go registers factory in init()
- Types defined with Config.GetBaseURL() returning regional endpoints
- Severity patterns copied from VictoriaLogs
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Elasticsearch DSL query builder with authentication</name>
  <files>
    internal/integration/logzio/client.go
    internal/integration/logzio/query.go
    internal/integration/logzio/query_test.go
  </files>
  <action>
**File: internal/integration/logzio/client.go**
- Client struct with fields: baseURL string, httpClient *http.Client, secretWatcher *SecretWatcher, logger *logging.Logger
- NewClient(baseURL, httpClient, secretWatcher, logger) returns *Client
- QueryLogs(ctx, params QueryParams) (*QueryResponse, error):
  - Build query DSL via BuildLogsQuery(params)
  - Marshal to JSON
  - POST to {baseURL}/v1/search with X-API-TOKEN header from secretWatcher.GetToken()
  - Set Content-Type: application/json
  - Handle errors: 401/403 (auth failure), 429 (rate limit with helpful message), other status codes
  - Parse response JSON (Elasticsearch hits structure)
  - Normalize hits to []LogEntry via parseLogzioHit helper
  - Return QueryResponse{Logs: entries}
- QueryAggregation(ctx, params QueryParams, groupByFields []string) (*AggregationResponse, error):
  - Build aggregation DSL via BuildAggregationQuery(params, groupByFields)
  - Similar HTTP flow as QueryLogs
  - Parse aggregation buckets to []AggregationGroup
  - Return AggregationResponse{Groups: groups}
- parseLogzioHit(hit map[string]interface{}) LogEntry helper:
  - Extract _source map
  - Parse @timestamp as RFC3339
  - Map fields: message, kubernetes.namespace, kubernetes.pod_name, kubernetes.container_name, level
  - Use .keyword suffix NOT needed here (only in query filters)
  - Return normalized LogEntry

**File: internal/integration/logzio/query.go**
- BuildLogsQuery(params QueryParams) map[string]interface{}:
  - Build bool query with must clauses array
  - Time range clause: range @timestamp with gte/lte in RFC3339 format (params.TimeRange.Start.Format(time.RFC3339))
  - Namespace filter: term kubernetes.namespace.keyword (exact match, note .keyword suffix)
  - Pod filter: term kubernetes.pod_name.keyword if params.Pod non-empty
  - Container filter: term kubernetes.container_name.keyword if params.Container non-empty
  - Level filter: term level.keyword if params.Level non-empty
  - RegexMatch filter: regexp message with value params.RegexMatch, flags "ALL", case_insensitive true if params.RegexMatch non-empty
  - Return map with query.bool.must, size: params.Limit (default 100 if 0), sort: [@timestamp desc]
- BuildAggregationQuery(params QueryParams, groupByFields []string) map[string]interface{}:
  - Similar bool query structure as BuildLogsQuery
  - Add aggs section with terms aggregation on groupByFields[0] (typically "kubernetes.namespace.keyword")
  - field: append .keyword suffix to field name
  - size: 1000 (Logz.io max for aggregations)
  - order: _count desc
  - Return map with query, aggs, size: 0 (no hits, only aggregations)
- ValidateQueryParams(params QueryParams) error:
  - Check for leading wildcards in RegexMatch (starts with * or ?)
  - Return helpful error: "leading wildcard queries are not supported by Logz.io - try suffix wildcards or remove wildcard"
  - Enforce max limit: 500 (but Plan 02 tools will use 100)

**File: internal/integration/logzio/query_test.go**
- TestBuildLogsQuery: Verify DSL structure for basic query
- TestBuildLogsQueryWithFilters: Verify namespace, pod, container, level filters all present with .keyword suffix
- TestBuildLogsQueryTimeRange: Verify RFC3339 formatting of time range
- TestBuildLogsQueryRegexMatch: Verify regexp clause structure
- TestBuildAggregationQuery: Verify terms aggregation with .keyword field and size 1000
- TestValidateQueryParams_LeadingWildcard: Verify rejection of *prefix and ?prefix patterns
- Use table-driven tests for multiple scenarios

CRITICAL: Avoid using 'Authorization: Bearer' header - Logz.io uses 'X-API-TOKEN' header (research explicitly documents this).
  </action>
  <verify>
go test ./internal/integration/logzio/... -v -cover
grep "X-API-TOKEN" internal/integration/logzio/client.go (verify correct header)
grep "keyword" internal/integration/logzio/query.go (verify .keyword suffix in filters)
  </verify>
  <done>
- Client implements QueryLogs and QueryAggregation with X-API-TOKEN auth
- Query builder generates valid Elasticsearch DSL with .keyword suffixes on exact-match fields
- ValidateQueryParams rejects leading wildcard queries
- All query builder tests pass with >80% coverage
- No Bearer token pattern found in code (X-API-TOKEN confirmed)
  </done>
</task>

</tasks>

<verification>
After completion:

1. **Factory registration:** grep "logzio" internal/integration/registry_test.go or test integration creation
2. **Config validation:** Verify Config.Validate() rejects invalid regions and missing keys
3. **Query DSL correctness:** Review generated JSON in tests matches Elasticsearch 7.x format
4. **SecretWatcher integration:** Verify watcher started in Start() and stopped in Stop()
5. **Authentication header:** Confirm X-API-TOKEN used (not Bearer token)
6. **Test coverage:** go test -cover shows >80% for query.go and client.go
</verification>

<success_criteria>
- Logzio integration type registered and discoverable via factory system
- Client authenticates with X-API-TOKEN header populated from SecretWatcher
- BuildLogsQuery generates Elasticsearch DSL with correct .keyword suffixes on exact-match fields
- BuildAggregationQuery generates terms aggregation with size 1000
- ValidateQueryParams rejects leading wildcard queries with helpful error
- All unit tests pass with >80% coverage
- SecretWatcher lifecycle managed correctly (Start/Stop)
- Regional endpoint selection works (5 regions supported)
</success_criteria>

<output>
After completion, create `.planning/phases/12-mcp-tools-overview-logs/12-01-SUMMARY.md`

Include:
- Factory registration confirmation
- Query builder patterns established (DSL construction, .keyword usage)
- SecretWatcher integration approach
- Test coverage metrics
- Regional endpoint mapping
- Deviations from VictoriaLogs reference (if any)
</output>
