---
phase: 04-log-template-mining
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/logprocessing/normalize.go
  - internal/logprocessing/masking.go
  - internal/logprocessing/kubernetes.go
autonomous: true

must_haves:
  truths:
    - "JSON logs have message field extracted before templating"
    - "Logs are normalized (lowercase, trimmed) for consistent clustering"
    - "Variables are masked in templates (IPs, UUIDs, timestamps, K8s names)"
    - "HTTP status codes are preserved as literals in templates"
  artifacts:
    - path: "internal/logprocessing/normalize.go"
      provides: "Pre-processing for Drain input"
      exports: ["ExtractMessage", "PreProcess"]
      min_lines: 40
    - path: "internal/logprocessing/masking.go"
      provides: "Post-clustering variable masking"
      exports: ["AggressiveMask"]
      min_lines: 80
    - path: "internal/logprocessing/kubernetes.go"
      provides: "K8s-specific pattern detection"
      exports: ["MaskKubernetesNames"]
      min_lines: 30
  key_links:
    - from: "internal/logprocessing/normalize.go"
      to: "encoding/json"
      via: "JSON message extraction"
      pattern: "json\\.Unmarshal"
    - from: "internal/logprocessing/masking.go"
      to: "regexp"
      via: "Variable pattern matching"
      pattern: "regexp\\.MustCompile"
    - from: "internal/logprocessing/kubernetes.go"
      to: "regexp"
      via: "K8s resource name patterns"
      pattern: "k8sPodPattern\\.ReplaceAllString"
---

<objective>
Implement log normalization and variable masking pipeline for stable template generation.

Purpose: Transform raw logs into normalized form for Drain clustering, then mask variables in resulting templates to prevent pattern explosion while preserving semantic distinctions.

Output: Complete preprocessing (JSON extraction, normalization) and post-processing (aggressive masking, K8s patterns) pipeline ready for integration with Drain processor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-log-template-mining/04-RESEARCH.md
@.planning/phases/04-log-template-mining/04-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Create normalization logic for Drain preprocessing</name>
  <files>internal/logprocessing/normalize.go</files>
  <action>
Create `normalize.go` in `internal/logprocessing` with:

- ExtractMessage(rawLog string) string function:
  - Try parsing rawLog as JSON with encoding/json.Unmarshal into map[string]interface{}
  - If JSON parsing fails, return rawLog as-is (plain text log)
  - If JSON succeeds, try common message field names in order: "message", "msg", "log", "text", "_raw", "event"
  - Return first non-empty string field found
  - If no message field exists, return full rawLog (might be structured event log)
  - User decision from CONTEXT.md: "For JSON logs, extract and template the message/msg field only (ignore JSON structure)"

- PreProcess(rawLog string) string function:
  - Call ExtractMessage(rawLog) to get semantic message
  - Convert to lowercase with strings.ToLower() (case-insensitive clustering)
  - Trim whitespace with strings.TrimSpace()
  - Return normalized message ready for Drain
  - DO NOT mask variables yet - that happens post-clustering (user decision: "masking AFTER Drain clustering")

Import: encoding/json, strings

Research guidance from 04-RESEARCH.md: "Pre-tokenization: Strip known variable prefixes" but user decision overrides - minimal pre-processing, aggressive post-processing.
  </action>
  <verify>
go build ./internal/logprocessing
Test cases:
- ExtractMessage(`{"msg":"test"}`) returns "test"
- ExtractMessage("plain text") returns "plain text"
- PreProcess("  UPPERCASE  ") returns "uppercase"
  </verify>
  <done>
ExtractMessage handles JSON and plain text logs, PreProcess normalizes without masking, functions return expected outputs for test cases.
  </done>
</task>

<task type="auto">
  <name>Create aggressive variable masking for post-clustering</name>
  <files>internal/logprocessing/masking.go</files>
  <action>
Create `masking.go` in `internal/logprocessing` with:

Define regex patterns as package-level variables (compile once):
- ipv4Pattern: `\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b`
- ipv6Pattern: `\b[0-9a-fA-F:]+:[0-9a-fA-F:]+\b`
- uuidPattern: `\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b`
- timestampPattern: `\b\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?\b`
- unixTimestampPattern: `\b\d{10,13}\b`
- hexPattern: `\b0x[0-9a-fA-F]+\b`
- longHexPattern: `\b[0-9a-fA-F]{16,}\b`
- filePathPattern: `\b(/[a-zA-Z0-9_.-]+)+\b`
- windowsPathPattern: `\b[A-Z]:\\[a-zA-Z0-9_.\-\\]+\b`
- urlPattern: `\bhttps?://[a-zA-Z0-9.-]+[a-zA-Z0-9/._?=&-]*\b`
- emailPattern: `\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b`

AggressiveMask(template string) string function:
- Apply patterns in specific order (specific before generic):
  1. ipv6Pattern -> "<IP>"
  2. ipv4Pattern -> "<IP>"
  3. uuidPattern -> "<UUID>"
  4. timestampPattern -> "<TIMESTAMP>"
  5. unixTimestampPattern -> "<TIMESTAMP>"
  6. hexPattern -> "<HEX>"
  7. longHexPattern -> "<HEX>"
  8. urlPattern -> "<URL>"
  9. emailPattern -> "<EMAIL>"
  10. filePathPattern -> "<PATH>"
  11. windowsPathPattern -> "<PATH>"
  12. Call MaskKubernetesNames(template) (from kubernetes.go)
  13. maskNumbersExceptStatusCodes(template)
- Return masked template

maskNumbersExceptStatusCodes(template string) string helper:
- Split template into tokens with strings.Fields()
- For each token, check if it's a number
- Check surrounding 3 tokens (window) for status code context: "status", "code", "http", "returned", "response"
- If context found, preserve number as-is (user decision: "HTTP status codes preserved")
- Otherwise replace with "<NUM>"
- Return reassembled string
- User decision from CONTEXT.md: "returned 404 vs returned 500 stay distinct"

Import: regexp, strings

Use regexp.MustCompile() for pattern initialization (panic on invalid regex is acceptable).
  </action>
  <verify>
go build ./internal/logprocessing
Test cases:
- AggressiveMask("connected to 10.0.0.1") returns "connected to <IP>"
- AggressiveMask("returned 404 error") preserves "404" (status code context)
- AggressiveMask("processing 12345 items") returns "processing <NUM> items"
  </verify>
  <done>
AggressiveMask applies all masking patterns in correct order, HTTP status codes preserved, generic numbers masked, functions compile and return expected outputs.
  </done>
</task>

<task type="auto">
  <name>Create Kubernetes-specific pattern masking</name>
  <files>internal/logprocessing/kubernetes.go</files>
  <action>
Create `kubernetes.go` in `internal/logprocessing` with:

Define regex patterns for K8s resource naming conventions:
- k8sPodPattern: `\b[a-z0-9-]+-[a-z0-9]{8,10}-[a-z0-9]{5}\b`
  - Matches: nginx-deployment-66b6c48dd5-8w7xz (deployment-replicaset-pod pattern)
- k8sReplicaSetPattern: `\b[a-z0-9-]+-[a-z0-9]{8,10}\b`
  - Matches: nginx-deployment-66b6c48dd5 (deployment-replicaset pattern)

MaskKubernetesNames(template string) string function:
- Replace pod names first (more specific pattern): k8sPodPattern.ReplaceAllString(template, "<K8S_NAME>")
- Then replace replicaset names: k8sReplicaSetPattern.ReplaceAllString(template, "<K8S_NAME>")
- Return masked template
- Order matters: pod pattern is superset of replicaset pattern, must be applied first
- User decision from CONTEXT.md: "pod names (app-xyz-abc123) become <K8S_NAME>"

Import: regexp

Research guidance from 04-RESEARCH.md: "Kubernetes pod name pattern: <deployment>-<replicaset-hash>-<pod-hash>" and "Pre-tokenization: Strip known variable prefixes" - here we mask post-clustering per user decision.
  </action>
  <verify>
go build ./internal/logprocessing
Test cases:
- MaskKubernetesNames("pod nginx-deployment-66b6c48dd5-8w7xz started") returns "pod <K8S_NAME> started"
- MaskKubernetesNames("replicaset nginx-deployment-66b6c48dd5 created") returns "replicaset <K8S_NAME> created"
  </verify>
  <done>
MaskKubernetesNames correctly identifies and masks K8s pod and replicaset names, returns expected outputs for test patterns.
  </done>
</task>

</tasks>

<verification>
Package structure:
- internal/logprocessing/normalize.go exists with ExtractMessage and PreProcess
- internal/logprocessing/masking.go exists with AggressiveMask
- internal/logprocessing/kubernetes.go exists with MaskKubernetesNames

Functional checks:
- JSON logs have message field extracted: `ExtractMessage("{\"msg\":\"test\"}")` returns "test"
- Plain text logs pass through: `ExtractMessage("plain")` returns "plain"
- Normalization works: `PreProcess("  UPPERCASE  ")` returns "uppercase"
- IP masking works: `AggressiveMask("connect 1.2.3.4")` returns "connect <IP>"
- Status codes preserved: `AggressiveMask("returned 404")` keeps "404"
- K8s names masked: `MaskKubernetesNames("pod app-abc-xyz started")` returns "pod <K8S_NAME> started"
- Package compiles: `go build ./internal/logprocessing`

Two-phase processing verified:
- PreProcess does minimal normalization (NO variable masking)
- AggressiveMask does aggressive masking (AFTER clustering)
- This aligns with user decision: "masking AFTER Drain clustering"
</verification>

<success_criteria>
- [ ] normalize.go implements JSON message extraction with fallback to plain text
- [ ] PreProcess normalizes logs (lowercase, trim) without masking variables
- [ ] masking.go implements 11+ regex patterns for aggressive variable masking
- [ ] AggressiveMask preserves HTTP status codes per user decision
- [ ] kubernetes.go masks K8s pod and replicaset names with <K8S_NAME> placeholder
- [ ] All functions compile and return expected outputs for test cases
- [ ] Package compiles: `go build ./internal/logprocessing`
</success_criteria>

<output>
After completion, create `.planning/phases/04-log-template-mining/04-02-SUMMARY.md`
</output>
