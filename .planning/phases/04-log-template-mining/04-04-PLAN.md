---
phase: 04-log-template-mining
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - internal/logprocessing/rebalancer.go
  - internal/logprocessing/store_test.go
  - internal/logprocessing/masking_test.go
  - internal/logprocessing/normalize_test.go
autonomous: true

must_haves:
  truths:
    - "Low-count templates are pruned to prevent clutter"
    - "Similar templates are auto-merged to handle log format drift"
    - "Rebalancing runs periodically without blocking log processing"
    - "Template mining package is fully tested with >80% coverage"
  artifacts:
    - path: "internal/logprocessing/rebalancer.go"
      provides: "Count-based pruning and auto-merge logic"
      exports: ["TemplateRebalancer", "RebalanceConfig"]
      min_lines: 80
    - path: "internal/logprocessing/store_test.go"
      provides: "Integration tests for storage and pipeline"
      min_lines: 100
    - path: "internal/logprocessing/masking_test.go"
      provides: "Unit tests for masking patterns"
      min_lines: 80
    - path: "internal/logprocessing/normalize_test.go"
      provides: "Unit tests for normalization"
      min_lines: 60
  key_links:
    - from: "internal/logprocessing/rebalancer.go"
      to: "internal/logprocessing/store.go"
      via: "Rebalance operates on TemplateStore"
      pattern: "store\\.GetNamespaces\\(\\)"
    - from: "internal/logprocessing/rebalancer.go"
      to: "github.com/texttheater/golang-levenshtein"
      via: "Edit distance for template similarity"
      pattern: "levenshtein\\.DistanceForStrings"
---

<objective>
Add lifecycle management (rebalancing, pruning, auto-merge) and comprehensive test coverage for template mining package.

Purpose: Handle template drift over time with automatic pruning and merging, ensure package quality with thorough testing of normalization, masking, storage, and rebalancing logic.

Output: Production-ready log processing package with self-healing template management and >80% test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-log-template-mining/04-RESEARCH.md
@.planning/phases/04-log-template-mining/04-CONTEXT.md
@.planning/phases/04-log-template-mining/04-01-SUMMARY.md
@.planning/phases/04-log-template-mining/04-02-SUMMARY.md
@.planning/phases/04-log-template-mining/04-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create template rebalancing with pruning and auto-merge</name>
  <files>internal/logprocessing/rebalancer.go</files>
  <action>
Create `rebalancer.go` in `internal/logprocessing` with:

RebalanceConfig struct:
- PruneThreshold int (minimum occurrences to keep, default 10 per user decision)
- MergeInterval time.Duration (how often to run, default 5 minutes per user decision)
- SimilarityThreshold float64 (normalized edit distance for merging, default 0.7 for "loose clustering")

TemplateRebalancer struct:
- store *TemplateStore (reference to live store)
- config RebalanceConfig
- stopCh chan struct{} (graceful shutdown)

NewTemplateRebalancer(store *TemplateStore, config RebalanceConfig) *TemplateRebalancer constructor:
- Initialize with store, config, create stopCh
- Return rebalancer

Start(ctx context.Context) error method:
- Create ticker with config.MergeInterval
- Loop: select on ticker.C and ctx.Done()
- On ticker: call RebalanceAll(), log error if fails but continue
- On ctx.Done(): return nil (graceful shutdown)

Stop() method:
- Close stopCh to signal shutdown

RebalanceAll() error method:
- Get all namespaces: namespaces := store.GetNamespaces()
- For each namespace, call RebalanceNamespace(namespace)
- Return first error encountered (but continue processing other namespaces)

RebalanceNamespace(namespace string) error method:
- Get namespace templates: ns := store.namespaces[namespace] (with lock)
- Step 1: Prune low-count templates
  - For templateID, count in ns.counts:
    - If count < config.PruneThreshold:
      - Delete from ns.templates[templateID]
      - Delete from ns.counts[templateID]
- Step 2: Find and merge similar templates
  - Convert ns.templates to slice
  - For i := 0; i < len(templates); i++:
    - For j := i + 1; j < len(templates); j++:
      - If shouldMerge(templates[i], templates[j], config.SimilarityThreshold):
        - mergeTemplates(ns, templates[i], templates[j])

shouldMerge(t1, t2 *Template, threshold float64) bool helper:
- Calculate edit distance: distance := editDistance(t1.Pattern, t2.Pattern)
- Normalize by shorter template length: shorter := min(len(t1.Tokens), len(t2.Tokens))
- Compute similarity: similarity := 1.0 - float64(distance)/float64(shorter)
- Return similarity > threshold
- User decision from CONTEXT.md: "loose clustering" means aggressive merging at 0.7 threshold
- Use github.com/texttheater/golang-levenshtein for edit distance (stdlib doesn't have it)

mergeTemplates(ns *NamespaceTemplates, target, source *Template) helper:
- Add source.Count to target.Count
- Update target.LastSeen to max(target.LastSeen, source.LastSeen)
- Keep target.FirstSeen as min (earliest occurrence)
- Delete source from ns.templates and ns.counts
- Log merge: "Merged template %s into %s (similarity above threshold)"

editDistance(s1, s2 string) int helper:
- Use github.com/texttheater/golang-levenshtein/levenshtein.DistanceForStrings()
- Return edit distance

Import: context, time, sync, github.com/texttheater/golang-levenshtein/levenshtein

User decisions from CONTEXT.md: "Count-based expiry" with threshold 10, "Auto-merge similar templates periodically", "Persist every 5 minutes" (same interval for rebalancing).

Research pattern from 04-RESEARCH.md: "Count-Based Template Expiry with Auto-Merge" with similarity threshold for merging.
  </action>
  <verify>
go get github.com/texttheater/golang-levenshtein/levenshtein
go build ./internal/logprocessing
Test:
- Create store with 3 templates: t1 (count 5), t2 (count 15), t3 (count 20, very similar to t2)
- Run rebalancer.RebalanceAll()
- Verify t1 pruned (count < 10), t2 and t3 merged (similarity > 0.7)
  </verify>
  <done>
TemplateRebalancer implements periodic rebalancing with count-based pruning and similarity-based auto-merge, Start/Stop provide lifecycle, package compiles.
  </done>
</task>

<task type="auto">
  <name>Create comprehensive test suite for template mining</name>
  <files>
internal/logprocessing/normalize_test.go
internal/logprocessing/masking_test.go
internal/logprocessing/store_test.go
  </files>
  <action>
Create test files in `internal/logprocessing`:

**normalize_test.go:**
- TestExtractMessage_JSON: Test JSON message extraction
  - Input: `{"msg":"test message"}` -> Output: "test message"
  - Input: `{"message":"another test"}` -> Output: "another test"
  - Input: `{"log":"kubernetes log"}` -> Output: "kubernetes log"
  - Input: `{"no_msg_field":"value"}` -> Output: full JSON (fallback)
- TestExtractMessage_PlainText: Test plain text logs
  - Input: "plain text log" -> Output: "plain text log"
  - Input: "not valid json {" -> Output: "not valid json {"
- TestPreProcess: Test normalization
  - Input: "  UPPERCASE  " -> Output: "uppercase"
  - Input: `{"msg":"  Mixed Case  "}` -> Output: "mixed case"
- Verify PreProcess does NOT mask variables (that's post-clustering)

**masking_test.go:**
- TestAggressiveMask_IPs: Test IP masking
  - Input: "connected to 10.0.0.1" -> Output: "connected to <IP>"
  - Input: "ipv6 fe80::1" -> Output: "ipv6 <IP>"
- TestAggressiveMask_UUIDs: Test UUID masking
  - Input: "request 550e8400-e29b-41d4-a716-446655440000" -> Output: "request <UUID>"
- TestAggressiveMask_Timestamps: Test timestamp masking
  - Input: "at 2023-01-15T10:30:00Z" -> Output: "at <TIMESTAMP>"
  - Input: "unix 1673780400" -> Output: "unix <TIMESTAMP>"
- TestAggressiveMask_StatusCodes: Test status code preservation
  - Input: "returned 404 error" -> Output: "returned 404 error" (preserved)
  - Input: "http status code 500" -> Output: "http status code 500" (preserved)
  - Input: "processing 12345 items" -> Output: "processing <NUM> items" (masked)
- TestAggressiveMask_KubernetesNames: Test K8s pattern masking
  - Input: "pod nginx-66b6c48dd5-8w7xz started" -> Output: "pod <K8S_NAME> started"
  - Input: "replicaset app-abc123def45 ready" -> Output: "replicaset <K8S_NAME> ready"
- TestAggressiveMask_URLs: Test URL masking
  - Input: "fetched https://api.example.com/v1/data" -> Output: "fetched <URL>"
- TestAggressiveMask_Emails: Test email masking
  - Input: "user test@example.com logged in" -> Output: "user <EMAIL> logged in"

**store_test.go:**
- TestTemplateStore_Process: Test basic processing
  - Process "connected to 10.0.0.1" and "connected to 10.0.0.2"
  - Verify both return same templateID (masked to same pattern)
  - Verify template.Pattern == "connected to <ip>" (masked)
  - Verify template.Count == 2 (both logs counted)
- TestTemplateStore_NamespaceScoping: Test namespace isolation
  - Process same log in "ns1" and "ns2"
  - Verify different templateIDs (namespace-scoped)
  - Verify templates stored separately
- TestTemplateStore_Concurrency: Test thread safety
  - Launch 10 goroutines, each processing 100 logs
  - Use sync.WaitGroup to wait for completion
  - Verify no race conditions (run with `go test -race`)
  - Verify all logs accounted for in template counts
- TestPersistence_SnapshotLoad: Test persistence lifecycle
  - Create store, process logs, call Snapshot()
  - Create new store, call Load()
  - Verify templates restored correctly
  - Verify counts match
- TestRebalancer_Pruning: Test low-count template removal
  - Create templates with counts [5, 15, 20]
  - Set PruneThreshold=10
  - Run RebalanceNamespace()
  - Verify template with count=5 removed, others retained
- TestRebalancer_AutoMerge: Test similar template merging
  - Create two templates with patterns "connected to <IP>" and "connected to <IP> port <NUM>"
  - Set SimilarityThreshold=0.7
  - Run RebalanceNamespace()
  - Verify templates merged if similarity > threshold

Use testify/assert for assertions: `assert.Equal(t, expected, actual)`

Run tests: `go test -v -race -cover ./internal/logprocessing`

Target: >80% code coverage across all files
  </action>
  <verify>
go test -v -race -cover ./internal/logprocessing
All tests pass, no race conditions detected, coverage >80%
  </verify>
  <done>
Test suite covers normalization, masking, storage, persistence, and rebalancing with >80% code coverage, all tests pass including race detector, test suite comprehensive.
  </done>
</task>

</tasks>

<verification>
Package structure:
- internal/logprocessing/rebalancer.go exists with TemplateRebalancer
- internal/logprocessing/*_test.go files exist with comprehensive tests

Functional checks:
- Rebalancing: Low-count templates pruned, similar templates merged
- Pruning: Templates below PruneThreshold (10) removed
- Auto-merge: Templates with similarity >0.7 merged together
- Lifecycle: Start/Stop methods work, rebalancing runs periodically
- Tests: All test cases pass, including concurrency tests with race detector
- Coverage: `go test -cover ./internal/logprocessing` shows >80% coverage
- Package compiles: `go build ./internal/logprocessing`

Integration verification (full pipeline):
1. Create TemplateStore with config
2. Process 100 logs with varying patterns
3. Start PersistenceManager (5-minute snapshots)
4. Start TemplateRebalancer (5-minute rebalancing)
5. Verify templates created, counts tracked, low-count pruned, similar merged
6. Stop managers gracefully
7. Verify final snapshot saved to disk
8. Load snapshot in new store
9. Verify templates restored correctly

Requirements coverage:
- MINE-01: Drain algorithm extracts templates ✓
- MINE-02: Normalization + masking ✓
- MINE-03: Stable hashes (SHA-256) ✓
- MINE-04: Persistence to disk ✓
- MINE-05: Sampling not implemented yet (deferred to Phase 5 integration)
- MINE-06: Batching not implemented yet (deferred to Phase 5 integration)

Note: MINE-05 and MINE-06 (sampling and batching) are integration concerns - they belong in Phase 5 when wiring template mining to VictoriaLogs data source. The template mining package is integration-agnostic and processes logs fed to it.
</verification>

<success_criteria>
- [ ] TemplateRebalancer implements count-based pruning with threshold=10
- [ ] Auto-merge uses normalized edit distance with similarity threshold=0.7
- [ ] Start/Stop lifecycle methods for periodic rebalancing (default 5 minutes)
- [ ] normalize_test.go covers JSON extraction and plain text fallback
- [ ] masking_test.go covers all masking patterns (IPs, UUIDs, K8s names, status codes)
- [ ] store_test.go covers processing, namespace scoping, concurrency, persistence
- [ ] All tests pass: `go test -v -race ./internal/logprocessing`
- [ ] Test coverage >80%: `go test -cover ./internal/logprocessing`
- [ ] Package compiles: `go build ./internal/logprocessing`
- [ ] Requirements MINE-01 through MINE-04 satisfied (MINE-05/06 deferred to Phase 5)
</success_criteria>

<output>
After completion, create `.planning/phases/04-log-template-mining/04-04-SUMMARY.md`
</output>
