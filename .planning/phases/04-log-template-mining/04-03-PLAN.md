---
phase: 04-log-template-mining
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - internal/logprocessing/store.go
  - internal/logprocessing/persistence.go
autonomous: true

must_haves:
  truths:
    - "Templates are stored per-namespace (scoped isolation)"
    - "Each namespace has its own Drain instance"
    - "Templates persist to disk every 5 minutes"
    - "Templates survive server restarts (loaded from JSON snapshot)"
  artifacts:
    - path: "internal/logprocessing/store.go"
      provides: "Namespace-scoped template storage"
      exports: ["TemplateStore", "NamespaceTemplates"]
      min_lines: 100
    - path: "internal/logprocessing/persistence.go"
      provides: "Periodic JSON snapshots with atomic writes"
      exports: ["PersistenceManager", "SnapshotData"]
      min_lines: 80
  key_links:
    - from: "internal/logprocessing/store.go"
      to: "internal/logprocessing/drain.go"
      via: "Per-namespace DrainProcessor instances"
      pattern: "NewDrainProcessor\\(config\\)"
    - from: "internal/logprocessing/store.go"
      to: "internal/logprocessing/normalize.go"
      via: "PreProcess before Train"
      pattern: "PreProcess\\(logMessage\\)"
    - from: "internal/logprocessing/store.go"
      to: "internal/logprocessing/masking.go"
      via: "AggressiveMask on cluster templates"
      pattern: "AggressiveMask\\(cluster\\.String\\(\\)\\)"
    - from: "internal/logprocessing/persistence.go"
      to: "internal/logprocessing/store.go"
      via: "Snapshot serialization"
      pattern: "json\\.Marshal\\(store\\.templates\\)"
---

<objective>
Build namespace-scoped template storage with periodic disk persistence for crash recovery.

Purpose: Integrate Drain processor, normalization, and masking into a thread-safe storage layer that maintains per-namespace template state and persists snapshots to disk every 5 minutes.

Output: Complete storage and persistence layer ready for lifecycle management (rebalancing, pruning) in Plan 03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-log-template-mining/04-RESEARCH.md
@.planning/phases/04-log-template-mining/04-CONTEXT.md
@.planning/phases/04-log-template-mining/04-01-SUMMARY.md
@.planning/phases/04-log-template-mining/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create namespace-scoped template storage</name>
  <files>internal/logprocessing/store.go</files>
  <action>
Create `store.go` in `internal/logprocessing` with:

NamespaceTemplates struct:
- drain *DrainProcessor (per-namespace Drain instance)
- templates map[string]*Template (templateID -> Template)
- counts map[string]int (templateID -> occurrence count)
- mu sync.RWMutex (protects templates and counts maps)

TemplateStore struct:
- namespaces map[string]*NamespaceTemplates (namespace -> NamespaceTemplates)
- config DrainConfig (shared config for all namespaces)
- mu sync.RWMutex (protects namespaces map)

NewTemplateStore(config DrainConfig) *TemplateStore constructor:
- Initialize empty namespaces map
- Store config for creating per-namespace Drain instances
- Return initialized store

Process(namespace, logMessage string) (templateID string, err error) method:
- Lock store.mu for read to get/create namespace
- If namespace doesn't exist, create new NamespaceTemplates with NewDrainProcessor(store.config)
- Normalize log: normalized := PreProcess(logMessage)
- Train Drain: cluster := ns.drain.Train(normalized)
- Mask template: maskedPattern := AggressiveMask(cluster.String())
- Generate ID: templateID := GenerateTemplateID(namespace, maskedPattern)
- Lock ns.mu for write
- If template doesn't exist in ns.templates, create new Template with ID, Namespace, Pattern=maskedPattern, Tokens=cluster.Tokens(), Count=0, FirstSeen=now
- Increment ns.counts[templateID]
- Update template.Count and template.LastSeen
- Return templateID, nil

GetTemplate(namespace, templateID string) (*Template, error) method:
- Lock for read, lookup namespace
- If not found, return nil, ErrNamespaceNotFound
- Lock ns.mu for read, lookup template
- If not found, return nil, ErrTemplateNotFound
- Return deep copy of template (avoid mutation)

ListTemplates(namespace string) ([]Template, error) method:
- Lock for read, lookup namespace
- If not found, return nil, ErrNamespaceNotFound
- Lock ns.mu for read, copy templates to slice
- Return slice sorted by count descending (TemplateList.SortByCount())

GetNamespaces() []string method:
- Lock for read, return list of namespace keys

Import: sync, time, errors

User decision from CONTEXT.md: "Templates scoped per-namespace" and "In-memory with periodic disk snapshots".

Research pattern from 04-RESEARCH.md: "Namespace-Scoped Template Storage" with per-namespace Drain instances and composite keys.
  </action>
  <verify>
go build ./internal/logprocessing
Test:
- store := NewTemplateStore(DrainConfig{})
- templateID, _ := store.Process("default", "connected to 10.0.0.1")
- template, _ := store.GetTemplate("default", templateID)
- Verify: template.Pattern contains "<IP>" (masked)
  </verify>
  <done>
TemplateStore implements namespace-scoped storage with thread safety (RWMutex), Process method integrates normalization + Drain + masking pipeline, templates accessible via Get/List methods.
  </done>
</task>

<task type="auto">
  <name>Create periodic persistence with atomic writes</name>
  <files>internal/logprocessing/persistence.go</files>
  <action>
Create `persistence.go` in `internal/logprocessing` with:

SnapshotData struct (JSON serialization format):
- Version int (schema version, start with 1)
- Timestamp time.Time (snapshot creation time)
- Namespaces map[string]*NamespaceSnapshot (namespace -> snapshot)

NamespaceSnapshot struct:
- Templates []Template (serialized templates, not map)
- Counts map[string]int (templateID -> count)

PersistenceManager struct:
- store *TemplateStore (reference to live store)
- snapshotPath string (file path for JSON snapshots)
- snapshotInterval time.Duration (default 5 minutes per user decision)
- stopCh chan struct{} (for graceful shutdown)

NewPersistenceManager(store *TemplateStore, snapshotPath string, interval time.Duration) *PersistenceManager constructor:
- Initialize with provided store, path, interval
- Create stopCh
- Return manager

Start(ctx context.Context) error method:
- If snapshotPath exists, call Load() to restore state
- Create ticker with snapshotInterval
- Loop: select on ticker.C and ctx.Done()
- On ticker: call Snapshot(), log error if fails but continue (user decision: "lose at most 5 min on crash")
- On ctx.Done(): call Snapshot() one final time, return
- Requirement MINE-04: Canonical templates stored in MCP server for persistence

Snapshot() error method:
- Lock store for read
- Build SnapshotData with current timestamp, version=1
- For each namespace, copy templates and counts to NamespaceSnapshot
- Marshal to JSON with indentation (json.MarshalIndent for readability)
- Write to temp file: snapshotPath + ".tmp"
- Atomic rename: os.Rename(tmpPath, snapshotPath) (POSIX atomicity)
- Return error if any step fails
- Pattern from Phase 2: "Atomic writes prevent config corruption on crashes"

Load() error method:
- Read snapshotPath with os.ReadFile()
- If file doesn't exist, return nil (start empty per user decision)
- Unmarshal JSON into SnapshotData
- For each namespace in snapshot:
  - Create NamespaceTemplates with NewDrainProcessor(store.config)
  - Populate templates map and counts map
  - Store in store.namespaces[namespace]
- Return error if unmarshal fails (corrupted snapshot)

Stop() method:
- Close stopCh to trigger shutdown
- Wait for Start() goroutine to complete final snapshot

Import: context, encoding/json, os, time

User decision from CONTEXT.md: "Persist every 5 minutes" and "JSON format for persistence (human-readable, debuggable)".

Research pattern from 04-RESEARCH.md: "Periodic Disk Snapshots" with atomic writes using temp-file-then-rename.
  </action>
  <verify>
go build ./internal/logprocessing
Test sequence:
1. Create store, process some logs
2. Create manager: pm := NewPersistenceManager(store, "/tmp/test-snapshot.json", 1*time.Second)
3. Call pm.Snapshot() manually
4. Verify /tmp/test-snapshot.json exists and contains valid JSON
5. Create new store, create manager with same path
6. Call pm.Load()
7. Verify templates restored: store.ListTemplates("default") returns expected templates
  </verify>
  <done>
PersistenceManager implements periodic snapshots with atomic writes (temp + rename), Load restores state from JSON, Start/Stop provide lifecycle management, snapshots are human-readable JSON.
  </done>
</task>

</tasks>

<verification>
Package structure:
- internal/logprocessing/store.go exists with TemplateStore and NamespaceTemplates
- internal/logprocessing/persistence.go exists with PersistenceManager

Functional checks:
- Namespace scoping: Processing logs for "ns1" and "ns2" creates separate template spaces
- Pipeline integration: Process() calls PreProcess -> Train -> AggressiveMask -> GenerateTemplateID
- Thread safety: Multiple goroutines can call Process() concurrently (RWMutex protection)
- Persistence: Snapshot() creates JSON file, Load() restores templates
- Atomic writes: Snapshot uses temp-file-then-rename pattern
- Package compiles: `go build ./internal/logprocessing`

Integration verification:
- store := NewTemplateStore(DrainConfig{SimTh: 0.4})
- id1, _ := store.Process("default", "connected to 10.0.0.1")
- id2, _ := store.Process("default", "connected to 10.0.0.2")
- Verify id1 == id2 (same template for both IPs due to masking)
- template, _ := store.GetTemplate("default", id1)
- Verify template.Pattern == "connected to <IP>" (masked correctly)
- Verify template.Count == 2 (both logs counted)
</verification>

<success_criteria>
- [ ] TemplateStore provides namespace-scoped storage with per-namespace Drain instances
- [ ] Process() integrates normalization, Drain training, masking, and hashing pipeline
- [ ] Thread-safe operations using sync.RWMutex for concurrent access
- [ ] PersistenceManager implements periodic snapshots every 5 minutes (configurable)
- [ ] Snapshots use atomic writes (temp file + rename) to prevent corruption
- [ ] Load() restores templates from JSON snapshot on startup
- [ ] JSON format is human-readable with indentation
- [ ] Package compiles and integration test passes: `go build ./internal/logprocessing`
</success_criteria>

<output>
After completion, create `.planning/phases/04-log-template-mining/04-03-SUMMARY.md`
</output>
