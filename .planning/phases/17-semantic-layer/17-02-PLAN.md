---
phase: 17-semantic-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/graph_builder.go
  - internal/integration/grafana/types.go
  - internal/integration/grafana/graph_builder_test.go
autonomous: true

must_haves:
  truths:
    - "Dashboards have hierarchyLevel property (overview/drilldown/detail)"
    - "Hierarchy classification uses tags first, then fallback config"
    - "Config includes HierarchyMap for tag-to-level mapping"
    - "Default to 'detail' when no signals present"
  artifacts:
    - path: "internal/integration/grafana/types.go"
      provides: "HierarchyMap field in Config struct"
      contains: "HierarchyMap"
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "Hierarchy classification logic"
      contains: "classifyHierarchy"
  key_links:
    - from: "graph_builder.go:CreateDashboardGraph"
      to: "types.Config.HierarchyMap"
      via: "Fallback mapping lookup"
      pattern: "config.*HierarchyMap"
---

<objective>
Classify dashboards by hierarchy level (overview/drilldown/detail) using Grafana tags with configurable fallback mapping.

Purpose: Enable progressive disclosure in MCP tools by identifying which dashboards show high-level overview vs deep detail.

Output:
- Dashboard nodes include hierarchyLevel property
- Config supports HierarchyMap for fallback when tags absent
- Classification logic uses tags first, falls back to config, defaults to detail
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-semantic-layer/17-CONTEXT.md
@.planning/phases/17-semantic-layer/17-RESEARCH.md

# Existing types and graph builder
@internal/integration/grafana/types.go
@internal/integration/grafana/graph_builder.go
</context>

<tasks>

<task type="auto">
  <name>Add HierarchyMap to Config and extend Validate</name>
  <files>
internal/integration/grafana/types.go
  </files>
  <action>
1. Add `HierarchyMap` field to Config struct in `types.go`:
   ```go
   type Config struct {
       URL          string                 `json:"url" yaml:"url"`
       APITokenRef  *SecretRef             `json:"apiTokenRef,omitempty" yaml:"apiTokenRef,omitempty"`
       HierarchyMap map[string]string      `json:"hierarchyMap,omitempty" yaml:"hierarchyMap,omitempty"`
   }
   ```

2. Document HierarchyMap in struct comment:
   - Maps Grafana tag to hierarchy level
   - Example: `{"prod": "overview", "staging": "drilldown"}`
   - Used as fallback when dashboard lacks hierarchy tags
   - Optional field (omitempty)

3. Extend `Validate()` function:
   - If HierarchyMap is present, validate values are one of: "overview", "drilldown", "detail"
   - Return error if invalid level: `fmt.Errorf("hierarchyMap contains invalid level %q, must be overview/drilldown/detail", level)`
   - Empty HierarchyMap is valid (skips validation)

**Granularity decision (Claude's discretion from CONTEXT.md):** Use per-tag mapping (simplest, most flexible). Each tag maps to a hierarchy level. If dashboard has multiple tags, first matching tag wins.
  </action>
  <verify>
Check Config struct includes HierarchyMap: `grep -n "HierarchyMap" internal/integration/grafana/types.go`

Verify validation logic: `grep -A10 "func.*Validate" internal/integration/grafana/types.go | grep -i hierarchy`

Build to confirm no compilation errors: `go build ./internal/integration/grafana/...`
  </verify>
  <done>
- HierarchyMap field added to Config with JSON/YAML tags
- Struct comment documents mapping semantics
- Validate() checks HierarchyMap values are valid levels
- Compilation succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Implement dashboard hierarchy classification</name>
  <files>
internal/integration/grafana/graph_builder.go
internal/integration/grafana/graph_builder_test.go
  </files>
  <action>
1. Add `classifyHierarchy` function to `graph_builder.go`:
   - Input: `tags []string`, `hierarchyMap map[string]string`
   - Logic (from CONTEXT.md):
     a. **Primary signal (tags first):** Check dashboard tags for hierarchy indicators
        - If tag matches pattern `spectre:overview` or `hierarchy:overview` → return "overview"
        - If tag matches pattern `spectre:drilldown` or `hierarchy:drilldown` → return "drilldown"
        - If tag matches pattern `spectre:detail` or `hierarchy:detail` → return "detail"
        - Case-insensitive matching
     b. **Fallback signal (config mapping):** If no hierarchy tag found, check HierarchyMap
        - For each dashboard tag, check if it exists in HierarchyMap
        - If match found, return mapped level (first match wins)
     c. **Default:** If no signals, return "detail" (per CONTEXT.md)
   - Return: string ("overview" | "drilldown" | "detail")

2. Update `CreateDashboardGraph` in `graph_builder.go`:
   - Before creating Dashboard node (line ~92), call `classifyHierarchy(dashboard.Tags, gb.config.HierarchyMap)`
   - Store result in variable: `hierarchyLevel := gb.classifyHierarchy(dashboard.Tags)`
   - Add `hierarchyLevel` to Dashboard node properties in MERGE query:
     ```cypher
     ON CREATE SET
         d.hierarchyLevel = $hierarchyLevel,
         ...
     ON MATCH SET
         d.hierarchyLevel = $hierarchyLevel,
         ...
     ```
   - Pass `hierarchyLevel` in Parameters map

3. Add `config` field to GraphBuilder struct:
   - Add `config *Config` field to GraphBuilder struct (line ~55)
   - Update `NewGraphBuilder` to accept config parameter: `func NewGraphBuilder(graphClient graph.Client, config *Config, logger *logging.Logger)`
   - Store config in GraphBuilder: `gb.config = config`

4. Update call sites:
   - Find where GraphBuilder is created (likely in `dashboard_syncer.go` or `grafana.go`)
   - Pass integration config to NewGraphBuilder
   - Example: `gb := NewGraphBuilder(graphClient, integration.config, logger)`

5. Add unit tests in `graph_builder_test.go`:
   - Test hierarchy tag detection (spectre:overview → "overview")
   - Test case-insensitivity (SPECTRE:OVERVIEW → "overview")
   - Test both tag formats (spectre:* and hierarchy:*)
   - Test fallback mapping (tag "prod" + map{"prod": "overview"} → "overview")
   - Test default to detail (no tags, no mapping → "detail")
   - Test tags override mapping (hierarchy tag present + mapping → tag wins)

**Tag patterns (from CONTEXT.md):**
- `spectre:overview`, `spectre:drilldown`, `spectre:detail`
- Also support `hierarchy:*` as alternative format

Tags are authoritative when present (per CONTEXT.md).
  </action>
  <verify>
Run tests: `go test ./internal/integration/grafana/... -v -run TestHierarchyClassification`

Check classifyHierarchy function exists: `grep -n "func.*classifyHierarchy" internal/integration/grafana/graph_builder.go`

Verify config field added to GraphBuilder: `grep -n "config.*Config" internal/integration/grafana/graph_builder.go`

Check Dashboard node includes hierarchyLevel: `grep -n "hierarchyLevel" internal/integration/grafana/graph_builder.go`

Build integration: `go build ./internal/integration/grafana/...`
  </verify>
  <done>
- classifyHierarchy function implements tag-first, config-fallback, default logic
- GraphBuilder stores config and uses it for classification
- Dashboard nodes include hierarchyLevel property in graph
- NewGraphBuilder accepts config parameter
- All call sites updated to pass config
- Tests verify all classification paths (tags, fallback, default)
- No compilation errors
  </done>
</task>

</tasks>

<verification>
**Config structure verification:**
```bash
# Verify HierarchyMap field exists
grep -n "HierarchyMap" internal/integration/grafana/types.go

# Verify validation logic
go test ./internal/integration/grafana/... -v -run TestConfigValidation
```

**Classification logic verification:**
```bash
# Check hierarchy classification integrated
grep -n "classifyHierarchy" internal/integration/grafana/graph_builder.go

# Verify Dashboard node includes hierarchyLevel
grep -n "hierarchyLevel" internal/integration/grafana/graph_builder.go | head -5
```

**Test coverage:**
```bash
# Run all tests
go test ./internal/integration/grafana/... -v -cover

# Verify hierarchy tests exist
grep -n "TestHierarchy" internal/integration/grafana/graph_builder_test.go
```

**Integration check:**
```bash
# Build succeeds
go build ./internal/integration/grafana/...

# No lint errors
golangci-lint run ./internal/integration/grafana/... 2>&1 | grep -i hierarchy || echo "No hierarchy-related lint issues"
```
</verification>

<success_criteria>
Phase 17-02 complete when:

1. **Config extended:**
   - HierarchyMap field exists in Config struct
   - Validation checks map values are valid levels
   - Field is optional (omitempty tags)

2. **Classification working:**
   - classifyHierarchy implements tag-first logic
   - Fallback to HierarchyMap when tags absent
   - Default to "detail" when no signals
   - Case-insensitive tag matching

3. **Integration complete:**
   - GraphBuilder stores config reference
   - CreateDashboardGraph calls classifyHierarchy
   - Dashboard nodes include hierarchyLevel property
   - All call sites pass config to NewGraphBuilder

4. **Tests passing:**
   - Unit tests verify all classification paths
   - Tests check tag priority over mapping
   - Config validation tests pass
   - No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/17-semantic-layer/17-02-SUMMARY.md`
</output>
