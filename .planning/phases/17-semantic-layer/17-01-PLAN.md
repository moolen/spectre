---
phase: 17-semantic-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/graph_builder.go
  - internal/graph/models.go
  - internal/integration/grafana/graph_builder_test.go
autonomous: true

must_haves:
  truths:
    - "Service nodes exist in graph with cluster and namespace scoping"
    - "Metrics link to Service nodes via TRACKS edges"
    - "Services are inferred from job, service, app labels with priority"
    - "Variable nodes exist with scoping/entity/detail classification"
    - "Variables link to Dashboard nodes via HAS_VARIABLE edges"
  artifacts:
    - path: "internal/graph/models.go"
      provides: "Service and Variable node type definitions"
      contains: "NodeTypeService, NodeTypeVariable"
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "Service inference and variable classification logic"
      min_lines: 400
  key_links:
    - from: "graph_builder.go:createQueryGraph"
      to: "graph_builder.go:createServiceNodes"
      via: "Label selector extraction"
      pattern: "createServiceNodes.*LabelSelectors"
    - from: "graph_builder.go:CreateDashboardGraph"
      to: "graph_builder.go:createVariableNodes"
      via: "Dashboard templating list"
      pattern: "createVariableNodes.*Templating"
---

<objective>
Infer Service nodes from PromQL label selectors and classify Grafana variables by type.

Purpose: Enable semantic queries about which services are tracked by which metrics, and what variables control scoping vs entity selection.

Output:
- Service nodes in FalkorDB with cluster/namespace scoping
- Variable nodes with scoping/entity/detail/unknown classification
- Graph relationships linking metrics to services and dashboards to variables
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-semantic-layer/17-CONTEXT.md
@.planning/phases/17-semantic-layer/17-RESEARCH.md

# Existing graph builder and parser
@internal/integration/grafana/graph_builder.go
@internal/integration/grafana/promql_parser.go
@internal/graph/models.go
</context>

<tasks>

<task type="auto">
  <name>Create Service node inference from label selectors</name>
  <files>
internal/integration/grafana/graph_builder.go
internal/graph/models.go
internal/integration/grafana/graph_builder_test.go
  </files>
  <action>
1. Add Service node type to `internal/graph/models.go`:
   - `NodeTypeService = "Service"`
   - `EdgeTypeTracks = "TRACKS"` (Metric-[:TRACKS]->Service)
   - Service node properties: `name`, `cluster`, `namespace`, `inferredFrom` (label used)

2. Add `inferServiceFromLabels` function to `graph_builder.go`:
   - Input: `map[string]string` (LabelSelectors from QueryExtraction)
   - Apply label priority: `app` > `service` > `job`
   - Extract `cluster` and `namespace` from selectors (required for scoping)
   - If multiple service labels exist and disagree, create multiple Service nodes
   - If no service labels exist, return single Service with name="Unknown"
   - Return: `[]ServiceInference` with `{name, cluster, namespace, inferredFrom}`

3. Add `createServiceNodes` function to `graph_builder.go`:
   - Input: `ctx`, `queryID`, `[]ServiceInference`, `now`
   - For each inferred service:
     - Use MERGE to create/update Service node: `MERGE (s:Service {name: $name, cluster: $cluster, namespace: $namespace})`
     - Set `inferredFrom`, `firstSeen`, `lastSeen` timestamps
     - Create edge: `MERGE (m:Metric)<-[:TRACKS]-(s:Service)` (link to metrics used by this query)
   - Handle missing cluster/namespace: use empty string (not null)

4. Integrate into `createQueryGraph` in `graph_builder.go`:
   - After creating Metric nodes (line ~255), call `inferServiceFromLabels(extraction.LabelSelectors)`
   - For each inference result, call `createServiceNodes(ctx, queryID, inferences, now)`
   - Log service inference at Debug level: "Inferred N services from query %s"
   - Use graceful degradation: log errors, continue with other services

5. Add unit tests in `graph_builder_test.go`:
   - Test service inference with single label (app)
   - Test priority: app wins over job when both present
   - Test multiple services when labels conflict
   - Test Unknown service when no labels present
   - Test cluster/namespace scoping extraction

**Label whitelist (from CONTEXT.md):** job, service, app, namespace, cluster
**Priority (from CONTEXT.md):** app > service > job
**Scoping (from CONTEXT.md):** Service identity = {name, cluster, namespace}

Do NOT use any other labels for service inference. If label is not in whitelist, ignore it.
  </action>
  <verify>
Run tests: `go test ./internal/integration/grafana/... -v -run TestServiceInference`

Check graph schema includes Service nodes: `grep -n "NodeTypeService" internal/graph/models.go`

Verify TRACKS edge defined: `grep -n "EdgeTypeTracks" internal/graph/models.go`
  </verify>
  <done>
- Service node type exists in models.go with all properties
- inferServiceFromLabels function implements priority logic
- createServiceNodes creates Service nodes and TRACKS edges
- Tests verify label priority, scoping, and Unknown service fallback
- Integration with createQueryGraph logs service count per query
  </done>
</task>

<task type="auto">
  <name>Parse dashboard variables and classify by type</name>
  <files>
internal/integration/grafana/graph_builder.go
internal/graph/models.go
internal/integration/grafana/graph_builder_test.go
  </files>
  <action>
1. Add Variable node type to `internal/graph/models.go`:
   - `NodeTypeVariable = "Variable"`
   - `EdgeTypeHasVariable = "HAS_VARIABLE"` (Dashboard-[:HAS_VARIABLE]->Variable)
   - Variable node properties: `name`, `type` (query/textbox/custom/interval), `classification` (scoping/entity/detail/unknown)

2. Add `classifyVariable` function to `graph_builder.go`:
   - Input: variable name (string)
   - Use regex patterns to classify:
     - **Scoping:** cluster, region, env, environment, datacenter, zone
     - **Entity:** service, namespace, app, application, deployment, pod, container
     - **Detail:** instance, node, host, endpoint, handler, path
   - Return classification string: "scoping" | "entity" | "detail" | "unknown"
   - Case-insensitive matching (convert to lowercase before matching)

3. Add `createVariableNodes` function to `graph_builder.go`:
   - Input: `ctx`, `dashboardUID`, `[]interface{}` (Templating.List from dashboard JSON), `now`
   - For each variable in list:
     - Parse variable: check if it has `name` and `type` fields (JSON map)
     - Call `classifyVariable(name)` to get classification
     - Use MERGE to create/update Variable node: `MERGE (v:Variable {dashboardUID: $uid, name: $name})`
     - Set properties: `type`, `classification`, `firstSeen`, `lastSeen`
     - Create edge: `MERGE (d:Dashboard {uid: $uid})-[:HAS_VARIABLE]->(v)`
   - Handle malformed variables: log warning, skip that variable
   - Return variable count for logging

4. Integrate into `CreateDashboardGraph` in `graph_builder.go`:
   - After creating Dashboard node (line ~122), call `createVariableNodes(ctx, dashboard.UID, dashboard.Templating.List, now)`
   - Log variable count at Debug level: "Created N variables for dashboard %s"
   - Use graceful degradation: log errors, continue with dashboard creation

5. Add unit tests in `graph_builder_test.go`:
   - Test variable classification for all three types (scoping, entity, detail)
   - Test unknown classification for unrecognized names
   - Test case-insensitivity (Cluster == cluster)
   - Test multiple variables per dashboard
   - Test malformed variable handling (missing name field)

**Classification patterns (from CONTEXT.md):**
- Scoping: cluster, region, env
- Entity: service, namespace, app
- Detail: pod, instance

Extend patterns to include common variations (environment, datacenter, application, etc.) but mark as appropriate classification.
  </action>
  <verify>
Run tests: `go test ./internal/integration/grafana/... -v -run TestVariableClassification`

Check Variable node type exists: `grep -n "NodeTypeVariable" internal/graph/models.go`

Verify HAS_VARIABLE edge defined: `grep -n "EdgeTypeHasVariable" internal/graph/models.go`

Check integration creates variables: `grep -n "createVariableNodes" internal/integration/grafana/graph_builder.go`
  </verify>
  <done>
- Variable node type exists in models.go
- classifyVariable implements pattern matching for all three types
- createVariableNodes parses Templating.List and creates Variable nodes
- HAS_VARIABLE edges link dashboards to variables
- Tests verify classification logic and malformed variable handling
- Integration with CreateDashboardGraph logs variable count
  </done>
</task>

</tasks>

<verification>
**Graph schema verification:**
```bash
# Verify new node types defined
grep -E "NodeTypeService|NodeTypeVariable" internal/graph/models.go

# Verify new edge types defined
grep -E "EdgeTypeTracks|EdgeTypeHasVariable" internal/graph/models.go
```

**Test coverage:**
```bash
# Run all Grafana integration tests
go test ./internal/integration/grafana/... -v -cover

# Verify service inference tests exist
grep -n "TestServiceInference" internal/integration/grafana/graph_builder_test.go

# Verify variable classification tests exist
grep -n "TestVariableClassification" internal/integration/grafana/graph_builder_test.go
```

**Integration verification:**
```bash
# Check service node creation integrated into query graph
grep -n "createServiceNodes" internal/integration/grafana/graph_builder.go | grep -A2 "createQueryGraph"

# Check variable node creation integrated into dashboard graph
grep -n "createVariableNodes" internal/integration/grafana/graph_builder.go | grep -A2 "CreateDashboardGraph"
```
</verification>

<success_criteria>
Phase 17-01 complete when:

1. **Service inference working:**
   - Service nodes created from PromQL label selectors
   - Label priority (app > service > job) enforced
   - Cluster and namespace scoping included
   - TRACKS edges link Metrics to Services
   - Unknown service created when no labels present

2. **Variable classification working:**
   - Variable nodes created from dashboard Templating.List
   - Classification (scoping/entity/detail/unknown) applied
   - HAS_VARIABLE edges link Dashboards to Variables
   - Malformed variables handled gracefully

3. **Tests passing:**
   - All unit tests for service inference pass
   - All unit tests for variable classification pass
   - Integration tests verify graph structure

4. **No regressions:**
   - Existing dashboard sync still works
   - PromQL parsing unchanged
   - All Phase 16 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-semantic-layer/17-01-SUMMARY.md`
</output>
