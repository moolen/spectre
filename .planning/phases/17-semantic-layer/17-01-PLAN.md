---
phase: 17-semantic-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/integration/grafana/graph_builder.go
  - internal/graph/models.go
  - internal/integration/grafana/graph_builder_test.go
autonomous: true

must_haves:
  truths:
    - "Service nodes exist in graph with cluster and namespace scoping"
    - "Metrics link to Service nodes via TRACKS edges"
    - "Services are inferred from job, service, app labels with priority"
  artifacts:
    - path: "internal/graph/models.go"
      provides: "Service node type definition"
      contains: "NodeTypeService"
    - path: "internal/integration/grafana/graph_builder.go"
      provides: "Service inference logic"
      contains: "inferServiceFromLabels, createServiceNodes"
      min_lines: 200
  key_links:
    - from: "graph_builder.go:createQueryGraph"
      to: "graph_builder.go:createServiceNodes"
      via: "Label selector extraction"
      pattern: "createServiceNodes.*LabelSelectors"
---

<objective>
Infer Service nodes from PromQL label selectors with cluster/namespace scoping.

Purpose: Enable semantic queries about which services are tracked by which metrics.

Output:
- Service nodes in FalkorDB with cluster/namespace scoping
- TRACKS edges linking metrics to services
- Label priority logic (app > service > job)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-semantic-layer/17-CONTEXT.md
@.planning/phases/17-semantic-layer/17-RESEARCH.md

# Existing graph builder and parser
@internal/integration/grafana/graph_builder.go
@internal/integration/grafana/promql_parser.go
@internal/graph/models.go
</context>

<tasks>

<task type="auto">
  <name>Create Service node inference from label selectors</name>
  <files>
internal/integration/grafana/graph_builder.go
internal/graph/models.go
internal/integration/grafana/graph_builder_test.go
  </files>
  <action>
1. Add Service node type to `internal/graph/models.go`:
   - `NodeTypeService = "Service"`
   - `EdgeTypeTracks = "TRACKS"` (Metric-[:TRACKS]->Service)
   - Service node properties: `name`, `cluster`, `namespace`, `inferredFrom` (label used)

2. Add `inferServiceFromLabels` function to `graph_builder.go`:
   - Input: `map[string]string` (LabelSelectors from QueryExtraction)
   - Apply label priority: `app` > `service` > `job`
   - Extract `cluster` and `namespace` from selectors (required for scoping)
   - If multiple service labels exist and disagree, create multiple Service nodes
   - If no service labels exist, return single Service with name="Unknown"
   - Return: `[]ServiceInference` with `{name, cluster, namespace, inferredFrom}`

3. Add `createServiceNodes` function to `graph_builder.go`:
   - Input: `ctx`, `queryID`, `[]ServiceInference`, `now`
   - For each inferred service:
     - Use MERGE to create/update Service node: `MERGE (s:Service {name: $name, cluster: $cluster, namespace: $namespace})`
     - Set `inferredFrom`, `firstSeen`, `lastSeen` timestamps
     - Create edge: `MERGE (m:Metric)<-[:TRACKS]-(s:Service)` (link to metrics used by this query)
   - Handle missing cluster/namespace: use empty string (not null)

4. Integrate into `createQueryGraph` in `graph_builder.go`:
   - After creating Metric nodes (line ~255), call `inferServiceFromLabels(extraction.LabelSelectors)`
   - For each inference result, call `createServiceNodes(ctx, queryID, inferences, now)`
   - Log service inference at Debug level: "Inferred N services from query %s"
   - Use graceful degradation: log errors, continue with other services

5. Add unit tests in `graph_builder_test.go`:
   - Test service inference with single label (app)
   - Test priority: app wins over job when both present
   - Test multiple services when labels conflict
   - Test Unknown service when no labels present
   - Test cluster/namespace scoping extraction

**Label whitelist (from CONTEXT.md):** job, service, app, namespace, cluster
**Priority (from CONTEXT.md):** app > service > job
**Scoping (from CONTEXT.md):** Service identity = {name, cluster, namespace}

Do NOT use any other labels for service inference. If label is not in whitelist, ignore it.
  </action>
  <verify>
Run tests: `go test ./internal/integration/grafana/... -v -run TestServiceInference`

Check graph schema includes Service nodes: `grep -n "NodeTypeService" internal/graph/models.go`

Verify TRACKS edge defined: `grep -n "EdgeTypeTracks" internal/graph/models.go`
  </verify>
  <done>
- Service node type exists in models.go with all properties
- inferServiceFromLabels function implements priority logic
- createServiceNodes creates Service nodes and TRACKS edges
- Tests verify label priority, scoping, and Unknown service fallback
- Integration with createQueryGraph logs service count per query
  </done>
</task>

</tasks>

<verification>
**Graph schema verification:**
```bash
# Verify new node types defined
grep -E "NodeTypeService" internal/graph/models.go

# Verify new edge types defined
grep -E "EdgeTypeTracks" internal/graph/models.go
```

**Test coverage:**
```bash
# Run all Grafana integration tests
go test ./internal/integration/grafana/... -v -cover

# Verify service inference tests exist
grep -n "TestServiceInference" internal/integration/grafana/graph_builder_test.go
```

**Integration verification:**
```bash
# Check service node creation integrated into query graph
grep -n "createServiceNodes" internal/integration/grafana/graph_builder.go | grep -A2 "createQueryGraph"
```
</verification>

<success_criteria>
Phase 17-01 complete when:

1. **Service inference working:**
   - Service nodes created from PromQL label selectors
   - Label priority (app > service > job) enforced
   - Cluster and namespace scoping included
   - TRACKS edges link Metrics to Services
   - Unknown service created when no labels present

2. **Tests passing:**
   - All unit tests for service inference pass
   - Integration tests verify graph structure

3. **No regressions:**
   - Existing dashboard sync still works
   - PromQL parsing unchanged
   - All Phase 16 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-semantic-layer/17-01-SUMMARY.md`
</output>
