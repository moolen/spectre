// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: internal/api/proto/timeline.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "api";

/** TimelineRequest parameters */
export interface TimelineRequest {
  startTimestamp: number;
  endTimestamp: number;
  namespace: string;
  kind: string;
  name: string;
  labelSelector: string;
}

/** TimelineMetadata sent first in stream */
export interface TimelineMetadata {
  totalCount: number;
  filesSearched: number;
  segmentsScanned: number;
  segmentsSkipped: number;
  queryExecutionTimeMs: number;
}

/** StatusSegment represents resource status over time */
export interface StatusSegment {
  id: string;
  resourceId: string;
  status: string;
  reason: string;
  message: string;
  startTime: number;
  endTime: number;
  inferred: boolean;
  /** Full Kubernetes resource JSON */
  resourceData: Uint8Array;
}

/** K8sEvent represents a Kubernetes Event */
export interface K8sEvent {
  uid: string;
  type: string;
  reason: string;
  message: string;
  timestamp: number;
  involvedObjectUid: string;
}

/** TimelineResource represents a single resource with its timeline */
export interface TimelineResource {
  id: string;
  kind: string;
  apiVersion: string;
  namespace: string;
  name: string;
  createdAt: number;
  deletedAt: number;
  labels: { [key: string]: string };
  statusSegments: StatusSegment[];
  events: K8sEvent[];
  preExisting: boolean;
}

export interface TimelineResource_LabelsEntry {
  key: string;
  value: string;
}

/** TimelineChunk contains a batch of resources */
export interface TimelineChunk {
  metadata?: TimelineMetadata | undefined;
  batch?: ResourceBatch | undefined;
}

/** ResourceBatch contains grouped resources */
export interface ResourceBatch {
  /** The kind for this batch */
  kind: string;
  resources: TimelineResource[];
  /** Indicates this is the last batch */
  isFinalBatch: boolean;
}

function createBaseTimelineRequest(): TimelineRequest {
  return { startTimestamp: 0, endTimestamp: 0, namespace: "", kind: "", name: "", labelSelector: "" };
}

export const TimelineRequest: MessageFns<TimelineRequest> = {
  encode(message: TimelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTimestamp !== 0) {
      writer.uint32(8).int64(message.startTimestamp);
    }
    if (message.endTimestamp !== 0) {
      writer.uint32(16).int64(message.endTimestamp);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.kind !== "") {
      writer.uint32(34).string(message.kind);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.labelSelector !== "") {
      writer.uint32(50).string(message.labelSelector);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.labelSelector = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineRequest {
    return {
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      endTimestamp: isSet(object.endTimestamp) ? globalThis.Number(object.endTimestamp) : 0,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labelSelector: isSet(object.labelSelector) ? globalThis.String(object.labelSelector) : "",
    };
  },

  toJSON(message: TimelineRequest): unknown {
    const obj: any = {};
    if (message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.endTimestamp !== 0) {
      obj.endTimestamp = Math.round(message.endTimestamp);
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labelSelector !== "") {
      obj.labelSelector = message.labelSelector;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineRequest>, I>>(base?: I): TimelineRequest {
    return TimelineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineRequest>, I>>(object: I): TimelineRequest {
    const message = createBaseTimelineRequest();
    message.startTimestamp = object.startTimestamp ?? 0;
    message.endTimestamp = object.endTimestamp ?? 0;
    message.namespace = object.namespace ?? "";
    message.kind = object.kind ?? "";
    message.name = object.name ?? "";
    message.labelSelector = object.labelSelector ?? "";
    return message;
  },
};

function createBaseTimelineMetadata(): TimelineMetadata {
  return { totalCount: 0, filesSearched: 0, segmentsScanned: 0, segmentsSkipped: 0, queryExecutionTimeMs: 0 };
}

export const TimelineMetadata: MessageFns<TimelineMetadata> = {
  encode(message: TimelineMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCount !== 0) {
      writer.uint32(8).int32(message.totalCount);
    }
    if (message.filesSearched !== 0) {
      writer.uint32(16).int32(message.filesSearched);
    }
    if (message.segmentsScanned !== 0) {
      writer.uint32(24).int32(message.segmentsScanned);
    }
    if (message.segmentsSkipped !== 0) {
      writer.uint32(32).int32(message.segmentsSkipped);
    }
    if (message.queryExecutionTimeMs !== 0) {
      writer.uint32(40).int64(message.queryExecutionTimeMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filesSearched = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.segmentsScanned = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.segmentsSkipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.queryExecutionTimeMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineMetadata {
    return {
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      filesSearched: isSet(object.filesSearched) ? globalThis.Number(object.filesSearched) : 0,
      segmentsScanned: isSet(object.segmentsScanned) ? globalThis.Number(object.segmentsScanned) : 0,
      segmentsSkipped: isSet(object.segmentsSkipped) ? globalThis.Number(object.segmentsSkipped) : 0,
      queryExecutionTimeMs: isSet(object.queryExecutionTimeMs) ? globalThis.Number(object.queryExecutionTimeMs) : 0,
    };
  },

  toJSON(message: TimelineMetadata): unknown {
    const obj: any = {};
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.filesSearched !== 0) {
      obj.filesSearched = Math.round(message.filesSearched);
    }
    if (message.segmentsScanned !== 0) {
      obj.segmentsScanned = Math.round(message.segmentsScanned);
    }
    if (message.segmentsSkipped !== 0) {
      obj.segmentsSkipped = Math.round(message.segmentsSkipped);
    }
    if (message.queryExecutionTimeMs !== 0) {
      obj.queryExecutionTimeMs = Math.round(message.queryExecutionTimeMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineMetadata>, I>>(base?: I): TimelineMetadata {
    return TimelineMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineMetadata>, I>>(object: I): TimelineMetadata {
    const message = createBaseTimelineMetadata();
    message.totalCount = object.totalCount ?? 0;
    message.filesSearched = object.filesSearched ?? 0;
    message.segmentsScanned = object.segmentsScanned ?? 0;
    message.segmentsSkipped = object.segmentsSkipped ?? 0;
    message.queryExecutionTimeMs = object.queryExecutionTimeMs ?? 0;
    return message;
  },
};

function createBaseStatusSegment(): StatusSegment {
  return {
    id: "",
    resourceId: "",
    status: "",
    reason: "",
    message: "",
    startTime: 0,
    endTime: 0,
    inferred: false,
    resourceData: new Uint8Array(0),
  };
}

export const StatusSegment: MessageFns<StatusSegment> = {
  encode(message: StatusSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    if (message.startTime !== 0) {
      writer.uint32(48).int64(message.startTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(56).int64(message.endTime);
    }
    if (message.inferred !== false) {
      writer.uint32(64).bool(message.inferred);
    }
    if (message.resourceData.length !== 0) {
      writer.uint32(74).bytes(message.resourceData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.startTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.endTime = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.inferred = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resourceData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusSegment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
      inferred: isSet(object.inferred) ? globalThis.Boolean(object.inferred) : false,
      resourceData: isSet(object.resourceData) ? bytesFromBase64(object.resourceData) : new Uint8Array(0),
    };
  },

  toJSON(message: StatusSegment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.endTime !== 0) {
      obj.endTime = Math.round(message.endTime);
    }
    if (message.inferred !== false) {
      obj.inferred = message.inferred;
    }
    if (message.resourceData.length !== 0) {
      obj.resourceData = base64FromBytes(message.resourceData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusSegment>, I>>(base?: I): StatusSegment {
    return StatusSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusSegment>, I>>(object: I): StatusSegment {
    const message = createBaseStatusSegment();
    message.id = object.id ?? "";
    message.resourceId = object.resourceId ?? "";
    message.status = object.status ?? "";
    message.reason = object.reason ?? "";
    message.message = object.message ?? "";
    message.startTime = object.startTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.inferred = object.inferred ?? false;
    message.resourceData = object.resourceData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseK8sEvent(): K8sEvent {
  return { uid: "", type: "", reason: "", message: "", timestamp: 0, involvedObjectUid: "" };
}

export const K8sEvent: MessageFns<K8sEvent> = {
  encode(message: K8sEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int64(message.timestamp);
    }
    if (message.involvedObjectUid !== "") {
      writer.uint32(50).string(message.involvedObjectUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): K8sEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseK8sEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.involvedObjectUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): K8sEvent {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      involvedObjectUid: isSet(object.involvedObjectUid) ? globalThis.String(object.involvedObjectUid) : "",
    };
  },

  toJSON(message: K8sEvent): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.involvedObjectUid !== "") {
      obj.involvedObjectUid = message.involvedObjectUid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<K8sEvent>, I>>(base?: I): K8sEvent {
    return K8sEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<K8sEvent>, I>>(object: I): K8sEvent {
    const message = createBaseK8sEvent();
    message.uid = object.uid ?? "";
    message.type = object.type ?? "";
    message.reason = object.reason ?? "";
    message.message = object.message ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.involvedObjectUid = object.involvedObjectUid ?? "";
    return message;
  },
};

function createBaseTimelineResource(): TimelineResource {
  return {
    id: "",
    kind: "",
    apiVersion: "",
    namespace: "",
    name: "",
    createdAt: 0,
    deletedAt: 0,
    labels: {},
    statusSegments: [],
    events: [],
    preExisting: false,
  };
}

export const TimelineResource: MessageFns<TimelineResource> = {
  encode(message: TimelineResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.apiVersion !== "") {
      writer.uint32(26).string(message.apiVersion);
    }
    if (message.namespace !== "") {
      writer.uint32(34).string(message.namespace);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.createdAt !== 0) {
      writer.uint32(48).int64(message.createdAt);
    }
    if (message.deletedAt !== 0) {
      writer.uint32(56).int64(message.deletedAt);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TimelineResource_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    for (const v of message.statusSegments) {
      StatusSegment.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.events) {
      K8sEvent.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.preExisting !== false) {
      writer.uint32(88).bool(message.preExisting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deletedAt = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = TimelineResource_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.statusSegments.push(StatusSegment.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.events.push(K8sEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.preExisting = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineResource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      deletedAt: isSet(object.deletedAt) ? globalThis.Number(object.deletedAt) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      statusSegments: globalThis.Array.isArray(object?.statusSegments)
        ? object.statusSegments.map((e: any) => StatusSegment.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => K8sEvent.fromJSON(e)) : [],
      preExisting: isSet(object.preExisting) ? globalThis.Boolean(object.preExisting) : false,
    };
  },

  toJSON(message: TimelineResource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.deletedAt !== 0) {
      obj.deletedAt = Math.round(message.deletedAt);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.statusSegments?.length) {
      obj.statusSegments = message.statusSegments.map((e) => StatusSegment.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => K8sEvent.toJSON(e));
    }
    if (message.preExisting !== false) {
      obj.preExisting = message.preExisting;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineResource>, I>>(base?: I): TimelineResource {
    return TimelineResource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineResource>, I>>(object: I): TimelineResource {
    const message = createBaseTimelineResource();
    message.id = object.id ?? "";
    message.kind = object.kind ?? "";
    message.apiVersion = object.apiVersion ?? "";
    message.namespace = object.namespace ?? "";
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.deletedAt = object.deletedAt ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.statusSegments = object.statusSegments?.map((e) => StatusSegment.fromPartial(e)) || [];
    message.events = object.events?.map((e) => K8sEvent.fromPartial(e)) || [];
    message.preExisting = object.preExisting ?? false;
    return message;
  },
};

function createBaseTimelineResource_LabelsEntry(): TimelineResource_LabelsEntry {
  return { key: "", value: "" };
}

export const TimelineResource_LabelsEntry: MessageFns<TimelineResource_LabelsEntry> = {
  encode(message: TimelineResource_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineResource_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineResource_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineResource_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TimelineResource_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineResource_LabelsEntry>, I>>(base?: I): TimelineResource_LabelsEntry {
    return TimelineResource_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineResource_LabelsEntry>, I>>(object: I): TimelineResource_LabelsEntry {
    const message = createBaseTimelineResource_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTimelineChunk(): TimelineChunk {
  return { metadata: undefined, batch: undefined };
}

export const TimelineChunk: MessageFns<TimelineChunk> = {
  encode(message: TimelineChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      TimelineMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.batch !== undefined) {
      ResourceBatch.encode(message.batch, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimelineChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimelineChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = TimelineMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.batch = ResourceBatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimelineChunk {
    return {
      metadata: isSet(object.metadata) ? TimelineMetadata.fromJSON(object.metadata) : undefined,
      batch: isSet(object.batch) ? ResourceBatch.fromJSON(object.batch) : undefined,
    };
  },

  toJSON(message: TimelineChunk): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = TimelineMetadata.toJSON(message.metadata);
    }
    if (message.batch !== undefined) {
      obj.batch = ResourceBatch.toJSON(message.batch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimelineChunk>, I>>(base?: I): TimelineChunk {
    return TimelineChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimelineChunk>, I>>(object: I): TimelineChunk {
    const message = createBaseTimelineChunk();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? TimelineMetadata.fromPartial(object.metadata)
      : undefined;
    message.batch = (object.batch !== undefined && object.batch !== null)
      ? ResourceBatch.fromPartial(object.batch)
      : undefined;
    return message;
  },
};

function createBaseResourceBatch(): ResourceBatch {
  return { kind: "", resources: [], isFinalBatch: false };
}

export const ResourceBatch: MessageFns<ResourceBatch> = {
  encode(message: ResourceBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    for (const v of message.resources) {
      TimelineResource.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.isFinalBatch !== false) {
      writer.uint32(24).bool(message.isFinalBatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resources.push(TimelineResource.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFinalBatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceBatch {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => TimelineResource.fromJSON(e))
        : [],
      isFinalBatch: isSet(object.isFinalBatch) ? globalThis.Boolean(object.isFinalBatch) : false,
    };
  },

  toJSON(message: ResourceBatch): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => TimelineResource.toJSON(e));
    }
    if (message.isFinalBatch !== false) {
      obj.isFinalBatch = message.isFinalBatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceBatch>, I>>(base?: I): ResourceBatch {
    return ResourceBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceBatch>, I>>(object: I): ResourceBatch {
    const message = createBaseResourceBatch();
    message.kind = object.kind ?? "";
    message.resources = object.resources?.map((e) => TimelineResource.fromPartial(e)) || [];
    message.isFinalBatch = object.isFinalBatch ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
