"use strict";(globalThis.webpackChunkspectre_docs=globalThis.webpackChunkspectre_docs||[]).push([[9646],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},8484:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"architecture/storage-design","title":"Storage Design","description":"Deep dive into Spectre\'s storage architecture and design decisions","source":"@site/docs/architecture/storage-design.md","sourceDirName":"architecture","slug":"/architecture/storage-design","permalink":"/spectre/docs/architecture/storage-design","draft":false,"unlisted":false,"editUrl":"https://github.com/moolen/spectre/tree/master/docs/docs/architecture/storage-design.md","tags":[],"version":"current","lastUpdatedBy":"Moritz Johner","lastUpdatedAt":1765616329000,"frontMatter":{"title":"Storage Design","description":"Deep dive into Spectre\'s storage architecture and design decisions","keywords":["architecture","storage","design","blocks","hourly files"]},"sidebar":"docsSidebar","previous":{"title":"Architecture Overview","permalink":"/spectre/docs/architecture/overview"},"next":{"title":"Block Format Reference","permalink":"/spectre/docs/architecture/block-format"}}');var s=i(4848),t=i(8453);const l={title:"Storage Design",description:"Deep dive into Spectre's storage architecture and design decisions",keywords:["architecture","storage","design","blocks","hourly files"]},d="Storage Design",c={},o=[{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"File Organization",id:"file-organization",level:2},{value:"Hourly File Strategy",id:"hourly-file-strategy",level:3},{value:"Why Hourly Files?",id:"why-hourly-files",level:3},{value:"Directory Structure",id:"directory-structure",level:3},{value:"File Lifecycle",id:"file-lifecycle",level:3},{value:"Hour Rotation",id:"hour-rotation",level:3},{value:"Block-Based Architecture",id:"block-based-architecture",level:2},{value:"Block Lifecycle",id:"block-lifecycle",level:3},{value:"EventBuffer Design",id:"eventbuffer-design",level:3},{value:"Block Structure",id:"block-structure",level:3},{value:"Write Path",id:"write-path",level:2},{value:"Complete Write Flow",id:"complete-write-flow",level:3},{value:"Block Finalization",id:"block-finalization",level:3},{value:"File Closing",id:"file-closing",level:3},{value:"State Snapshots",id:"state-snapshots",level:2},{value:"Problem: Pre-Existing Resources",id:"problem-pre-existing-resources",level:3},{value:"Solution: Final Resource States",id:"solution-final-resource-states",level:3},{value:"State Carryover",id:"state-carryover",level:3},{value:"Query Integration",id:"query-integration",level:3},{value:"File Restoration",id:"file-restoration",level:2},{value:"Reopening Complete Files",id:"reopening-complete-files",level:3},{value:"Crash Recovery",id:"crash-recovery",level:3},{value:"Incomplete Files",id:"incomplete-files",level:4},{value:"Corrupted Files",id:"corrupted-files",level:4},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Write Performance",id:"write-performance",level:3},{value:"Space Efficiency",id:"space-efficiency",level:3},{value:"Read Performance",id:"read-performance",level:3},{value:"Design Decisions (Q&amp;A)",id:"design-decisions-qa",level:2},{value:"Q: Why 10MB default block size?",id:"q-why-10mb-default-block-size",level:3},{value:"Q: Why gzip over zstd?",id:"q-why-gzip-over-zstd",level:3},{value:"Q: Why hourly files instead of daily?",id:"q-why-hourly-files-instead-of-daily",level:3},{value:"Q: Why JSON index instead of binary?",id:"q-why-json-index-instead-of-binary",level:3},{value:"Q: Why not use a database (SQLite, RocksDB)?",id:"q-why-not-use-a-database-sqlite-rocksdb",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Version 1.1 (Planned)",id:"version-11-planned",level:3},{value:"Version 2.0 (Planned)",id:"version-20-planned",level:3},{value:"Beyond 2.0",id:"beyond-20",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"storage-design",children:"Storage Design"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides a comprehensive overview of Spectre's storage architecture, explaining the design philosophy, implementation details, and performance characteristics."}),"\n",(0,s.jsx)(n.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,s.jsx)(n.p,{children:"Spectre's storage engine is designed with three primary goals:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Write Throughput:"})," Handle continuous streams of Kubernetes audit events with minimal latency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast Query Access:"})," Execute filtered queries efficiently without scanning entire dataset"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Storage Efficiency:"})," Compress data effectively while maintaining read performance"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The design draws inspiration from log-structured storage systems like Loki and VictoriaMetrics, adapted specifically for Kubernetes resource state tracking."}),"\n",(0,s.jsx)(n.h2,{id:"file-organization",children:"File Organization"}),"\n",(0,s.jsx)(n.h3,{id:"hourly-file-strategy",children:"Hourly File Strategy"}),"\n",(0,s.jsxs)(n.p,{children:["Events are organized into ",(0,s.jsx)(n.strong,{children:"hourly files"})," with the naming convention:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"YYYY-MM-DD-HH.bin\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"2025-12-12-10.bin"})," - Events from 10:00-10:59"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"2025-12-12-11.bin"})," - Events from 11:00-11:59"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"2025-12-12-12.bin"})," - Events from 12:00-12:59"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-hourly-files",children:"Why Hourly Files?"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Benefit"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Retention Granularity"})}),(0,s.jsx)(n.td,{children:"Delete old data by hour, not day or all-at-once"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Query Optimization"})}),(0,s.jsx)(n.td,{children:"Skip entire files that fall outside query time range"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Crash Recovery"})}),(0,s.jsx)(n.td,{children:"Limit blast radius - only current hour affected if crash occurs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Parallelization"})}),(0,s.jsx)(n.td,{children:"Future: Query multiple hourly files concurrently"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Manageability"})}),(0,s.jsx)(n.td,{children:"Smaller files are easier to backup, move, or analyze"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/data/\n\u251c\u2500\u2500 2025-12-11-10.bin                    # Complete file (with footer)\n\u251c\u2500\u2500 2025-12-11-11.bin                    # Complete file\n\u251c\u2500\u2500 2025-12-11-12.bin                    # Incomplete (currently writing)\n\u251c\u2500\u2500 2025-12-11-09.bin.incomplete.1733915200  # Backup from crash\n\u2514\u2500\u2500 2025-12-10-15.bin.corrupted.1733828800   # Corrupted file backup\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"File States:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complete:"})," Has valid header and footer, can be reopened for appending"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incomplete:"})," Missing footer (crash during write), renamed with ",(0,s.jsx)(n.code,{children:".incomplete.<timestamp>"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Corrupted:"})," Invalid header or structure, renamed with ",(0,s.jsx)(n.code,{children:".corrupted.<timestamp>"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"file-lifecycle",children:"File Lifecycle"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Created    \u2502 Write header (77 bytes)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Writing    \u2502 Buffer events \u2192 Finalize blocks \u2192 Write compressed data\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Closing   \u2502 Finalize last block \u2192 Build indexes \u2192 Write index \u2192 Write footer\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Complete   \u2502 Has footer, can be queried or reopened for appending\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Archived   \u2502 Outside query window, ready for deletion\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"hour-rotation",children:"Hour Rotation"}),"\n",(0,s.jsx)(n.p,{children:"When the clock advances to a new hour:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Finalize current file:"})," Flush buffer, build indexes, write footer"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extract state snapshots:"})," Capture final resource states"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create new file:"})," Generate filename for new hour"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Carry over states:"})," Transfer state snapshots to new file"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Continue writing:"})," New events go to new file"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Code Path:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"storage.go:getOrCreateCurrentFile()\n  \u2192 Check if currentHour has changed\n  \u2192 Close previous file (extracts finalResourceStates)\n  \u2192 Create new file for current hour\n  \u2192 Transfer finalResourceStates to new file\n"})}),"\n",(0,s.jsx)(n.h2,{id:"block-based-architecture",children:"Block-Based Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"block-lifecycle",children:"Block Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"Events are buffered in memory until they reach the configured block size, then compressed and written to disk."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Event Flow                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWatcher Event\n     \u2502\n     v\nStorage.WriteEvent()\n     \u2502\n     v\nBlockStorageFile.WriteEvent()\n     \u2502\n     v\nEventBuffer.AddEvent()\n     \u2502\n     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  \u2502 Buffer Events (JSON)                \u2502\n     \u2502  \u2502 - Track metadata (kinds, ns, etc)  \u2502\n     \u2502  \u2502 - Update Bloom filters             \u2502\n     \u2502  \u2502 - Monitor buffer size              \u2502\n     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     v\n  Buffer Full?\n     \u2502\n     \u251c\u2500 No  \u2500> Continue buffering\n     \u2502\n     \u2514\u2500 Yes \u2500> Finalize Block\n                     \u2502\n                     v\n               Encode Protobuf\n                     \u2502\n                     v\n               Compress (gzip)\n                     \u2502\n                     v\n               Write to Disk\n                     \u2502\n                     v\n               Store Metadata\n                     \u2502\n                     v\n               Create New Buffer\n"})}),"\n",(0,s.jsx)(n.h3,{id:"eventbuffer-design",children:"EventBuffer Design"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"EventBuffer"})," accumulates events until the block size threshold is reached:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type EventBuffer struct {\n    events       [][]byte              // JSON-encoded events\n    blockSize    int64                 // Target uncompressed size\n    currentSize  int64                 // Current uncompressed size\n\n    // Metadata tracking\n    timestampMin int64\n    timestampMax int64\n    kindSet      map[string]bool\n    namespaceSet map[string]bool\n    groupSet     map[string]bool\n\n    // Bloom filters (built incrementally)\n    bloomKinds      *StandardBloomFilter\n    bloomNamespaces *StandardBloomFilter\n    bloomGroups     *StandardBloomFilter\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Behaviors:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incremental Metadata:"})," Kinds, namespaces, groups tracked as events arrive"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bloom Filter Building:"})," Filters updated with each event for space efficiency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Size Monitoring:"})," Checks if adding next event would exceed block size"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"First Event Exception:"})," Never full on first event (prevents zero-event blocks)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"block-structure",children:"Block Structure"}),"\n",(0,s.jsx)(n.p,{children:"Once finalized, a block contains:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type Block struct {\n    ID                 int32            // Sequential within file\n    Offset             int64            // Byte offset in file\n    Length             int64            // Compressed data length\n    UncompressedLength int64            // Original size\n    EventCount         int32            // Number of events\n    TimestampMin       int64            // Time range for filtering\n    TimestampMax       int64\n    CompressedData     []byte           // gzip-compressed protobuf stream\n    Metadata           *BlockMetadata   // For indexing\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Block Size Trade-offs:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Block Size"}),(0,s.jsx)(n.th,{children:"Pros"}),(0,s.jsx)(n.th,{children:"Cons"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Small (1 MB)"}),(0,s.jsx)(n.td,{children:"Fine-grained filtering, fast decompress"}),(0,s.jsx)(n.td,{children:"More blocks, larger index overhead"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Medium (10 MB)"}),(0,s.jsx)(n.td,{children:"Balanced compression and granularity"}),(0,s.jsx)(n.td,{children:"Moderate decompression latency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Large (100 MB)"}),(0,s.jsx)(n.td,{children:"Fewer blocks, better compression"}),(0,s.jsx)(n.td,{children:"Slow decompression, coarse filtering"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Default:"})," 10 MB (configurable via ",(0,s.jsx)(n.code,{children:"--segment-size"})," flag)"]}),"\n",(0,s.jsx)(n.h2,{id:"write-path",children:"Write Path"}),"\n",(0,s.jsx)(n.h3,{id:"complete-write-flow",children:"Complete Write Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"// 1. Application calls WriteEvent\nstorage.WriteEvent(event)\n    \u2193\n// 2. Get or create hourly file (rotates at hour boundary)\ngetOrCreateCurrentFile()\n    \u2193\n// 3. Write to block storage file\nblockStorageFile.WriteEvent(event)\n    \u2193\n// 4. Serialize event to JSON\neventJSON := json.Marshal(event)\n    \u2193\n// 5. Check if buffer is full\nif currentBuffer.IsFull(len(eventJSON)) {\n    finalizeBlock()     // Flush current buffer\n    currentBuffer = NewEventBuffer(blockSize)\n}\n    \u2193\n// 6. Add to buffer\ncurrentBuffer.AddEvent(eventJSON)\n    \u2193\n// 7. Update metadata\n- Add kind/namespace/group to sets\n- Add to Bloom filters\n- Update timestamp min/max\n    \u2193\n// 8. Write buffered (returns immediately)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"block-finalization",children:"Block Finalization"}),"\n",(0,s.jsx)(n.p,{children:"When buffer is full (triggered by next event):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'finalizeBlock()\n    \u2193\n// 1. Create block from buffer\nblock := currentBuffer.Finalize(blockID, "gzip")\n    \u2193\n// 2. Encode events as protobuf stream\nprotobufData := encodeProtobuf(events)\n    \u2193\n// 3. Compress with gzip\ncompressedData := gzip.Compress(protobufData)\n    \u2193\n// 4. Get current file offset\noffset := file.Seek(0, SEEK_CUR)\n    \u2193\n// 5. Write compressed data to disk\nfile.Write(compressedData)\n    \u2193\n// 6. Store metadata for index\nblockMetadataList.append(block.Metadata)\n    \u2193\n// 7. Increment block ID\nblockID++\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance Characteristics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event buffering:"})," O(1) per event"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Block finalization:"})," O(N) where N = events in block (protobuf encode + gzip compress)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Typical latency:"})," <50ms for 10MB block on modern hardware"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"file-closing",children:"File Closing"}),"\n",(0,s.jsx)(n.p,{children:"When hour changes or application shuts down:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'blockStorageFile.Close()\n    \u2193\n// 1. Finalize last buffer (if non-empty)\nif currentBuffer.EventCount > 0 {\n    finalizeBlock()\n}\n    \u2193\n// 2. Build inverted indexes from block metadata\nindex := BuildInvertedIndexes(blockMetadataList)\n    \u2193\n// 3. Extract final resource states\nfinalResourceStates := extractFinalResourceStates()\n    \u2193\n// 4. Create index section\nindexSection := IndexSection{\n    BlockMetadata: blockMetadataList,\n    InvertedIndexes: index,\n    Statistics: stats,\n    FinalResourceStates: finalResourceStates,\n}\n    \u2193\n// 5. Write index section (JSON)\nindexOffset := file.CurrentOffset()\nindexLength := WriteIndexSection(file, indexSection)\n    \u2193\n// 6. Write footer\nfooter := FileFooter{\n    IndexSectionOffset: indexOffset,\n    IndexSectionLength: indexLength,\n    MagicBytes: "RPKEND",\n}\nWriteFileFooter(file, footer)\n    \u2193\n// 7. Close file handle\nfile.Close()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"state-snapshots",children:"State Snapshots"}),"\n",(0,s.jsx)(n.h3,{id:"problem-pre-existing-resources",children:"Problem: Pre-Existing Resources"}),"\n",(0,s.jsx)(n.p,{children:"Consider this scenario:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Hour 10:00-10:59:  Deployment "nginx" created\nHour 11:00-11:59:  No events for "nginx"\nQuery [11:30-12:00]: Should "nginx" appear in results?\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"})," Yes! The Deployment still exists, even if no events occurred."]}),"\n",(0,s.jsx)(n.h3,{id:"solution-final-resource-states",children:"Solution: Final Resource States"}),"\n",(0,s.jsxs)(n.p,{children:["Each file stores the ",(0,s.jsx)(n.strong,{children:"final state"})," of every resource at file close time:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type ResourceLastState struct {\n    UID          string          // Resource UID\n    EventType    string          // CREATE, UPDATE, or DELETE\n    Timestamp    int64           // Last observed timestamp\n    ResourceData json.RawMessage // Full resource object (null for DELETE)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Map Key:"})," ",(0,s.jsx)(n.code,{children:"group/version/kind/namespace/name"}),"\n",(0,s.jsx)(n.strong,{children:"Example:"})," ",(0,s.jsx)(n.code,{children:"apps/v1/Deployment/default/nginx"})]}),"\n",(0,s.jsx)(n.h3,{id:"state-carryover",children:"State Carryover"}),"\n",(0,s.jsx)(n.p,{children:"When creating a new hourly file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"// Close previous file\npreviousFile.Close()\n    \u2193\n// Extract its final states\ncarryoverStates := previousFile.finalResourceStates\n    \u2193\n// Create new file\nnewFile := NewBlockStorageFile(path, timestamp, blockSize)\n    \u2193\n// Transfer states to new file\nnewFile.finalResourceStates = carryoverStates\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why This Works:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Resources that exist but have no events: Carried forward hour-to-hour"}),"\n",(0,s.jsxs)(n.li,{children:["Resources that are deleted: State shows ",(0,s.jsx)(n.code,{children:'EventType = "DELETE"'})]}),"\n",(0,s.jsx)(n.li,{children:"Resources with new events: State updated during event processing"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"query-integration",children:"Query Integration"}),"\n",(0,s.jsxs)(n.p,{children:["When querying ",(0,s.jsx)(n.code,{children:"[startTime, endTime]"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identify files"})," that overlap the time range"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Include one file before"})," ",(0,s.jsx)(n.code,{children:"startTime"})," (for state snapshots)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Merge events"})," from files with state snapshots"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'Generate synthetic "state-" events'})," for resources that exist but have no events in range"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Query: [11:30, 12:30]\nFiles: 2025-12-12-10.bin (for states)\n       2025-12-12-11.bin (events + states)\n       2025-12-12-12.bin (events + states)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"file-restoration",children:"File Restoration"}),"\n",(0,s.jsx)(n.h3,{id:"reopening-complete-files",children:"Reopening Complete Files"}),"\n",(0,s.jsx)(n.p,{children:"When starting the application, existing complete files can be reopened for appending:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// 1. Check if file exists\nif fileExists(path) {\n    // 2. Read footer\n    footer := ReadFileFooter(path)\n\n    // 3. Verify magic bytes\n    if footer.MagicBytes != "RPKEND" {\n        // Incomplete file - rename and create new\n        os.Rename(path, path + ".incomplete." + timestamp)\n        return createNewFile(path)\n    }\n\n    // 4. Read index section\n    index := ReadIndexSection(path, footer.IndexOffset, footer.IndexLength)\n\n    // 5. Restore state\n    blockMetadata := index.BlockMetadata\n    finalResourceStates := index.FinalResourceStates\n    nextBlockID := len(blockMetadata)\n\n    // 6. Truncate at blocks end (remove old index + footer)\n    file.Truncate(footer.IndexSectionOffset)\n\n    // 7. Seek to end for appending\n    file.Seek(footer.IndexSectionOffset, SEEK_SET)\n\n    // 8. Continue writing new blocks\n    return blockStorageFile\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Application restart:"})," Resume writing to current hour's file"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hot reload:"})," Reload configuration without losing buffered data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing:"})," Inject historical events into existing files"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"crash-recovery",children:"Crash Recovery"}),"\n",(0,s.jsx)(n.h4,{id:"incomplete-files",children:"Incomplete Files"}),"\n",(0,s.jsx)(n.p,{children:"If the application crashes before closing a file:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Detection:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Footer is missing (can't read 324 bytes from end)"}),"\n",(0,s.jsx)(n.li,{children:'Footer magic bytes != "RPKEND"'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recovery:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'timestamp := time.Now().Unix()\nbackupPath := fmt.Sprintf("%s.incomplete.%d", path, timestamp)\nos.Rename(path, backupPath)\n\n// Create new empty file\ncreateNewFile(path)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Result:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Original incomplete file preserved for debugging/recovery"}),"\n",(0,s.jsx)(n.li,{children:"New empty file created for writing"}),"\n",(0,s.jsx)(n.li,{children:"No data loss for previously closed files"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"corrupted-files",children:"Corrupted Files"}),"\n",(0,s.jsx)(n.p,{children:"If the header or structure is invalid:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Detection:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can't read 77-byte header"}),"\n",(0,s.jsx)(n.li,{children:'Header magic bytes != "RPKBLOCK"'}),"\n",(0,s.jsx)(n.li,{children:"Version is unsupported"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recovery:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'timestamp := time.Now().Unix()\nbackupPath := fmt.Sprintf("%s.corrupted.%d", path, timestamp)\nos.Rename(path, backupPath)\n\n// Create new empty file\ncreateNewFile(path)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"write-performance",children:"Write Performance"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Complexity"}),(0,s.jsx)(n.th,{children:"Typical Latency"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Event buffering"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"<1 \xb5s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON marshal"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~10 \xb5s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bloom filter update"}),(0,s.jsx)(n.td,{children:"O(k)"}),(0,s.jsx)(n.td,{children:"~1 \xb5s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Block finalization"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~50 ms (10 MB)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Protobuf encode"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~20 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"gzip compress"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~100 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Disk write"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"~10 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Index build (close)"}),(0,s.jsx)(n.td,{children:"O(N \xd7 M)"}),(0,s.jsx)(n.td,{children:"~500 ms"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Throughput:"})," 10,000+ events/second (typical Kubernetes cluster)"]}),"\n",(0,s.jsx)(n.h3,{id:"space-efficiency",children:"Space Efficiency"}),"\n",(0,s.jsx)(n.p,{children:"For a typical hourly file with 60,000 events:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Size"}),(0,s.jsx)(n.th,{children:"Percentage"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Compressed Events"}),(0,s.jsx)(n.td,{children:"18 MB"}),(0,s.jsx)(n.td,{children:"~94%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Block Metadata"}),(0,s.jsx)(n.td,{children:"800 KB"}),(0,s.jsx)(n.td,{children:"~4%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Inverted Indexes"}),(0,s.jsx)(n.td,{children:"200 KB"}),(0,s.jsx)(n.td,{children:"~1%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bloom Filters"}),(0,s.jsx)(n.td,{children:"150 KB"}),(0,s.jsx)(n.td,{children:"~0.8%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"State Snapshots"}),(0,s.jsx)(n.td,{children:"100 KB"}),(0,s.jsx)(n.td,{children:"~0.5%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Header + Footer"}),(0,s.jsx)(n.td,{children:"401 bytes"}),(0,s.jsx)(n.td,{children:"<0.001%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Total"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"~19 MB"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"100%"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compression Ratio:"})," 0.25 (75% reduction from uncompressed)"]}),"\n",(0,s.jsx)(n.h3,{id:"read-performance",children:"Read Performance"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Complexity"}),(0,s.jsx)(n.th,{children:"Typical Latency"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Header read"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"<1 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Footer read"}),(0,s.jsx)(n.td,{children:"O(1)"}),(0,s.jsx)(n.td,{children:"<1 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Index read"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~10 ms (2 MB)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Index parse (JSON)"}),(0,s.jsx)(n.td,{children:"O(N)"}),(0,s.jsx)(n.td,{children:"~20 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Block read"}),(0,s.jsx)(n.td,{children:"O(1) seek"}),(0,s.jsx)(n.td,{children:"~5 ms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Block decompress"}),(0,s.jsx)(n.td,{children:"O(M)"}),(0,s.jsx)(n.td,{children:"~30 ms (10 MB)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Protobuf decode"}),(0,s.jsx)(n.td,{children:"O(M)"}),(0,s.jsx)(n.td,{children:"~20 ms"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Query Performance:"})," See ",(0,s.jsx)(n.a,{href:"/spectre/docs/architecture/query-execution",children:"Query Execution"})," for details"]}),"\n",(0,s.jsx)(n.h2,{id:"design-decisions-qa",children:"Design Decisions (Q&A)"}),"\n",(0,s.jsx)(n.h3,{id:"q-why-10mb-default-block-size",children:"Q: Why 10MB default block size?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A:"})," Balances three competing factors:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compression Ratio:"})," Larger blocks compress better (more context for gzip)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 MB: ~65% reduction"}),"\n",(0,s.jsx)(n.li,{children:"10 MB: ~75% reduction"}),"\n",(0,s.jsx)(n.li,{children:"100 MB: ~78% reduction"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Query Granularity:"})," Smaller blocks enable finer filtering"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 MB block = ~80 events \u2192 better filtering precision"}),"\n",(0,s.jsx)(n.li,{children:"10 MB block = ~800 events \u2192 balanced"}),"\n",(0,s.jsx)(n.li,{children:"100 MB block = ~8000 events \u2192 coarse filtering"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decompression Latency:"})," Smaller blocks decompress faster"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 MB: ~3 ms"}),"\n",(0,s.jsx)(n.li,{children:"10 MB: ~30 ms"}),"\n",(0,s.jsx)(n.li,{children:"100 MB: ~300 ms"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"10 MB provides good compression (75%) with acceptable latency (<50ms)."})}),"\n",(0,s.jsx)(n.h3,{id:"q-why-gzip-over-zstd",children:"Q: Why gzip over zstd?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A:"})," Implementation maturity and compatibility:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"gzip:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Excellent Go library support (",(0,s.jsx)(n.code,{children:"klauspost/compress/gzip"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Universal compatibility"}),"\n",(0,s.jsx)(n.li,{children:"Good compression ratio (75%)"}),"\n",(0,s.jsx)(n.li,{children:"Battle-tested in production"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"zstd"})," (planned for v2.0):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Slightly better compression (78%)"}),"\n",(0,s.jsx)(n.li,{children:"Faster compression (~2x)"}),"\n",(0,s.jsx)(n.li,{children:"Faster decompression (~1.5x)"}),"\n",(0,s.jsx)(n.li,{children:"Requires migration strategy for existing files"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Current choice: gzip for stability. Future: zstd as opt-in with migration path."})}),"\n",(0,s.jsx)(n.h3,{id:"q-why-hourly-files-instead-of-daily",children:"Q: Why hourly files instead of daily?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A:"})," Operational flexibility:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hourly"}),(0,s.jsx)(n.th,{children:"Daily"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Delete specific hours"}),(0,s.jsx)(n.td,{children:"Delete entire days only"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Smaller files (~20 MB)"}),(0,s.jsx)(n.td,{children:"Larger files (~500 MB)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hour-level query optimization"}),(0,s.jsx)(n.td,{children:"Day-level only"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Fast rotation (low risk)"}),(0,s.jsx)(n.td,{children:"Rotation once/day (higher risk)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Easier backup/restore"}),(0,s.jsx)(n.td,{children:"Harder to manage"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Hourly provides finer control without excessive file count."})}),"\n",(0,s.jsx)(n.h3,{id:"q-why-json-index-instead-of-binary",children:"Q: Why JSON index instead of binary?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A:"})," Developer experience and flexibility:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Human-readable (debugging, inspection)"}),"\n",(0,s.jsx)(n.li,{children:"Easy schema evolution (add fields without breaking)"}),"\n",(0,s.jsx)(n.li,{children:"Standard tooling (jq, JSON parsers)"}),"\n",(0,s.jsx)(n.li,{children:"Compact enough for typical indexes (<2 MB)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Slightly larger than binary (10-20%)"}),"\n",(0,s.jsx)(n.li,{children:"Slightly slower to parse (~20ms vs ~5ms)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Trade-off: Flexibility and debuggability over ~15ms latency."})}),"\n",(0,s.jsx)(n.h3,{id:"q-why-not-use-a-database-sqlite-rocksdb",children:"Q: Why not use a database (SQLite, RocksDB)?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A:"})," Specialized requirements and simplicity:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Append-only workload:"})," Blocks never modified after write"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression at block level:"})," Databases compress at page level (less efficient)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom indexing:"})," Inverted indexes + Bloom filters tailored for our queries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No dependencies:"})," Single binary deployment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Portability:"})," Files can be copied, archived, analyzed offline"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Custom storage provides better compression and simpler deployment."})}),"\n",(0,s.jsx)(n.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,s.jsx)(n.h3,{id:"version-11-planned",children:"Version 1.1 (Planned)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Retention Policies:"})," Delete files older than N days via configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Compaction:"})," Merge small blocks from low-traffic hours"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enhanced Metadata:"})," Track more dimensions (verbs, users, source IPs)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"version-20-planned",children:"Version 2.0 (Planned)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"zstd Compression:"})," Opt-in faster compression with migration tool"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrent File Writing:"})," Parallel writes to multiple hourly files"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Block-Level Encryption:"})," Encrypt sensitive events at rest"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Tier Storage:"})," Hot (SSD), warm (HDD), cold (object storage)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Distributed Queries:"})," Query across multiple Spectre instances"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"beyond-20",children:"Beyond 2.0"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Column-Oriented Blocks:"})," Store fields separately for better compression"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dictionary Learning:"})," Pre-build compression dictionaries for common patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adaptive Block Sizing:"})," Tune block size based on event rate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Incremental Indexes:"})," Update indexes without rebuilding entire file"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/spectre/docs/architecture/block-format",children:"Block Format Reference"})," - Binary file format specification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/spectre/docs/architecture/indexing-strategy",children:"Indexing Strategy"})," - Query optimization techniques"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/spectre/docs/architecture/compression",children:"Compression"})," - Compression algorithms and performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/spectre/docs/architecture/query-execution",children:"Query Execution"})," - Query pipeline and optimization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/spectre/docs/configuration/storage-settings",children:"Storage Settings"})," - Configuration guide"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);