"use strict";(globalThis.webpackChunkspectre_docs=globalThis.webpackChunkspectre_docs||[]).push([[2409],{6898:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"architecture/indexing-strategy","title":"Indexing Strategy","description":"Query optimization through inverted indexes and Bloom filters","source":"@site/docs/architecture/indexing-strategy.md","sourceDirName":"architecture","slug":"/architecture/indexing-strategy","permalink":"/spectre/docs/architecture/indexing-strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/moolen/spectre/tree/master/docs/docs/architecture/indexing-strategy.md","tags":[],"version":"current","lastUpdatedBy":"Moritz Johner","lastUpdatedAt":1765616329000,"frontMatter":{"title":"Indexing Strategy","description":"Query optimization through inverted indexes and Bloom filters","keywords":["architecture","indexing","bloom filters","query optimization"]},"sidebar":"docsSidebar","previous":{"title":"Block Format Reference","permalink":"/spectre/docs/architecture/block-format"},"next":{"title":"Compression","permalink":"/spectre/docs/architecture/compression"}}');var r=i(4848),t=i(8453);const l={title:"Indexing Strategy",description:"Query optimization through inverted indexes and Bloom filters",keywords:["architecture","indexing","bloom filters","query optimization"]},d="Indexing Strategy",c={},o=[{value:"Three-Tier Indexing Architecture",id:"three-tier-indexing-architecture",level:2},{value:"Inverted Indexes",id:"inverted-indexes",level:2},{value:"Structure",id:"structure",level:3},{value:"Query Optimization",id:"query-optimization",level:3},{value:"Single Filter",id:"single-filter",level:4},{value:"Multiple Filters (AND Logic)",id:"multiple-filters-and-logic",level:4},{value:"Three-Way Intersection",id:"three-way-intersection",level:4},{value:"Intersection Algorithm",id:"intersection-algorithm",level:3},{value:"Index Build Performance",id:"index-build-performance",level:3},{value:"Bloom Filters",id:"bloom-filters",level:2},{value:"Purpose",id:"purpose",level:3},{value:"Configuration",id:"configuration",level:3},{value:"How Bloom Filters Work",id:"how-bloom-filters-work",level:3},{value:"Adding Values (Write Time)",id:"adding-values-write-time",level:4},{value:"Checking Values (Query Time)",id:"checking-values-query-time",level:4},{value:"False Positive Rate",id:"false-positive-rate",level:3},{value:"Space Efficiency Comparison",id:"space-efficiency-comparison",level:3},{value:"Timestamp Indexes",id:"timestamp-indexes",level:2},{value:"Block-Level Time Ranges",id:"block-level-time-ranges",level:3},{value:"Time Range Filtering",id:"time-range-filtering",level:3},{value:"Multi-Stage Filtering Pipeline",id:"multi-stage-filtering-pipeline",level:2},{value:"Complete Query Execution Flow",id:"complete-query-execution-flow",level:3},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Index Memory Footprint",id:"index-memory-footprint",level:2},{value:"Per-File Index Size",id:"per-file-index-size",level:3},{value:"System-Wide Memory Usage",id:"system-wide-memory-usage",level:3},{value:"Index Persistence",id:"index-persistence",level:2},{value:"Query Without Indexes",id:"query-without-indexes",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"indexing-strategy",children:"Indexing Strategy"})}),"\n",(0,r.jsxs)(n.p,{children:["This document explains Spectre's indexing strategy for fast query execution. The goal is to ",(0,r.jsx)(n.strong,{children:"skip 90%+ of blocks"})," for filtered queries without scanning the entire dataset."]}),"\n",(0,r.jsx)(n.h2,{id:"three-tier-indexing-architecture",children:"Three-Tier Indexing Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Spectre uses a layered filtering approach:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Query: kind=Pod, namespace=default            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Tier 1: Inverted Indexes (Exact Match)                     \u2502\n\u2502  kind_to_blocks["Pod"] = [0, 1, 3, 7, 9]                   \u2502\n\u2502  namespace_to_blocks["default"] = [0, 2, 4, 6]             \u2502\n\u2502  Intersection: [0]  \u2192 Skip 99% of blocks                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Tier 2: Bloom Filters (Probabilistic)                      \u2502\n\u2502  block[0].bloomKinds.Contains("Pod")? \u2192 true                \u2502\n\u2502  block[0].bloomNamespaces.Contains("default")? \u2192 true       \u2502\n\u2502  \u2192 Candidate for decompression                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Tier 3: Timestamp Filtering (Range Check)                  \u2502\n\u2502  block[0].TimestampMin \u2264 queryEnd? \u2192 true                   \u2502\n\u2502  block[0].TimestampMax \u2265 queryStart? \u2192 true                 \u2502\n\u2502  \u2192 Decompress and scan events                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,r.jsx)(n.h2,{id:"inverted-indexes",children:"Inverted Indexes"}),"\n",(0,r.jsx)(n.h3,{id:"structure",children:"Structure"}),"\n",(0,r.jsx)(n.p,{children:"Inverted indexes map resource attribute values directly to the list of block IDs containing them:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type InvertedIndex struct {\n    // Maps kind \u2192 block IDs\n    KindToBlocks map[string][]int32\n\n    // Maps namespace \u2192 block IDs\n    NamespaceToBlocks map[string][]int32\n\n    // Maps API group \u2192 block IDs\n    GroupToBlocks map[string][]int32\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Index:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "kind_to_blocks": {\n    "Pod": [0, 1, 3, 7, 9, 12, 15],\n    "Deployment": [0, 2, 5, 8, 11],\n    "Service": [0, 4, 6, 10, 14],\n    "ConfigMap": [1, 3, 5, 7, 9, 11, 13]\n  },\n  "namespace_to_blocks": {\n    "default": [0, 1, 2, 3, 4, 5],\n    "kube-system": [6, 7, 8, 9, 10],\n    "production": [11, 12, 13, 14, 15]\n  },\n  "group_to_blocks": {\n    "": [0, 1, 3, 7],           // core API group\n    "apps": [2, 5, 8, 11, 14],\n    "batch": [4, 6, 9, 12]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"query-optimization",children:"Query Optimization"}),"\n",(0,r.jsx)(n.h4,{id:"single-filter",children:"Single Filter"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query:"})," ",(0,r.jsx)(n.code,{children:"kind=Pod"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'candidateBlocks := index.KindToBlocks["Pod"]\n// Result: [0, 1, 3, 7, 9, 12, 15]\n// Skip: 53% of blocks (8 out of 15 skipped)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"multiple-filters-and-logic",children:"Multiple Filters (AND Logic)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query:"})," ",(0,r.jsx)(n.code,{children:"kind=Pod AND namespace=default"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Step 1: Lookup each filter dimension\nkindBlocks := index.KindToBlocks["Pod"]\n// [0, 1, 3, 7, 9, 12, 15]\n\nnamespaceBlocks := index.NamespaceToBlocks["default"]\n// [0, 1, 2, 3, 4, 5]\n\n// Step 2: Compute intersection\ncandidateBlocks := Intersect(kindBlocks, namespaceBlocks)\n// [0, 1, 3] (only blocks with BOTH Pod AND default)\n\n// Skip: 80% of blocks (3 candidates out of 16 total)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"three-way-intersection",children:"Three-Way Intersection"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query:"})," ",(0,r.jsx)(n.code,{children:"kind=Deployment AND namespace=production AND group=apps"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"kindBlocks := [0, 2, 5, 8, 11]\nnamespaceBlocks := [11, 12, 13, 14, 15]\ngroupBlocks := [2, 5, 8, 11, 14]\n\n// Intersection: [11]\n// Skip: 93% of blocks (1 candidate out of 16 total)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"intersection-algorithm",children:"Intersection Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'func GetCandidateBlocks(index *InvertedIndex, filters map[string]string) []int32 {\n    var candidates map[int32]bool\n\n    // For each filter dimension\n    for dimension, value := range filters {\n        var dimensionBlocks []int32\n\n        switch dimension {\n        case "kind":\n            dimensionBlocks = index.KindToBlocks[value]\n        case "namespace":\n            dimensionBlocks = index.NamespaceToBlocks[value]\n        case "group":\n            dimensionBlocks = index.GroupToBlocks[value]\n        }\n\n        // If no blocks contain this value, return empty (early exit)\n        if len(dimensionBlocks) == 0 {\n            return nil\n        }\n\n        if candidates == nil {\n            // First filter: Initialize candidates\n            candidates = make(map[int32]bool)\n            for _, blockID := range dimensionBlocks {\n                candidates[blockID] = true\n            }\n        } else {\n            // Subsequent filters: Intersect with existing candidates\n            newCandidates := make(map[int32]bool)\n            for _, blockID := range dimensionBlocks {\n                if candidates[blockID] {\n                    newCandidates[blockID] = true\n                }\n            }\n            candidates = newCandidates\n        }\n\n        // Early exit if no candidates remain\n        if len(candidates) == 0 {\n            return nil\n        }\n    }\n\n    // Convert map to sorted slice\n    result := make([]int32, 0, len(candidates))\n    for blockID := range candidates {\n        result = append(result, blockID)\n    }\n    return result\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Complexity:"})," O(F \xd7 N) where F = number of filters, N = average blocks per filter value"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimization:"})," Filters are evaluated in sequence with early exit if intersection becomes empty."]}),"\n",(0,r.jsx)(n.h3,{id:"index-build-performance",children:"Index Build Performance"}),"\n",(0,r.jsx)(n.p,{children:"Built at file close time from block metadata:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func BuildInvertedIndexes(blocks []*BlockMetadata) *InvertedIndex {\n    index := &InvertedIndex{\n        KindToBlocks:      make(map[string][]int32),\n        NamespaceToBlocks: make(map[string][]int32),\n        GroupToBlocks:     make(map[string][]int32),\n    }\n\n    for _, block := range blocks {\n        // Add all kinds from this block\n        for _, kind := range block.KindSet {\n            index.KindToBlocks[kind] = append(index.KindToBlocks[kind], block.ID)\n        }\n\n        // Add all namespaces from this block\n        for _, ns := range block.NamespaceSet {\n            index.NamespaceToBlocks[ns] = append(index.NamespaceToBlocks[ns], block.ID)\n        }\n\n        // Add all groups from this block\n        for _, group := range block.GroupSet {\n            index.GroupToBlocks[group] = append(index.GroupToBlocks[group], block.ID)\n        }\n    }\n\n    return index\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Complexity:"})," O(B \xd7 V) where B = number of blocks, V = average unique values per block"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Typical Performance:"})," <500ms for 300 blocks, 60K events (hourly file)"]}),"\n",(0,r.jsx)(n.h2,{id:"bloom-filters",children:"Bloom Filters"}),"\n",(0,r.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsxs)(n.p,{children:["Bloom filters provide ",(0,r.jsx)(n.strong,{children:"space-efficient probabilistic filtering"})," for each block without storing complete value lists."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Property:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"False Positives:"}),' Possible (might say "yes" when answer is "no")']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"False Negatives:"}),' Impossible (never says "no" when answer is "yes")']}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case:"})," Quickly eliminate blocks that definitely don't contain a value."]}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Each block has three Bloom filters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type BlockMetadata struct {\n    BloomFilterKinds      *StandardBloomFilter  // For resource kinds\n    BloomFilterNamespaces *StandardBloomFilter  // For namespaces\n    BloomFilterGroups     *StandardBloomFilter  // For API groups\n    // ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Filter Parameters:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Filter Type"}),(0,r.jsx)(n.th,{children:"Expected Elements"}),(0,r.jsx)(n.th,{children:"False Positive Rate"}),(0,r.jsx)(n.th,{children:"Hash Functions"}),(0,r.jsx)(n.th,{children:"Bit Array Size"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Kinds"}),(0,r.jsx)(n.td,{children:"1000"}),(0,r.jsx)(n.td,{children:"0.05 (5%)"}),(0,r.jsx)(n.td,{children:"~4"}),(0,r.jsx)(n.td,{children:"~1.2 KB"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Namespaces"}),(0,r.jsx)(n.td,{children:"100"}),(0,r.jsx)(n.td,{children:"0.05 (5%)"}),(0,r.jsx)(n.td,{children:"~4"}),(0,r.jsx)(n.td,{children:"~120 bytes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Groups"}),(0,r.jsx)(n.td,{children:"100"}),(0,r.jsx)(n.td,{children:"0.05 (5%)"}),(0,r.jsx)(n.td,{children:"~4"}),(0,r.jsx)(n.td,{children:"~120 bytes"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Total Overhead:"})," ~1.5 KB per block (minimal compared to 10 MB block data)"]}),"\n",(0,r.jsx)(n.h3,{id:"how-bloom-filters-work",children:"How Bloom Filters Work"}),"\n",(0,r.jsx)(n.h4,{id:"adding-values-write-time",children:"Adding Values (Write Time)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// When building a block, add each value to its Bloom filter\nfor _, event := range events {\n    block.BloomFilterKinds.Add(event.Resource.Kind)\n    block.BloomFilterNamespaces.Add(event.Resource.Namespace)\n    block.BloomFilterGroups.Add(event.Resource.Group)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Hash the value with K hash functions (typically 4)"}),"\n",(0,r.jsx)(n.li,{children:"Set K bits in the bit array to 1"}),"\n",(0,r.jsx)(n.li,{children:"Repeat for all values"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"checking-values-query-time",children:"Checking Values (Query Time)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Check if block might contain a value\nif !block.BloomFilterKinds.Contains("Pod") {\n    // Definitely does NOT contain "Pod" \u2192 skip this block\n    return false\n}\n\n// Might contain "Pod" (or false positive) \u2192 need to check further\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Hash the query value with same K hash functions"}),"\n",(0,r.jsx)(n.li,{children:"Check if all K bits are set to 1"}),"\n",(0,r.jsxs)(n.li,{children:["If any bit is 0: ",(0,r.jsx)(n.strong,{children:"definitely not present"})," (skip block)"]}),"\n",(0,r.jsxs)(n.li,{children:["If all bits are 1: ",(0,r.jsx)(n.strong,{children:"maybe present"})," (check with inverted index or decompress)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"false-positive-rate",children:"False Positive Rate"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Single Filter:"})," 5% (configured)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Combined (3 filters with AND logic):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"P(false positive) = 1 - (1 - 0.05)\xb3\n                  = 1 - 0.857\n                  \u2248 14.3%\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Impact:"})," Out of 100 blocks, ~14 might be false positives (scanned unnecessarily)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Acceptable Trade-off:"})," 14% extra decompression vs 100% without filtering"]}),"\n",(0,r.jsx)(n.h3,{id:"space-efficiency-comparison",children:"Space Efficiency Comparison"}),"\n",(0,r.jsx)(n.p,{children:"For a block with 800 events, 50 unique kinds, 10 namespaces, 5 groups:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Approach"}),(0,r.jsx)(n.th,{children:"Storage Size"}),(0,r.jsx)(n.th,{children:"Lookup Speed"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Exact Sets"})}),(0,r.jsx)(n.td,{children:"~2 KB"}),(0,r.jsx)(n.td,{children:"O(N)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bloom Filters"})}),(0,r.jsx)(n.td,{children:"~1.5 KB"}),(0,r.jsx)(n.td,{children:"O(k) = O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"No Filter"})}),(0,r.jsx)(n.td,{children:"0 bytes"}),(0,r.jsx)(n.td,{children:"Decompress"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Bloom filters save space while providing fast lookups (4-5 hash operations vs decompressing 10 MB)."})}),"\n",(0,r.jsx)(n.h2,{id:"timestamp-indexes",children:"Timestamp Indexes"}),"\n",(0,r.jsx)(n.h3,{id:"block-level-time-ranges",children:"Block-Level Time Ranges"}),"\n",(0,r.jsx)(n.p,{children:"Each block metadata stores the min/max event timestamps:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type BlockMetadata struct {\n    TimestampMin int64  // Earliest event in block (nanoseconds)\n    TimestampMax int64  // Latest event in block (nanoseconds)\n    // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"time-range-filtering",children:"Time Range Filtering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query:"})," ",(0,r.jsx)(n.code,{children:"startTime=1733915200000000000, endTime=1733918800000000000"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"for _, blockMeta := range blocks {\n    // Check if block overlaps query time range\n    if blockMeta.TimestampMax < query.StartTime {\n        continue  // Block ends before query starts \u2192 skip\n    }\n    if blockMeta.TimestampMin > query.EndTime {\n        continue  // Block starts after query ends \u2192 skip\n    }\n\n    // Block overlaps query range \u2192 candidate for reading\n    candidateBlocks = append(candidateBlocks, blockMeta.ID)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Complexity:"})," O(B) where B = number of blocks"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Typical Skip Rate:"})," 30-60% for time-limited queries (e.g., last 1 hour out of 24-hour file)"]}),"\n",(0,r.jsx)(n.h2,{id:"multi-stage-filtering-pipeline",children:"Multi-Stage Filtering Pipeline"}),"\n",(0,r.jsx)(n.h3,{id:"complete-query-execution-flow",children:"Complete Query Execution Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Query: kind=Pod, namespace=default, time=[10:00, 11:00]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stage 1: File Selection (by hour)                          \u2502\n\u2502 All files: 24 hourly files (1 day)                         \u2502\n\u2502 Filtered: 2 files (10:00-10:59, 11:00-11:59)              \u2502\n\u2502 Skip Rate: 91% of files (22 skipped)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stage 2: Inverted Index Filtering                          \u2502\n\u2502 Total blocks: 600 (2 files \xd7 300 blocks/file)              \u2502\n\u2502 kind=Pod: [0-50] (50 blocks)                               \u2502\n\u2502 namespace=default: [0-30] (30 blocks)                      \u2502\n\u2502 Intersection: [0-15] (15 blocks)                           \u2502\n\u2502 Skip Rate: 97.5% of blocks (585 skipped)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stage 3: Bloom Filter Verification                         \u2502\n\u2502 Candidates: 15 blocks                                       \u2502\n\u2502 Bloom filter checks: 15 \xd7 2 filters = 30 checks            \u2502\n\u2502 False positives: ~2 blocks (14.3% FP rate)                 \u2502\n\u2502 True candidates: 13 blocks                                  \u2502\n\u2502 Skip Rate: 13% additional (2 blocks)                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stage 4: Timestamp Filtering                               \u2502\n\u2502 Candidates: 13 blocks                                       \u2502\n\u2502 Time range overlap: 8 blocks                                \u2502\n\u2502 Skip Rate: 38% additional (5 blocks)                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stage 5: Decompression & Event Scanning                    \u2502\n\u2502 Blocks to decompress: 8 (1.3% of original 600)             \u2502\n\u2502 Overall Skip Rate: 98.7%                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Stage"}),(0,r.jsx)(n.th,{children:"Input"}),(0,r.jsx)(n.th,{children:"Output"}),(0,r.jsx)(n.th,{children:"Skip Rate"}),(0,r.jsx)(n.th,{children:"Latency"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"File Selection"}),(0,r.jsx)(n.td,{children:"24 files"}),(0,r.jsx)(n.td,{children:"2 files"}),(0,r.jsx)(n.td,{children:"91%"}),(0,r.jsx)(n.td,{children:"<1 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Inverted Index"}),(0,r.jsx)(n.td,{children:"600 blocks"}),(0,r.jsx)(n.td,{children:"15 blocks"}),(0,r.jsx)(n.td,{children:"97.5%"}),(0,r.jsx)(n.td,{children:"~2 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bloom Filters"}),(0,r.jsx)(n.td,{children:"15 blocks"}),(0,r.jsx)(n.td,{children:"13 blocks"}),(0,r.jsx)(n.td,{children:"13%"}),(0,r.jsx)(n.td,{children:"<1 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Timestamp Filter"}),(0,r.jsx)(n.td,{children:"13 blocks"}),(0,r.jsx)(n.td,{children:"8 blocks"}),(0,r.jsx)(n.td,{children:"38%"}),(0,r.jsx)(n.td,{children:"<1 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Decompression"}),(0,r.jsx)(n.td,{children:"8 blocks"}),(0,r.jsx)(n.td,{children:"8 blocks"}),(0,r.jsx)(n.td,{children:"0%"}),(0,r.jsx)(n.td,{children:"~240 ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"600"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"8"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"98.7%"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"~245 ms"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result:"})," Query processes only 1.3% of total blocks, dramatically reducing I/O and decompression overhead."]}),"\n",(0,r.jsx)(n.h2,{id:"index-memory-footprint",children:"Index Memory Footprint"}),"\n",(0,r.jsx)(n.h3,{id:"per-file-index-size",children:"Per-File Index Size"}),"\n",(0,r.jsx)(n.p,{children:"For a typical hourly file with 300 blocks:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Size"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Block Metadata Array"}),(0,r.jsx)(n.td,{children:"~600 KB"}),(0,r.jsx)(n.td,{children:"300 blocks \xd7 2 KB metadata each"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Inverted Indexes"}),(0,r.jsx)(n.td,{children:"~200 KB"}),(0,r.jsx)(n.td,{children:"Maps for kinds, namespaces, groups"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bloom Filters"}),(0,r.jsx)(n.td,{children:"~450 KB"}),(0,r.jsx)(n.td,{children:"300 blocks \xd7 1.5 KB filters"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Statistics"}),(0,r.jsx)(n.td,{children:"~1 KB"}),(0,r.jsx)(n.td,{children:"File-level stats"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total Index"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"~1.25 MB"})}),(0,r.jsx)(n.td,{children:"Per hourly file"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"system-wide-memory-usage",children:"System-Wide Memory Usage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario:"})," 168 hourly files (1 week retention)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Total Index Memory = 168 files \xd7 1.25 MB/file\n                   = 210 MB\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimization:"})," Indexes loaded on-demand (only for files matching query time range)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Typical Query:"})," Loads 1-24 files \u2192 1.25-30 MB index memory"]}),"\n",(0,r.jsx)(n.h2,{id:"index-persistence",children:"Index Persistence"}),"\n",(0,r.jsxs)(n.p,{children:["Indexes are ",(0,r.jsx)(n.strong,{children:"stored in the file"})," (not external):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"File Structure:\n\u251c\u2500 Header (77 bytes)\n\u251c\u2500 Blocks (compressed events)\n\u251c\u2500 Index Section (JSON)  \u2190 Inverted indexes stored here\n\u2502   \u251c\u2500 Block Metadata (with Bloom filters)\n\u2502   \u251c\u2500 Inverted Indexes (kind/namespace/group maps)\n\u2502   \u2514\u2500 Statistics\n\u2514\u2500 Footer (324 bytes)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No external dependencies:"})," No separate index database"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Portability:"})," Copy file, get indexes for free"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Crash safety:"})," Indexes built atomically at file close"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Version alignment:"})," Index always matches block data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"query-without-indexes",children:"Query Without Indexes"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What if indexes are missing or corrupted?"})}),"\n",(0,r.jsx)(n.p,{children:"Fallback: Sequential scan of all blocks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Read all block metadata (still available in footer)\n2. Decompress each block\n3. Scan events linearly\n4. Filter in-memory\n\nPerformance: 100\xd7 slower but still works\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case:"})," Recovery tool for corrupted index sections"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/spectre/docs/architecture/storage-design",children:"Storage Design"})," - Overall architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/spectre/docs/architecture/block-format",children:"Block Format Reference"})," - Index section format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/spectre/docs/architecture/query-execution",children:"Query Execution"})," - Complete query pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/spectre/docs/architecture/compression",children:"Compression"})," - Block compression details"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);